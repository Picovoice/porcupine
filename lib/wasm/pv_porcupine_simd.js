
var pv_porcupine_simd = (() => {
  var _scriptName = typeof document != 'undefined' ? document.currentScript?.src : undefined;
  
  return (
function(moduleArg = {}) {
  var moduleRtn;

var Module=moduleArg;var readyPromiseResolve,readyPromiseReject;var readyPromise=new Promise((resolve,reject)=>{readyPromiseResolve=resolve;readyPromiseReject=reject});var ENVIRONMENT_IS_WEB=typeof window=="object";var ENVIRONMENT_IS_WORKER=typeof importScripts=="function";var ENVIRONMENT_IS_NODE=typeof process=="object"&&typeof process.versions=="object"&&typeof process.versions.node=="string";function _typeof$2(o){null;return _typeof$2="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(o){return typeof o}:function(o){return o&&"function"==typeof Symbol&&o.constructor===Symbol&&o!==Symbol.prototype?"symbol":typeof o},_typeof$2(o)}function toPrimitive(t,r){if("object"!=_typeof$2(t)||!t)return t;var e=t[Symbol.toPrimitive];if(void 0!==e){var i=e.call(t,r||"default");if("object"!=_typeof$2(i))return i;throw new TypeError("@@toPrimitive must return a primitive value.")}return("string"===r?String:Number)(t)}function toPropertyKey(t){var i=toPrimitive(t,"string");return"symbol"==_typeof$2(i)?i:i+""}function _defineProperty(e,r,t){return(r=toPropertyKey(r))in e?Object.defineProperty(e,r,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[r]=t,e}function asyncGeneratorStep(n,t,e,r,o,a,c){try{var i=n[a](c),u=i.value}catch(n){return void e(n)}i.done?t(u):Promise.resolve(u).then(r,o)}function _asyncToGenerator(n){return function(){var t=this,e=arguments;return new Promise(function(r,o){var a=n.apply(t,e);function _next(n){asyncGeneratorStep(a,r,o,_next,_throw,"next",n)}function _throw(n){asyncGeneratorStep(a,r,o,_next,_throw,"throw",n)}_next(void 0)})}}function getDefaultExportFromCjs(x){return x&&x.__esModule&&Object.prototype.hasOwnProperty.call(x,"default")?x["default"]:x}var regeneratorRuntime$3={exports:{}};var _typeof$1={exports:{}};var _typeof_1=_typeof$1.exports;(function(module){function _typeof(o){null;return module.exports=_typeof="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(o){return typeof o}:function(o){return o&&"function"==typeof Symbol&&o.constructor===Symbol&&o!==Symbol.prototype?"symbol":typeof o},module.exports.__esModule=true,module.exports["default"]=module.exports,_typeof(o)}module.exports=_typeof,module.exports.__esModule=true,module.exports["default"]=module.exports})(_typeof$1);var _typeofExports=_typeof$1.exports;var _typeof=getDefaultExportFromCjs(_typeofExports);var regeneratorRuntime$1=regeneratorRuntime$3.exports;(function(module){var _typeof=_typeofExports["default"];function _regeneratorRuntime(){"use strict";module.exports=_regeneratorRuntime=function _regeneratorRuntime(){return e},module.exports.__esModule=true,module.exports["default"]=module.exports;var t,e={},r=Object.prototype,n=r.hasOwnProperty,o=Object.defineProperty||function(t,e,r){t[e]=r.value},i="function"==typeof Symbol?Symbol:{},a=i.iterator||"@@iterator",c=i.asyncIterator||"@@asyncIterator",u=i.toStringTag||"@@toStringTag";function define(t,e,r){return Object.defineProperty(t,e,{value:r,enumerable:!0,configurable:!0,writable:!0}),t[e]}try{define({},"")}catch(t){define=function define(t,e,r){return t[e]=r}}function wrap(t,e,r,n){var i=e&&e.prototype instanceof Generator?e:Generator,a=Object.create(i.prototype),c=new Context(n||[]);return o(a,"_invoke",{value:makeInvokeMethod(t,r,c)}),a}function tryCatch(t,e,r){try{return{type:"normal",arg:t.call(e,r)}}catch(t){return{type:"throw",arg:t}}}e.wrap=wrap;var h="suspendedStart",l="suspendedYield",f="executing",s="completed",y={};function Generator(){}function GeneratorFunction(){}function GeneratorFunctionPrototype(){}var p={};define(p,a,function(){return this});var d=Object.getPrototypeOf,v=d&&d(d(values([])));v&&v!==r&&n.call(v,a)&&(p=v);var g=GeneratorFunctionPrototype.prototype=Generator.prototype=Object.create(p);function defineIteratorMethods(t){["next","throw","return"].forEach(function(e){define(t,e,function(t){return this._invoke(e,t)})})}function AsyncIterator(t,e){function invoke(r,o,i,a){var c=tryCatch(t[r],t,o);if("throw"!==c.type){var u=c.arg,h=u.value;return h&&"object"==_typeof(h)&&n.call(h,"__await")?e.resolve(h.__await).then(function(t){invoke("next",t,i,a)},function(t){invoke("throw",t,i,a)}):e.resolve(h).then(function(t){u.value=t,i(u)},function(t){return invoke("throw",t,i,a)})}a(c.arg)}var r;o(this,"_invoke",{value:function value(t,n){function callInvokeWithMethodAndArg(){return new e(function(e,r){invoke(t,n,e,r)})}return r=r?r.then(callInvokeWithMethodAndArg,callInvokeWithMethodAndArg):callInvokeWithMethodAndArg()}})}function makeInvokeMethod(e,r,n){var o=h;return function(i,a){if(o===f)throw Error("Generator is already running");if(o===s){if("throw"===i)throw a;return{value:t,done:!0}}for(n.method=i,n.arg=a;;){var c=n.delegate;if(c){var u=maybeInvokeDelegate(c,n);if(u){if(u===y)continue;return u}}if("next"===n.method)n.sent=n._sent=n.arg;else if("throw"===n.method){if(o===h)throw o=s,n.arg;n.dispatchException(n.arg)}else"return"===n.method&&n.abrupt("return",n.arg);o=f;var p=tryCatch(e,r,n);if("normal"===p.type){if(o=n.done?s:l,p.arg===y)continue;return{value:p.arg,done:n.done}}"throw"===p.type&&(o=s,n.method="throw",n.arg=p.arg)}}}function maybeInvokeDelegate(e,r){var n=r.method,o=e.iterator[n];if(o===t)return r.delegate=null,"throw"===n&&e.iterator["return"]&&(r.method="return",r.arg=t,maybeInvokeDelegate(e,r),"throw"===r.method)||"return"!==n&&(r.method="throw",r.arg=new TypeError("The iterator does not provide a '"+n+"' method")),y;var i=tryCatch(o,e.iterator,r.arg);if("throw"===i.type)return r.method="throw",r.arg=i.arg,r.delegate=null,y;var a=i.arg;return a?a.done?(r[e.resultName]=a.value,r.next=e.nextLoc,"return"!==r.method&&(r.method="next",r.arg=t),r.delegate=null,y):a:(r.method="throw",r.arg=new TypeError("iterator result is not an object"),r.delegate=null,y)}function pushTryEntry(t){var e={tryLoc:t[0]};1 in t&&(e.catchLoc=t[1]),2 in t&&(e.finallyLoc=t[2],e.afterLoc=t[3]),this.tryEntries.push(e)}function resetTryEntry(t){var e=t.completion||{};e.type="normal",delete e.arg,t.completion=e}function Context(t){this.tryEntries=[{tryLoc:"root"}],t.forEach(pushTryEntry,this),this.reset(!0)}function values(e){if(e||""===e){var r=e[a];if(r)return r.call(e);if("function"==typeof e.next)return e;if(!isNaN(e.length)){var o=-1,i=function next(){for(;++o<e.length;)if(n.call(e,o))return next.value=e[o],next.done=!1,next;return next.value=t,next.done=!0,next};return i.next=i}}throw new TypeError(_typeof(e)+" is not iterable")}return GeneratorFunction.prototype=GeneratorFunctionPrototype,o(g,"constructor",{value:GeneratorFunctionPrototype,configurable:!0}),o(GeneratorFunctionPrototype,"constructor",{value:GeneratorFunction,configurable:!0}),GeneratorFunction.displayName=define(GeneratorFunctionPrototype,u,"GeneratorFunction"),e.isGeneratorFunction=function(t){var e="function"==typeof t&&t.constructor;return!!e&&(e===GeneratorFunction||"GeneratorFunction"===(e.displayName||e.name))},e.mark=function(t){return Object.setPrototypeOf?Object.setPrototypeOf(t,GeneratorFunctionPrototype):(t.__proto__=GeneratorFunctionPrototype,define(t,u,"GeneratorFunction")),t.prototype=Object.create(g),t},e.awrap=function(t){return{__await:t}},defineIteratorMethods(AsyncIterator.prototype),define(AsyncIterator.prototype,c,function(){return this}),e.AsyncIterator=AsyncIterator,e.async=function(t,r,n,o,i){void 0===i&&(i=Promise);var a=new AsyncIterator(wrap(t,r,n,o),i);return e.isGeneratorFunction(r)?a:a.next().then(function(t){return t.done?t.value:a.next()})},defineIteratorMethods(g),define(g,u,"Generator"),define(g,a,function(){return this}),define(g,"toString",function(){return"[object Generator]"}),e.keys=function(t){var e=Object(t),r=[];for(var n in e)r.push(n);return r.reverse(),function next(){for(;r.length;){var t=r.pop();if(t in e)return next.value=t,next.done=!1,next}return next.done=!0,next}},e.values=values,Context.prototype={constructor:Context,reset:function reset(e){if(this.prev=0,this.next=0,this.sent=this._sent=t,this.done=!1,this.delegate=null,this.method="next",this.arg=t,this.tryEntries.forEach(resetTryEntry),!e)for(var r in this)"t"===r.charAt(0)&&n.call(this,r)&&!isNaN(+r.slice(1))&&(this[r]=t)},stop:function stop(){this.done=!0;var t=this.tryEntries[0].completion;if("throw"===t.type)throw t.arg;return this.rval},dispatchException:function dispatchException(e){if(this.done)throw e;var r=this;function handle(n,o){return a.type="throw",a.arg=e,r.next=n,o&&(r.method="next",r.arg=t),!!o}for(var o=this.tryEntries.length-1;o>=0;--o){var i=this.tryEntries[o],a=i.completion;if("root"===i.tryLoc)return handle("end");if(i.tryLoc<=this.prev){var c=n.call(i,"catchLoc"),u=n.call(i,"finallyLoc");if(c&&u){if(this.prev<i.catchLoc)return handle(i.catchLoc,!0);if(this.prev<i.finallyLoc)return handle(i.finallyLoc)}else if(c){if(this.prev<i.catchLoc)return handle(i.catchLoc,!0)}else{if(!u)throw Error("try statement without catch or finally");if(this.prev<i.finallyLoc)return handle(i.finallyLoc)}}}},abrupt:function abrupt(t,e){for(var r=this.tryEntries.length-1;r>=0;--r){var o=this.tryEntries[r];if(o.tryLoc<=this.prev&&n.call(o,"finallyLoc")&&this.prev<o.finallyLoc){var i=o;break}}i&&("break"===t||"continue"===t)&&i.tryLoc<=e&&e<=i.finallyLoc&&(i=null);var a=i?i.completion:{};return a.type=t,a.arg=e,i?(this.method="next",this.next=i.finallyLoc,y):this.complete(a)},complete:function complete(t,e){if("throw"===t.type)throw t.arg;return"break"===t.type||"continue"===t.type?this.next=t.arg:"return"===t.type?(this.rval=this.arg=t.arg,this.method="return",this.next="end"):"normal"===t.type&&e&&(this.next=e),y},finish:function finish(t){for(var e=this.tryEntries.length-1;e>=0;--e){var r=this.tryEntries[e];if(r.finallyLoc===t)return this.complete(r.completion,r.afterLoc),resetTryEntry(r),y}},catch:function _catch(t){for(var e=this.tryEntries.length-1;e>=0;--e){var r=this.tryEntries[e];if(r.tryLoc===t){var n=r.completion;if("throw"===n.type){var o=n.arg;resetTryEntry(r)}return o}}throw Error("illegal catch attempt")},delegateYield:function delegateYield(e,r,n){return this.delegate={iterator:values(e),resultName:r,nextLoc:n},"next"===this.method&&(this.arg=t),y}},e}module.exports=_regeneratorRuntime,module.exports.__esModule=true,module.exports["default"]=module.exports})(regeneratorRuntime$3);var regeneratorRuntimeExports=regeneratorRuntime$3.exports;var regeneratorRuntime$2=getDefaultExportFromCjs(regeneratorRuntimeExports);var runtime=regeneratorRuntimeExports();var regenerator=runtime;try{regeneratorRuntime=runtime}catch(accidentalStrictMode){if(typeof globalThis==="object"){globalThis.regeneratorRuntime=runtime}else{Function("r","regeneratorRuntime = r")(runtime)}}var _regeneratorRuntime=getDefaultExportFromCjs(regenerator);const BROWSER_ALIASES_MAP={"Amazon Silk":"amazon_silk","Android Browser":"android",Bada:"bada",BlackBerry:"blackberry",Chrome:"chrome",Chromium:"chromium",Electron:"electron",Epiphany:"epiphany",Firefox:"firefox",Focus:"focus",Generic:"generic","Google Search":"google_search",Googlebot:"googlebot","Internet Explorer":"ie","K-Meleon":"k_meleon",Maxthon:"maxthon","Microsoft Edge":"edge","MZ Browser":"mz","NAVER Whale Browser":"naver",Opera:"opera","Opera Coast":"opera_coast",PhantomJS:"phantomjs",Puffin:"puffin",QupZilla:"qupzilla",QQ:"qq",QQLite:"qqlite",Safari:"safari",Sailfish:"sailfish","Samsung Internet for Android":"samsung_internet",SeaMonkey:"seamonkey",Sleipnir:"sleipnir",Swing:"swing",Tizen:"tizen","UC Browser":"uc",Vivaldi:"vivaldi","WebOS Browser":"webos",WeChat:"wechat","Yandex Browser":"yandex",Roku:"roku"};const BROWSER_MAP={amazon_silk:"Amazon Silk",android:"Android Browser",bada:"Bada",blackberry:"BlackBerry",chrome:"Chrome",chromium:"Chromium",electron:"Electron",epiphany:"Epiphany",firefox:"Firefox",focus:"Focus",generic:"Generic",googlebot:"Googlebot",google_search:"Google Search",ie:"Internet Explorer",k_meleon:"K-Meleon",maxthon:"Maxthon",edge:"Microsoft Edge",mz:"MZ Browser",naver:"NAVER Whale Browser",opera:"Opera",opera_coast:"Opera Coast",phantomjs:"PhantomJS",puffin:"Puffin",qupzilla:"QupZilla",qq:"QQ Browser",qqlite:"QQ Browser Lite",safari:"Safari",sailfish:"Sailfish",samsung_internet:"Samsung Internet for Android",seamonkey:"SeaMonkey",sleipnir:"Sleipnir",swing:"Swing",tizen:"Tizen",uc:"UC Browser",vivaldi:"Vivaldi",webos:"WebOS Browser",wechat:"WeChat",yandex:"Yandex Browser"};const PLATFORMS_MAP={tablet:"tablet",mobile:"mobile",desktop:"desktop",tv:"tv"};const OS_MAP={WindowsPhone:"Windows Phone",Windows:"Windows",MacOS:"macOS",iOS:"iOS",Android:"Android",WebOS:"WebOS",BlackBerry:"BlackBerry",Bada:"Bada",Tizen:"Tizen",Linux:"Linux",ChromeOS:"Chrome OS",PlayStation4:"PlayStation 4",Roku:"Roku"};const ENGINE_MAP={EdgeHTML:"EdgeHTML",Blink:"Blink",Trident:"Trident",Presto:"Presto",Gecko:"Gecko",WebKit:"WebKit"};class Utils{static getFirstMatch(regexp,ua){const match=ua.match(regexp);return match&&match.length>0&&match[1]||""}static getSecondMatch(regexp,ua){const match=ua.match(regexp);return match&&match.length>1&&match[2]||""}static matchAndReturnConst(regexp,ua,_const){if(regexp.test(ua)){return _const}return void 0}static getWindowsVersionName(version){switch(version){case"NT":return"NT";case"XP":return"XP";case"NT 5.0":return"2000";case"NT 5.1":return"XP";case"NT 5.2":return"2003";case"NT 6.0":return"Vista";case"NT 6.1":return"7";case"NT 6.2":return"8";case"NT 6.3":return"8.1";case"NT 10.0":return"10";default:return undefined}}static getMacOSVersionName(version){const v=version.split(".").splice(0,2).map(s=>parseInt(s,10)||0);v.push(0);if(v[0]!==10)return undefined;switch(v[1]){case 5:return"Leopard";case 6:return"Snow Leopard";case 7:return"Lion";case 8:return"Mountain Lion";case 9:return"Mavericks";case 10:return"Yosemite";case 11:return"El Capitan";case 12:return"Sierra";case 13:return"High Sierra";case 14:return"Mojave";case 15:return"Catalina";default:return undefined}}static getAndroidVersionName(version){const v=version.split(".").splice(0,2).map(s=>parseInt(s,10)||0);v.push(0);if(v[0]===1&&v[1]<5)return undefined;if(v[0]===1&&v[1]<6)return"Cupcake";if(v[0]===1&&v[1]>=6)return"Donut";if(v[0]===2&&v[1]<2)return"Eclair";if(v[0]===2&&v[1]===2)return"Froyo";if(v[0]===2&&v[1]>2)return"Gingerbread";if(v[0]===3)return"Honeycomb";if(v[0]===4&&v[1]<1)return"Ice Cream Sandwich";if(v[0]===4&&v[1]<4)return"Jelly Bean";if(v[0]===4&&v[1]>=4)return"KitKat";if(v[0]===5)return"Lollipop";if(v[0]===6)return"Marshmallow";if(v[0]===7)return"Nougat";if(v[0]===8)return"Oreo";if(v[0]===9)return"Pie";return undefined}static getVersionPrecision(version){return version.split(".").length}static compareVersions(versionA,versionB,isLoose=false){const versionAPrecision=Utils.getVersionPrecision(versionA);const versionBPrecision=Utils.getVersionPrecision(versionB);let precision=Math.max(versionAPrecision,versionBPrecision);let lastPrecision=0;const chunks=Utils.map([versionA,versionB],version=>{const delta=precision-Utils.getVersionPrecision(version);const _version=version+new Array(delta+1).join(".0");return Utils.map(_version.split("."),chunk=>new Array(20-chunk.length).join("0")+chunk).reverse()});if(isLoose){lastPrecision=precision-Math.min(versionAPrecision,versionBPrecision)}precision-=1;while(precision>=lastPrecision){if(chunks[0][precision]>chunks[1][precision]){return 1}if(chunks[0][precision]===chunks[1][precision]){if(precision===lastPrecision){return 0}precision-=1}else if(chunks[0][precision]<chunks[1][precision]){return-1}}return undefined}static map(arr,iterator){const result=[];let i;if(Array.prototype.map){return Array.prototype.map.call(arr,iterator)}for(i=0;i<arr.length;i+=1){result.push(iterator(arr[i]))}return result}static find(arr,predicate){let i;let l;if(Array.prototype.find){return Array.prototype.find.call(arr,predicate)}for(i=0,l=arr.length;i<l;i+=1){const value=arr[i];if(predicate(value,i)){return value}}return undefined}static assign(obj,...assigners){const result=obj;let i;let l;if(Object.assign){return Object.assign(obj,...assigners)}for(i=0,l=assigners.length;i<l;i+=1){const assigner=assigners[i];if(typeof assigner==="object"&&assigner!==null){const keys=Object.keys(assigner);keys.forEach(key=>{result[key]=assigner[key]})}}return obj}static getBrowserAlias(browserName){return BROWSER_ALIASES_MAP[browserName]}static getBrowserTypeByAlias(browserAlias){return BROWSER_MAP[browserAlias]||""}}const commonVersionIdentifier=/version\/(\d+(\.?_?\d+)+)/i;const browsersList=[{test:[/googlebot/i],describe(ua){const browser={name:"Googlebot"};const version=Utils.getFirstMatch(/googlebot\/(\d+(\.\d+))/i,ua)||Utils.getFirstMatch(commonVersionIdentifier,ua);if(version){browser.version=version}return browser}},{test:[/opera/i],describe(ua){const browser={name:"Opera"};const version=Utils.getFirstMatch(commonVersionIdentifier,ua)||Utils.getFirstMatch(/(?:opera)[\s/](\d+(\.?_?\d+)+)/i,ua);if(version){browser.version=version}return browser}},{test:[/opr\/|opios/i],describe(ua){const browser={name:"Opera"};const version=Utils.getFirstMatch(/(?:opr|opios)[\s/](\S+)/i,ua)||Utils.getFirstMatch(commonVersionIdentifier,ua);if(version){browser.version=version}return browser}},{test:[/SamsungBrowser/i],describe(ua){const browser={name:"Samsung Internet for Android"};const version=Utils.getFirstMatch(commonVersionIdentifier,ua)||Utils.getFirstMatch(/(?:SamsungBrowser)[\s/](\d+(\.?_?\d+)+)/i,ua);if(version){browser.version=version}return browser}},{test:[/Whale/i],describe(ua){const browser={name:"NAVER Whale Browser"};const version=Utils.getFirstMatch(commonVersionIdentifier,ua)||Utils.getFirstMatch(/(?:whale)[\s/](\d+(?:\.\d+)+)/i,ua);if(version){browser.version=version}return browser}},{test:[/MZBrowser/i],describe(ua){const browser={name:"MZ Browser"};const version=Utils.getFirstMatch(/(?:MZBrowser)[\s/](\d+(?:\.\d+)+)/i,ua)||Utils.getFirstMatch(commonVersionIdentifier,ua);if(version){browser.version=version}return browser}},{test:[/focus/i],describe(ua){const browser={name:"Focus"};const version=Utils.getFirstMatch(/(?:focus)[\s/](\d+(?:\.\d+)+)/i,ua)||Utils.getFirstMatch(commonVersionIdentifier,ua);if(version){browser.version=version}return browser}},{test:[/swing/i],describe(ua){const browser={name:"Swing"};const version=Utils.getFirstMatch(/(?:swing)[\s/](\d+(?:\.\d+)+)/i,ua)||Utils.getFirstMatch(commonVersionIdentifier,ua);if(version){browser.version=version}return browser}},{test:[/coast/i],describe(ua){const browser={name:"Opera Coast"};const version=Utils.getFirstMatch(commonVersionIdentifier,ua)||Utils.getFirstMatch(/(?:coast)[\s/](\d+(\.?_?\d+)+)/i,ua);if(version){browser.version=version}return browser}},{test:[/opt\/\d+(?:.?_?\d+)+/i],describe(ua){const browser={name:"Opera Touch"};const version=Utils.getFirstMatch(/(?:opt)[\s/](\d+(\.?_?\d+)+)/i,ua)||Utils.getFirstMatch(commonVersionIdentifier,ua);if(version){browser.version=version}return browser}},{test:[/yabrowser/i],describe(ua){const browser={name:"Yandex Browser"};const version=Utils.getFirstMatch(/(?:yabrowser)[\s/](\d+(\.?_?\d+)+)/i,ua)||Utils.getFirstMatch(commonVersionIdentifier,ua);if(version){browser.version=version}return browser}},{test:[/ucbrowser/i],describe(ua){const browser={name:"UC Browser"};const version=Utils.getFirstMatch(commonVersionIdentifier,ua)||Utils.getFirstMatch(/(?:ucbrowser)[\s/](\d+(\.?_?\d+)+)/i,ua);if(version){browser.version=version}return browser}},{test:[/Maxthon|mxios/i],describe(ua){const browser={name:"Maxthon"};const version=Utils.getFirstMatch(commonVersionIdentifier,ua)||Utils.getFirstMatch(/(?:Maxthon|mxios)[\s/](\d+(\.?_?\d+)+)/i,ua);if(version){browser.version=version}return browser}},{test:[/epiphany/i],describe(ua){const browser={name:"Epiphany"};const version=Utils.getFirstMatch(commonVersionIdentifier,ua)||Utils.getFirstMatch(/(?:epiphany)[\s/](\d+(\.?_?\d+)+)/i,ua);if(version){browser.version=version}return browser}},{test:[/puffin/i],describe(ua){const browser={name:"Puffin"};const version=Utils.getFirstMatch(commonVersionIdentifier,ua)||Utils.getFirstMatch(/(?:puffin)[\s/](\d+(\.?_?\d+)+)/i,ua);if(version){browser.version=version}return browser}},{test:[/sleipnir/i],describe(ua){const browser={name:"Sleipnir"};const version=Utils.getFirstMatch(commonVersionIdentifier,ua)||Utils.getFirstMatch(/(?:sleipnir)[\s/](\d+(\.?_?\d+)+)/i,ua);if(version){browser.version=version}return browser}},{test:[/k-meleon/i],describe(ua){const browser={name:"K-Meleon"};const version=Utils.getFirstMatch(commonVersionIdentifier,ua)||Utils.getFirstMatch(/(?:k-meleon)[\s/](\d+(\.?_?\d+)+)/i,ua);if(version){browser.version=version}return browser}},{test:[/micromessenger/i],describe(ua){const browser={name:"WeChat"};const version=Utils.getFirstMatch(/(?:micromessenger)[\s/](\d+(\.?_?\d+)+)/i,ua)||Utils.getFirstMatch(commonVersionIdentifier,ua);if(version){browser.version=version}return browser}},{test:[/qqbrowser/i],describe(ua){const browser={name:/qqbrowserlite/i.test(ua)?"QQ Browser Lite":"QQ Browser"};const version=Utils.getFirstMatch(/(?:qqbrowserlite|qqbrowser)[/](\d+(\.?_?\d+)+)/i,ua)||Utils.getFirstMatch(commonVersionIdentifier,ua);if(version){browser.version=version}return browser}},{test:[/msie|trident/i],describe(ua){const browser={name:"Internet Explorer"};const version=Utils.getFirstMatch(/(?:msie |rv:)(\d+(\.?_?\d+)+)/i,ua);if(version){browser.version=version}return browser}},{test:[/\sedg\//i],describe(ua){const browser={name:"Microsoft Edge"};const version=Utils.getFirstMatch(/\sedg\/(\d+(\.?_?\d+)+)/i,ua);if(version){browser.version=version}return browser}},{test:[/edg([ea]|ios)/i],describe(ua){const browser={name:"Microsoft Edge"};const version=Utils.getSecondMatch(/edg([ea]|ios)\/(\d+(\.?_?\d+)+)/i,ua);if(version){browser.version=version}return browser}},{test:[/vivaldi/i],describe(ua){const browser={name:"Vivaldi"};const version=Utils.getFirstMatch(/vivaldi\/(\d+(\.?_?\d+)+)/i,ua);if(version){browser.version=version}return browser}},{test:[/seamonkey/i],describe(ua){const browser={name:"SeaMonkey"};const version=Utils.getFirstMatch(/seamonkey\/(\d+(\.?_?\d+)+)/i,ua);if(version){browser.version=version}return browser}},{test:[/sailfish/i],describe(ua){const browser={name:"Sailfish"};const version=Utils.getFirstMatch(/sailfish\s?browser\/(\d+(\.\d+)?)/i,ua);if(version){browser.version=version}return browser}},{test:[/silk/i],describe(ua){const browser={name:"Amazon Silk"};const version=Utils.getFirstMatch(/silk\/(\d+(\.?_?\d+)+)/i,ua);if(version){browser.version=version}return browser}},{test:[/phantom/i],describe(ua){const browser={name:"PhantomJS"};const version=Utils.getFirstMatch(/phantomjs\/(\d+(\.?_?\d+)+)/i,ua);if(version){browser.version=version}return browser}},{test:[/slimerjs/i],describe(ua){const browser={name:"SlimerJS"};const version=Utils.getFirstMatch(/slimerjs\/(\d+(\.?_?\d+)+)/i,ua);if(version){browser.version=version}return browser}},{test:[/blackberry|\bbb\d+/i,/rim\stablet/i],describe(ua){const browser={name:"BlackBerry"};const version=Utils.getFirstMatch(commonVersionIdentifier,ua)||Utils.getFirstMatch(/blackberry[\d]+\/(\d+(\.?_?\d+)+)/i,ua);if(version){browser.version=version}return browser}},{test:[/(web|hpw)[o0]s/i],describe(ua){const browser={name:"WebOS Browser"};const version=Utils.getFirstMatch(commonVersionIdentifier,ua)||Utils.getFirstMatch(/w(?:eb)?[o0]sbrowser\/(\d+(\.?_?\d+)+)/i,ua);if(version){browser.version=version}return browser}},{test:[/bada/i],describe(ua){const browser={name:"Bada"};const version=Utils.getFirstMatch(/dolfin\/(\d+(\.?_?\d+)+)/i,ua);if(version){browser.version=version}return browser}},{test:[/tizen/i],describe(ua){const browser={name:"Tizen"};const version=Utils.getFirstMatch(/(?:tizen\s?)?browser\/(\d+(\.?_?\d+)+)/i,ua)||Utils.getFirstMatch(commonVersionIdentifier,ua);if(version){browser.version=version}return browser}},{test:[/qupzilla/i],describe(ua){const browser={name:"QupZilla"};const version=Utils.getFirstMatch(/(?:qupzilla)[\s/](\d+(\.?_?\d+)+)/i,ua)||Utils.getFirstMatch(commonVersionIdentifier,ua);if(version){browser.version=version}return browser}},{test:[/firefox|iceweasel|fxios/i],describe(ua){const browser={name:"Firefox"};const version=Utils.getFirstMatch(/(?:firefox|iceweasel|fxios)[\s/](\d+(\.?_?\d+)+)/i,ua);if(version){browser.version=version}return browser}},{test:[/electron/i],describe(ua){const browser={name:"Electron"};const version=Utils.getFirstMatch(/(?:electron)\/(\d+(\.?_?\d+)+)/i,ua);if(version){browser.version=version}return browser}},{test:[/MiuiBrowser/i],describe(ua){const browser={name:"Miui"};const version=Utils.getFirstMatch(/(?:MiuiBrowser)[\s/](\d+(\.?_?\d+)+)/i,ua);if(version){browser.version=version}return browser}},{test:[/chromium/i],describe(ua){const browser={name:"Chromium"};const version=Utils.getFirstMatch(/(?:chromium)[\s/](\d+(\.?_?\d+)+)/i,ua)||Utils.getFirstMatch(commonVersionIdentifier,ua);if(version){browser.version=version}return browser}},{test:[/chrome|crios|crmo/i],describe(ua){const browser={name:"Chrome"};const version=Utils.getFirstMatch(/(?:chrome|crios|crmo)\/(\d+(\.?_?\d+)+)/i,ua);if(version){browser.version=version}return browser}},{test:[/GSA/i],describe(ua){const browser={name:"Google Search"};const version=Utils.getFirstMatch(/(?:GSA)\/(\d+(\.?_?\d+)+)/i,ua);if(version){browser.version=version}return browser}},{test(parser){const notLikeAndroid=!parser.test(/like android/i);const butAndroid=parser.test(/android/i);return notLikeAndroid&&butAndroid},describe(ua){const browser={name:"Android Browser"};const version=Utils.getFirstMatch(commonVersionIdentifier,ua);if(version){browser.version=version}return browser}},{test:[/playstation 4/i],describe(ua){const browser={name:"PlayStation 4"};const version=Utils.getFirstMatch(commonVersionIdentifier,ua);if(version){browser.version=version}return browser}},{test:[/safari|applewebkit/i],describe(ua){const browser={name:"Safari"};const version=Utils.getFirstMatch(commonVersionIdentifier,ua);if(version){browser.version=version}return browser}},{test:[/.*/i],describe(ua){const regexpWithoutDeviceSpec=/^(.*)\/(.*) /;const regexpWithDeviceSpec=/^(.*)\/(.*)[ \t]\((.*)/;const hasDeviceSpec=ua.search("\\(")!==-1;const regexp=hasDeviceSpec?regexpWithDeviceSpec:regexpWithoutDeviceSpec;return{name:Utils.getFirstMatch(regexp,ua),version:Utils.getSecondMatch(regexp,ua)}}}];var osParsersList=[{test:[/Roku\/DVP/],describe(ua){const version=Utils.getFirstMatch(/Roku\/DVP-(\d+\.\d+)/i,ua);return{name:OS_MAP.Roku,version:version}}},{test:[/windows phone/i],describe(ua){const version=Utils.getFirstMatch(/windows phone (?:os)?\s?(\d+(\.\d+)*)/i,ua);return{name:OS_MAP.WindowsPhone,version:version}}},{test:[/windows /i],describe(ua){const version=Utils.getFirstMatch(/Windows ((NT|XP)( \d\d?.\d)?)/i,ua);const versionName=Utils.getWindowsVersionName(version);return{name:OS_MAP.Windows,version:version,versionName:versionName}}},{test:[/Macintosh(.*?) FxiOS(.*?)\//],describe(ua){const result={name:OS_MAP.iOS};const version=Utils.getSecondMatch(/(Version\/)(\d[\d.]+)/,ua);if(version){result.version=version}return result}},{test:[/macintosh/i],describe(ua){const version=Utils.getFirstMatch(/mac os x (\d+(\.?_?\d+)+)/i,ua).replace(/[_\s]/g,".");const versionName=Utils.getMacOSVersionName(version);const os={name:OS_MAP.MacOS,version:version};if(versionName){os.versionName=versionName}return os}},{test:[/(ipod|iphone|ipad)/i],describe(ua){const version=Utils.getFirstMatch(/os (\d+([_\s]\d+)*) like mac os x/i,ua).replace(/[_\s]/g,".");return{name:OS_MAP.iOS,version:version}}},{test(parser){const notLikeAndroid=!parser.test(/like android/i);const butAndroid=parser.test(/android/i);return notLikeAndroid&&butAndroid},describe(ua){const version=Utils.getFirstMatch(/android[\s/-](\d+(\.\d+)*)/i,ua);const versionName=Utils.getAndroidVersionName(version);const os={name:OS_MAP.Android,version:version};if(versionName){os.versionName=versionName}return os}},{test:[/(web|hpw)[o0]s/i],describe(ua){const version=Utils.getFirstMatch(/(?:web|hpw)[o0]s\/(\d+(\.\d+)*)/i,ua);const os={name:OS_MAP.WebOS};if(version&&version.length){os.version=version}return os}},{test:[/blackberry|\bbb\d+/i,/rim\stablet/i],describe(ua){const version=Utils.getFirstMatch(/rim\stablet\sos\s(\d+(\.\d+)*)/i,ua)||Utils.getFirstMatch(/blackberry\d+\/(\d+([_\s]\d+)*)/i,ua)||Utils.getFirstMatch(/\bbb(\d+)/i,ua);return{name:OS_MAP.BlackBerry,version:version}}},{test:[/bada/i],describe(ua){const version=Utils.getFirstMatch(/bada\/(\d+(\.\d+)*)/i,ua);return{name:OS_MAP.Bada,version:version}}},{test:[/tizen/i],describe(ua){const version=Utils.getFirstMatch(/tizen[/\s](\d+(\.\d+)*)/i,ua);return{name:OS_MAP.Tizen,version:version}}},{test:[/linux/i],describe(){return{name:OS_MAP.Linux}}},{test:[/CrOS/],describe(){return{name:OS_MAP.ChromeOS}}},{test:[/PlayStation 4/],describe(ua){const version=Utils.getFirstMatch(/PlayStation 4[/\s](\d+(\.\d+)*)/i,ua);return{name:OS_MAP.PlayStation4,version:version}}}];var platformParsersList=[{test:[/googlebot/i],describe(){return{type:"bot",vendor:"Google"}}},{test:[/huawei/i],describe(ua){const model=Utils.getFirstMatch(/(can-l01)/i,ua)&&"Nova";const platform={type:PLATFORMS_MAP.mobile,vendor:"Huawei"};if(model){platform.model=model}return platform}},{test:[/nexus\s*(?:7|8|9|10).*/i],describe(){return{type:PLATFORMS_MAP.tablet,vendor:"Nexus"}}},{test:[/ipad/i],describe(){return{type:PLATFORMS_MAP.tablet,vendor:"Apple",model:"iPad"}}},{test:[/Macintosh(.*?) FxiOS(.*?)\//],describe(){return{type:PLATFORMS_MAP.tablet,vendor:"Apple",model:"iPad"}}},{test:[/kftt build/i],describe(){return{type:PLATFORMS_MAP.tablet,vendor:"Amazon",model:"Kindle Fire HD 7"}}},{test:[/silk/i],describe(){return{type:PLATFORMS_MAP.tablet,vendor:"Amazon"}}},{test:[/tablet(?! pc)/i],describe(){return{type:PLATFORMS_MAP.tablet}}},{test(parser){const iDevice=parser.test(/ipod|iphone/i);const likeIDevice=parser.test(/like (ipod|iphone)/i);return iDevice&&!likeIDevice},describe(ua){const model=Utils.getFirstMatch(/(ipod|iphone)/i,ua);return{type:PLATFORMS_MAP.mobile,vendor:"Apple",model:model}}},{test:[/nexus\s*[0-6].*/i,/galaxy nexus/i],describe(){return{type:PLATFORMS_MAP.mobile,vendor:"Nexus"}}},{test:[/[^-]mobi/i],describe(){return{type:PLATFORMS_MAP.mobile}}},{test(parser){return parser.getBrowserName(true)==="blackberry"},describe(){return{type:PLATFORMS_MAP.mobile,vendor:"BlackBerry"}}},{test(parser){return parser.getBrowserName(true)==="bada"},describe(){return{type:PLATFORMS_MAP.mobile}}},{test(parser){return parser.getBrowserName()==="windows phone"},describe(){return{type:PLATFORMS_MAP.mobile,vendor:"Microsoft"}}},{test(parser){const osMajorVersion=Number(String(parser.getOSVersion()).split(".")[0]);return parser.getOSName(true)==="android"&&osMajorVersion>=3},describe(){return{type:PLATFORMS_MAP.tablet}}},{test(parser){return parser.getOSName(true)==="android"},describe(){return{type:PLATFORMS_MAP.mobile}}},{test(parser){return parser.getOSName(true)==="macos"},describe(){return{type:PLATFORMS_MAP.desktop,vendor:"Apple"}}},{test(parser){return parser.getOSName(true)==="windows"},describe(){return{type:PLATFORMS_MAP.desktop}}},{test(parser){return parser.getOSName(true)==="linux"},describe(){return{type:PLATFORMS_MAP.desktop}}},{test(parser){return parser.getOSName(true)==="playstation 4"},describe(){return{type:PLATFORMS_MAP.tv}}},{test(parser){return parser.getOSName(true)==="roku"},describe(){return{type:PLATFORMS_MAP.tv}}}];var enginesParsersList=[{test(parser){return parser.getBrowserName(true)==="microsoft edge"},describe(ua){const isBlinkBased=/\sedg\//i.test(ua);if(isBlinkBased){return{name:ENGINE_MAP.Blink}}const version=Utils.getFirstMatch(/edge\/(\d+(\.?_?\d+)+)/i,ua);return{name:ENGINE_MAP.EdgeHTML,version:version}}},{test:[/trident/i],describe(ua){const engine={name:ENGINE_MAP.Trident};const version=Utils.getFirstMatch(/trident\/(\d+(\.?_?\d+)+)/i,ua);if(version){engine.version=version}return engine}},{test(parser){return parser.test(/presto/i)},describe(ua){const engine={name:ENGINE_MAP.Presto};const version=Utils.getFirstMatch(/presto\/(\d+(\.?_?\d+)+)/i,ua);if(version){engine.version=version}return engine}},{test(parser){const isGecko=parser.test(/gecko/i);const likeGecko=parser.test(/like gecko/i);return isGecko&&!likeGecko},describe(ua){const engine={name:ENGINE_MAP.Gecko};const version=Utils.getFirstMatch(/gecko\/(\d+(\.?_?\d+)+)/i,ua);if(version){engine.version=version}return engine}},{test:[/(apple)?webkit\/537\.36/i],describe(){return{name:ENGINE_MAP.Blink}}},{test:[/(apple)?webkit/i],describe(ua){const engine={name:ENGINE_MAP.WebKit};const version=Utils.getFirstMatch(/webkit\/(\d+(\.?_?\d+)+)/i,ua);if(version){engine.version=version}return engine}}];class Parser{constructor(UA,skipParsing=false){if(UA===void 0||UA===null||UA===""){throw new Error("UserAgent parameter can't be empty")}this._ua=UA;this.parsedResult={};if(skipParsing!==true){this.parse()}}getUA(){return this._ua}test(regex){return regex.test(this._ua)}parseBrowser(){this.parsedResult.browser={};const browserDescriptor=Utils.find(browsersList,_browser=>{if(typeof _browser.test==="function"){return _browser.test(this)}if(_browser.test instanceof Array){return _browser.test.some(condition=>this.test(condition))}throw new Error("Browser's test function is not valid")});if(browserDescriptor){this.parsedResult.browser=browserDescriptor.describe(this.getUA())}return this.parsedResult.browser}getBrowser(){if(this.parsedResult.browser){return this.parsedResult.browser}return this.parseBrowser()}getBrowserName(toLowerCase){if(toLowerCase){return String(this.getBrowser().name).toLowerCase()||""}return this.getBrowser().name||""}getBrowserVersion(){return this.getBrowser().version}getOS(){if(this.parsedResult.os){return this.parsedResult.os}return this.parseOS()}parseOS(){this.parsedResult.os={};const os=Utils.find(osParsersList,_os=>{if(typeof _os.test==="function"){return _os.test(this)}if(_os.test instanceof Array){return _os.test.some(condition=>this.test(condition))}throw new Error("Browser's test function is not valid")});if(os){this.parsedResult.os=os.describe(this.getUA())}return this.parsedResult.os}getOSName(toLowerCase){const{name:name}=this.getOS();if(toLowerCase){return String(name).toLowerCase()||""}return name||""}getOSVersion(){return this.getOS().version}getPlatform(){if(this.parsedResult.platform){return this.parsedResult.platform}return this.parsePlatform()}getPlatformType(toLowerCase=false){const{type:type}=this.getPlatform();if(toLowerCase){return String(type).toLowerCase()||""}return type||""}parsePlatform(){this.parsedResult.platform={};const platform=Utils.find(platformParsersList,_platform=>{if(typeof _platform.test==="function"){return _platform.test(this)}if(_platform.test instanceof Array){return _platform.test.some(condition=>this.test(condition))}throw new Error("Browser's test function is not valid")});if(platform){this.parsedResult.platform=platform.describe(this.getUA())}return this.parsedResult.platform}getEngine(){if(this.parsedResult.engine){return this.parsedResult.engine}return this.parseEngine()}getEngineName(toLowerCase){if(toLowerCase){return String(this.getEngine().name).toLowerCase()||""}return this.getEngine().name||""}parseEngine(){this.parsedResult.engine={};const engine=Utils.find(enginesParsersList,_engine=>{if(typeof _engine.test==="function"){return _engine.test(this)}if(_engine.test instanceof Array){return _engine.test.some(condition=>this.test(condition))}throw new Error("Browser's test function is not valid")});if(engine){this.parsedResult.engine=engine.describe(this.getUA())}return this.parsedResult.engine}parse(){this.parseBrowser();this.parseOS();this.parsePlatform();this.parseEngine();return this}getResult(){return Utils.assign({},this.parsedResult)}satisfies(checkTree){const platformsAndOSes={};let platformsAndOSCounter=0;const browsers={};let browsersCounter=0;const allDefinitions=Object.keys(checkTree);allDefinitions.forEach(key=>{const currentDefinition=checkTree[key];if(typeof currentDefinition==="string"){browsers[key]=currentDefinition;browsersCounter+=1}else if(typeof currentDefinition==="object"){platformsAndOSes[key]=currentDefinition;platformsAndOSCounter+=1}});if(platformsAndOSCounter>0){const platformsAndOSNames=Object.keys(platformsAndOSes);const OSMatchingDefinition=Utils.find(platformsAndOSNames,name=>this.isOS(name));if(OSMatchingDefinition){const osResult=this.satisfies(platformsAndOSes[OSMatchingDefinition]);if(osResult!==void 0){return osResult}}const platformMatchingDefinition=Utils.find(platformsAndOSNames,name=>this.isPlatform(name));if(platformMatchingDefinition){const platformResult=this.satisfies(platformsAndOSes[platformMatchingDefinition]);if(platformResult!==void 0){return platformResult}}}if(browsersCounter>0){const browserNames=Object.keys(browsers);const matchingDefinition=Utils.find(browserNames,name=>this.isBrowser(name,true));if(matchingDefinition!==void 0){return this.compareVersion(browsers[matchingDefinition])}}return undefined}isBrowser(browserName,includingAlias=false){const defaultBrowserName=this.getBrowserName().toLowerCase();let browserNameLower=browserName.toLowerCase();const alias=Utils.getBrowserTypeByAlias(browserNameLower);if(includingAlias&&alias){browserNameLower=alias.toLowerCase()}return browserNameLower===defaultBrowserName}compareVersion(version){let expectedResults=[0];let comparableVersion=version;let isLoose=false;const currentBrowserVersion=this.getBrowserVersion();if(typeof currentBrowserVersion!=="string"){return void 0}if(version[0]===">"||version[0]==="<"){comparableVersion=version.substr(1);if(version[1]==="="){isLoose=true;comparableVersion=version.substr(2)}else{expectedResults=[]}if(version[0]===">"){expectedResults.push(1)}else{expectedResults.push(-1)}}else if(version[0]==="="){comparableVersion=version.substr(1)}else if(version[0]==="~"){isLoose=true;comparableVersion=version.substr(1)}return expectedResults.indexOf(Utils.compareVersions(currentBrowserVersion,comparableVersion,isLoose))>-1}isOS(osName){return this.getOSName(true)===String(osName).toLowerCase()}isPlatform(platformType){return this.getPlatformType(true)===String(platformType).toLowerCase()}isEngine(engineName){return this.getEngineName(true)===String(engineName).toLowerCase()}is(anything,includingAlias=false){return this.isBrowser(anything,includingAlias)||this.isOS(anything)||this.isPlatform(anything)}some(anythings=[]){return anythings.some(anything=>this.is(anything))}}class Bowser{static getParser(UA,skipParsing=false){if(typeof UA!=="string"){throw new Error("UserAgent should be a string")}return new Parser(UA,skipParsing)}static parse(UA){return new Parser(UA).getResult()}static get BROWSER_MAP(){return BROWSER_MAP}static get ENGINE_MAP(){return ENGINE_MAP}static get OS_MAP(){return OS_MAP}static get PLATFORMS_MAP(){return PLATFORMS_MAP}}function _classCallCheck(a,n){if(!(a instanceof n))throw new TypeError("Cannot call a class as a function")}function _defineProperties(e,r){for(var t=0;t<r.length;t++){var o=r[t];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(e,toPropertyKey(o.key),o)}}function _createClass(e,r,t){return r&&_defineProperties(e.prototype,r),t&&_defineProperties(e,t),Object.defineProperty(e,"prototype",{writable:!1}),e}function ownKeys$2(e,r){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);r&&(o=o.filter(function(r){return Object.getOwnPropertyDescriptor(e,r).enumerable})),t.push.apply(t,o)}return t}function _objectSpread$2(e){for(var r=1;r<arguments.length;r++){var t=null!=arguments[r]?arguments[r]:{};r%2?ownKeys$2(Object(t),!0).forEach(function(r){_defineProperty(e,r,t[r])}):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):ownKeys$2(Object(t)).forEach(function(r){Object.defineProperty(e,r,Object.getOwnPropertyDescriptor(t,r))})}return e}var PvFile=function(){function PvFile(){_classCallCheck(this,PvFile);this._path=""}return _createClass(PvFile,[{key:"meta",get:function get(){if(this._meta===undefined){return undefined}return _objectSpread$2({version:0},this._meta)}},{key:"pageSize",get:function get(){return undefined}}],[{key:"getPtr",value:function getPtr(ptr){if(PvFile._filePtrs.has(ptr)){return PvFile._filePtrs.get(ptr)}throw new Error("File instance not found.")}},{key:"setPtr",value:function setPtr(ptr,instance){PvFile._filePtrs.set(ptr,instance)}},{key:"removePtr",value:function removePtr(ptr){PvFile._filePtrs["delete"](ptr)}}])}();PvFile._filePtrs=new Map;function _assertThisInitialized(e){if(void 0===e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return e}function _possibleConstructorReturn(t,e){if(e&&("object"==_typeof$2(e)||"function"==typeof e))return e;if(void 0!==e)throw new TypeError("Derived constructors may only return object or undefined");return _assertThisInitialized(t)}function _getPrototypeOf(t){return _getPrototypeOf=Object.setPrototypeOf?Object.getPrototypeOf.bind():function(t){return t.__proto__||Object.getPrototypeOf(t)},_getPrototypeOf(t)}function _setPrototypeOf(t,e){return _setPrototypeOf=Object.setPrototypeOf?Object.setPrototypeOf.bind():function(t,e){return t.__proto__=e,t},_setPrototypeOf(t,e)}function _inherits(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function");t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,writable:!0,configurable:!0}}),Object.defineProperty(t,"prototype",{writable:!1}),e&&_setPrototypeOf(t,e)}function _callSuper$1(t,o,e){return o=_getPrototypeOf(o),_possibleConstructorReturn(t,_isNativeReflectConstruct$1()?Reflect.construct(o,e||[],_getPrototypeOf(t).constructor):o.apply(t,e))}function _isNativeReflectConstruct$1(){try{var t=!Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],function(){}))}catch(t){}return(_isNativeReflectConstruct$1=function _isNativeReflectConstruct(){return!!t})()}var DB_NAME="pv_db";var PV_FILE_STORE="pv_file";var DB_VERSION=3;function getDB(){return new Promise(function(resolve,reject){var request=self.indexedDB.open(DB_NAME,DB_VERSION);request.onerror=function(){reject(request.error)};request.onsuccess=function(){resolve(request.result)};request.onupgradeneeded=function(){if(!request.result.objectStoreNames.contains(PV_FILE_STORE)){request.result.createObjectStore(PV_FILE_STORE)}}})}var PvCache=function(){function PvCache(){_classCallCheck(this,PvCache);this._pos=0;this._data=new Uint8Array}return _createClass(PvCache,[{key:"get",value:function get(bytes){if(this._pos>=this._data.length){return undefined}var res=this._data.slice(this._pos,this._pos+bytes);this._pos+=bytes;return res}},{key:"set",value:function set(pos,data){this._pos=pos;this._data=data}},{key:"clear",value:function clear(){this._pos=0;this._data=new Uint8Array}}])}();var PvFileIDB=function(_PvFile){function PvFileIDB(path,meta,db,mode){var _this;_classCallCheck(this,PvFileIDB);_this=_callSuper$1(this,PvFileIDB);_this._pageSize=512*1024;_this._pagePtr=0;_this._pageOffset=0;_this._path=path;_this._meta=meta;_this._db=db;_this._mode=mode;_this._cache=new PvCache;return _this}_inherits(PvFileIDB,_PvFile);return _createClass(PvFileIDB,[{key:"pageSize",get:function get(){return this._pageSize}},{key:"close",value:function(){var _close=_asyncToGenerator(_regeneratorRuntime.mark(function _callee(){return _regeneratorRuntime.wrap(function _callee$(_context){while(1)switch(_context.prev=_context.next){case 0:this._db.close();case 1:case"end":return _context.stop()}},_callee,this)}));function close(){return _close.apply(this,arguments)}return close}()},{key:"read",value:function(){var _read=_asyncToGenerator(_regeneratorRuntime.mark(function _callee2(size,count){var _this2=this;return _regeneratorRuntime.wrap(function _callee2$(_context2){while(1)switch(_context2.prev=_context2.next){case 0:return _context2.abrupt("return",new Promise(function(resolve,reject){if(!_this2.exists()){reject(new Error("'".concat(_this2._path,"' doesn't exist.")));return}if(_this2._isEOF){var err=new Error("EOF");err.name="EndOfFile";reject(err);return}var copied=0;var maxToCopy=Math.min(size*count,_this2._meta.size);var totalElems=maxToCopy-maxToCopy%size;var buffer=new Uint8Array(totalElems);var res=_this2._cache.get(totalElems);if(res){copied+=res.length;_this2._pageOffset+=res.length;if(_this2._pageOffset===_this2._pageSize){_this2._pagePtr+=1;_this2._pageOffset=0}if(totalElems===copied){resolve(res);return}buffer.set(res)}var keyRange=IDBKeyRange.bound("".concat(_this2._path,"-").concat(PvFileIDB.createPage(_this2._pagePtr)),"".concat(_this2._path,"-").concat(PvFileIDB.createPage(_this2._pagePtr+Math.floor(totalElems/_this2._pageSize)+1)));var store=_this2._store;var req=store.openCursor(keyRange);req.onsuccess=function(){var cursor=req.result;if(!cursor||_this2._isEOF){return}var toCopy=Math.min(totalElems-copied,cursor.value.length-_this2._pageOffset);buffer.set(cursor.value.slice(_this2._pageOffset,_this2._pageOffset+toCopy),copied);copied+=toCopy;_this2._pageOffset+=toCopy;if(_this2._pageOffset===_this2._pageSize){_this2._pagePtr+=1;_this2._pageOffset=0}if(copied<totalElems){cursor["continue"]()}else{var _store$transaction;if(_this2._pageOffset!==0){_this2._cache.set(_this2._pageOffset,cursor.value)}else{_this2._cache.clear()}if((_store$transaction=store.transaction)!==null&&_store$transaction!==void 0&&_store$transaction.commit){var _store$transaction2;(_store$transaction2=store.transaction)===null||_store$transaction2===void 0||_store$transaction2.commit()}}};store.transaction.onerror=function(){reject(store.transaction.error)};store.transaction.oncomplete=function(){resolve(buffer.slice(0,copied))}}));case 1:case"end":return _context2.stop()}},_callee2)}));function read(_x,_x2){return _read.apply(this,arguments)}return read}()},{key:"write",value:function(){var _write=_asyncToGenerator(_regeneratorRuntime.mark(function _callee4(content){var _this3=this;var version,_args4=arguments;return _regeneratorRuntime.wrap(function _callee4$(_context4){while(1)switch(_context4.prev=_context4.next){case 0:version=_args4.length>1&&_args4[1]!==undefined?_args4[1]:1;return _context4.abrupt("return",new Promise(function(){var _ref=_asyncToGenerator(_regeneratorRuntime.mark(function _callee3(resolve,reject){var _store$transaction3;var store,getCurrentPage,last,newContent,newSize,newMeta,pages,i,keyRange,_store$transaction4;return _regeneratorRuntime.wrap(function _callee3$(_context3){while(1)switch(_context3.prev=_context3.next){case 0:if(!(_this3._mode==="readonly")){_context3.next=3;break}reject(new Error("Instance is readonly mode only."));return _context3.abrupt("return");case 3:if(!(typeof version!=="number"&&version<=0)){_context3.next=6;break}reject(new Error("Version should be a positive number"));return _context3.abrupt("return");case 6:store=_this3._store;getCurrentPage=function getCurrentPage(){return new Promise(function(res){var req=store.get("".concat(_this3._path,"-").concat(PvFileIDB.createPage(_this3._pagePtr)));req.onsuccess=function(){if(req.result!==undefined){res(req.result.slice(0,_this3._pageOffset))}else{res(new Uint8Array(0))}}})};_context3.next=10;return getCurrentPage();case 10:last=_context3.sent;newContent=new Uint8Array(last.length+content.length);newContent.set(last);newContent.set(content,last.length);newSize=_this3._pagePtr*_this3._pageSize+newContent.length;newMeta={size:newSize,numPages:Math.ceil(newSize/_this3._pageSize),version:version,pageSize:_this3._pageSize};store.put(newMeta,_this3._path);pages=Math.ceil(newContent.length/_this3._pageSize);for(i=0;i<pages;i++){store.put(newContent.slice(i*_this3._pageSize,(i+1)*_this3._pageSize),"".concat(_this3._path,"-").concat(PvFileIDB.createPage(_this3._pagePtr+i)))}if(_this3.exists()&&newMeta.numPages<_this3._meta.numPages){keyRange=IDBKeyRange.bound("".concat(_this3._path,"-").concat(PvFileIDB.createPage(newMeta.numPages)),"".concat(_this3._path,"-").concat(PvFileIDB.createPage(_this3._meta.numPages)),true);store["delete"](keyRange)}if((_store$transaction3=store.transaction)!==null&&_store$transaction3!==void 0&&_store$transaction3.commit){(_store$transaction4=store.transaction)===null||_store$transaction4===void 0||_store$transaction4.commit()}store.transaction.onerror=function(){reject(store.transaction.error)};store.transaction.oncomplete=function(){_this3._meta=newMeta;_this3.seek(0,2);resolve()};case 23:case"end":return _context3.stop()}},_callee3)}));return function(_x4,_x5){return _ref.apply(this,arguments)}}()));case 2:case"end":return _context4.stop()}},_callee4)}));function write(_x3){return _write.apply(this,arguments)}return write}()},{key:"seek",value:function seek(offset,whence){if(!this.exists()&&this._mode==="readonly"){throw new Error("'".concat(this._path,"' doesn't exist."))}if(!this.exists()){throw new Error("'".concat(this._path,"' doesn't exist."))}if(offset<0){var err=new Error("EOF");err.name="EndOfFile";throw err}var newOffset;if(whence===0){newOffset=Math.min(offset,this._meta.size)}else if(whence===1){var currentOffset=this._pageSize*this._pagePtr+this._pageOffset;newOffset=Math.min(currentOffset+offset,this._meta.size)}else if(whence===2){newOffset=Math.min(this._meta.size+offset,this._meta.size)}else{throw new Error("Invalid operation: ".concat(whence,"."))}this._pageOffset=newOffset%this._pageSize;this._pagePtr=Math.floor(newOffset/this._pageSize);this._cache.clear()}},{key:"tell",value:function tell(){if(!this.exists()){return-1}return this._pagePtr*this._pageSize+this._pageOffset}},{key:"remove",value:function(){var _remove=_asyncToGenerator(_regeneratorRuntime.mark(function _callee6(){var _this4=this;return _regeneratorRuntime.wrap(function _callee6$(_context6){while(1)switch(_context6.prev=_context6.next){case 0:return _context6.abrupt("return",new Promise(function(){var _ref2=_asyncToGenerator(_regeneratorRuntime.mark(function _callee5(resolve,reject){var numPages,keyRange,store,req;return _regeneratorRuntime.wrap(function _callee5$(_context5){while(1)switch(_context5.prev=_context5.next){case 0:if(_this4.exists()){_context5.next=3;break}reject(new Error("ENOENT"));return _context5.abrupt("return");case 3:numPages=_this4._meta.numPages;keyRange=IDBKeyRange.bound(_this4._path,"".concat(_this4._path,"-").concat(PvFileIDB.createPage(numPages)));store=_this4._store;req=store["delete"](keyRange);req.onerror=function(){reject(req.error)};req.onsuccess=function(){_this4._meta=undefined;_this4._pageOffset=0;_this4._pagePtr=0;resolve()};case 9:case"end":return _context5.stop()}},_callee5)}));return function(_x6,_x7){return _ref2.apply(this,arguments)}}()));case 1:case"end":return _context6.stop()}},_callee6)}));function remove(){return _remove.apply(this,arguments)}return remove}()},{key:"exists",value:function exists(){return this._meta!==undefined}},{key:"_isEOF",get:function get(){return this._pagePtr>=this._meta.numPages-1&&this._pageOffset>=this._meta.size%this._pageSize}},{key:"_store",get:function get(){return this._db.transaction(PV_FILE_STORE,this._mode).objectStore(PV_FILE_STORE)}}],[{key:"open",value:function open(path,mode){if(!self.indexedDB){var error=new Error("IndexedDB is not supported");error.name="IndexedDBNotSupported";throw error}return new Promise(function(){var _ref3=_asyncToGenerator(_regeneratorRuntime.mark(function _callee7(resolve,reject){var db,req,_error2;return _regeneratorRuntime.wrap(function _callee7$(_context7){while(1)switch(_context7.prev=_context7.next){case 0:_context7.prev=0;_context7.next=3;return getDB();case 3:db=_context7.sent;req=db.transaction(PV_FILE_STORE,"readwrite").objectStore(PV_FILE_STORE).get(path);req.onerror=function(){reject(req.error)};req.onsuccess=function(){var meta=req.result;var dbMode=mode.includes("r")?"readonly":"readwrite";if(meta===undefined&&dbMode==="readonly"){var _error=new Error("'".concat(path,"' doesn't exist."));_error.name="FileNotExists";reject(_error);return}var fileIDB=new PvFileIDB(path,meta,db,dbMode);if(mode.includes("a")){fileIDB.seek(0,2)}resolve(fileIDB)};_context7.next=12;break;case 9:_context7.prev=9;_context7.t0=_context7["catch"](0);if(_context7.t0.name==="InvalidStateError"){_error2=new Error("IndexedDB is not supported");_error2.name="IndexedDBNotSupported";reject(_error2)}else{reject(_context7.t0)}case 12:case"end":return _context7.stop()}},_callee7,null,[[0,9]])}));return function(_x8,_x9){return _ref3.apply(this,arguments)}}())}},{key:"createPage",value:function createPage(page){return("00000"+page).slice(-6)}}])}(PvFile);function _callSuper(t,o,e){return o=_getPrototypeOf(o),_possibleConstructorReturn(t,_isNativeReflectConstruct()?Reflect.construct(o,e||[],_getPrototypeOf(t).constructor):o.apply(t,e))}function _isNativeReflectConstruct(){try{var t=!Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],function(){}))}catch(t){}return(_isNativeReflectConstruct=function _isNativeReflectConstruct(){return!!t})()}var PvFileMem=function(_PvFile){function PvFileMem(path,meta,db,mode){var _this;_classCallCheck(this,PvFileMem);_this=_callSuper(this,PvFileMem);_this._pos=0;_this._path=path;_this._meta=meta;_this._mode=mode;return _this}_inherits(PvFileMem,_PvFile);return _createClass(PvFileMem,[{key:"close",value:function close(){return}},{key:"read",value:function read(size,count){if(!this.exists()){throw new Error("'".concat(this._path,"' doesn't exist."))}if(this._isEOF){var err=new Error("EOF");err.name="EndOfFile";throw err}var toCopy=Math.min(size*count,this._file.length-this._pos);var totalElems=toCopy-toCopy%size;var buffer=new Uint8Array(totalElems);buffer.set(this._file.slice(this._pos,this._pos+totalElems),0);this._pos+=totalElems;return buffer}},{key:"write",value:function write(content){var version=arguments.length>1&&arguments[1]!==undefined?arguments[1]:1;var newFile=new Uint8Array(this._pos+content.length);if(this._file!==undefined){newFile.set(this._file.slice(0,this._pos));newFile.set(content,this._pos)}else{newFile.set(content)}this._file=newFile;this._pos+=content.length}},{key:"seek",value:function seek(offset,whence){if(!this.exists()&&this._mode==="readonly"){throw new Error("'".concat(this._path,"' doesn't exist."))}if(!this.exists()){throw new Error("'".concat(this._path,"' doesn't exist."))}if(offset<0){var err=new Error("EOF");err.name="EndOfFile";throw err}var newOffset;if(whence===0){newOffset=Math.min(offset,this._file.length)}else if(whence===1){newOffset=Math.min(this._pos+offset,this._file.length)}else if(whence===2){newOffset=Math.min(this._file.length+offset,this._file.length)}else{throw new Error("Invalid operation: ".concat(whence,"."))}this._pos=newOffset}},{key:"tell",value:function tell(){if(!this.exists()){return-1}return this._pos}},{key:"remove",value:function(){var _remove=_asyncToGenerator(_regeneratorRuntime.mark(function _callee(){return _regeneratorRuntime.wrap(function _callee$(_context){while(1)switch(_context.prev=_context.next){case 0:if(this.exists()){_context.next=2;break}throw new Error("ENOENT");case 2:PvFileMem._memFiles["delete"](this._path);this._pos=0;case 4:case"end":return _context.stop()}},_callee,this)}));function remove(){return _remove.apply(this,arguments)}return remove}()},{key:"exists",value:function exists(){return this._file!==undefined}},{key:"_isEOF",get:function get(){return this._pos>=this._file.length}},{key:"_file",get:function get(){return PvFileMem._memFiles.get(this._path)},set:function set(content){PvFileMem._memFiles.set(this._path,content)}}],[{key:"open",value:function open(path,mode){var file=PvFileMem._memFiles.get(path);var dbMode=mode.includes("r")?"readonly":"readwrite";if(file===undefined&&dbMode==="readonly"){var error=new Error("'".concat(path,"' doesn't exist."));error.name="FileNotExists";throw error}var fileMem=new PvFileMem(path,undefined,undefined,dbMode);if(mode.includes("a")){fileMem.seek(0,2)}return fileMem}}])}(PvFile);PvFileMem._memFiles=new Map;function unsignedAddress(address){if(address<0){return address>>>0}return address}function _arrayWithHoles(r){if(Array.isArray(r))return r}function _iterableToArrayLimit(r,l){var t=null==r?null:"undefined"!=typeof Symbol&&r[Symbol.iterator]||r["@@iterator"];if(null!=t){var e,n,i,u,a=[],f=!0,o=!1;try{if(i=(t=t.call(r)).next,0===l){if(Object(t)!==t)return;f=!1}else for(;!(f=(e=i.call(t)).done)&&(a.push(e.value),a.length!==l);f=!0);}catch(r){o=!0,n=r}finally{try{if(!f&&null!=t["return"]&&(u=t["return"](),Object(u)!==u))return}finally{if(o)throw n}}return a}}function _arrayLikeToArray$2(r,a){(null==a||a>r.length)&&(a=r.length);for(var e=0,n=Array(a);e<a;e++)n[e]=r[e];return n}function _unsupportedIterableToArray$2(r,a){if(r){if("string"==typeof r)return _arrayLikeToArray$2(r,a);var t={}.toString.call(r).slice(8,-1);return"Object"===t&&r.constructor&&(t=r.constructor.name),"Map"===t||"Set"===t?Array.from(r):"Arguments"===t||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t)?_arrayLikeToArray$2(r,a):void 0}}function _nonIterableRest(){throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}function _slicedToArray(r,e){return _arrayWithHoles(r)||_iterableToArrayLimit(r,e)||_unsupportedIterableToArray$2(r,e)||_nonIterableRest()}function _createForOfIteratorHelper$1(r,e){var t="undefined"!=typeof Symbol&&r[Symbol.iterator]||r["@@iterator"];if(!t){if(Array.isArray(r)||(t=_unsupportedIterableToArray$1(r))||e&&r&&"number"==typeof r.length){t&&(r=t);var _n=0,F=function F(){};return{s:F,n:function n(){return _n>=r.length?{done:!0}:{done:!1,value:r[_n++]}},e:function e(r){throw r},f:F}}throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}var o,a=!0,u=!1;return{s:function s(){t=t.call(r)},n:function n(){var r=t.next();return a=r.done,r},e:function e(r){u=!0,o=r},f:function f(){try{a||null==t["return"]||t["return"]()}finally{if(u)throw o}}}}function _unsupportedIterableToArray$1(r,a){if(r){if("string"==typeof r)return _arrayLikeToArray$1(r,a);var t={}.toString.call(r).slice(8,-1);return"Object"===t&&r.constructor&&(t=r.constructor.name),"Map"===t||"Set"===t?Array.from(r):"Arguments"===t||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t)?_arrayLikeToArray$1(r,a):void 0}}function _arrayLikeToArray$1(r,a){(null==a||a>r.length)&&(a=r.length);for(var e=0,n=Array(a);e<a;e++)n[e]=r[e];return n}var PvWebGPUDevice=function(){function PvWebGPUDevice(device,adapterInfo){_classCallCheck(this,PvWebGPUDevice);this._numCommandsEncoded=0;this._commandEncoder=null;this._passEncoder=null;this._stageBuffersPendingMap=[];this._uniformBuffersPendingRelease=[];this.device=device;this.bufferReusePool=new Map;this.shaders={};this.shaderTimes={};this.timestampBuffers={};this.isTimerEnabled=false;this.adapterInfo=adapterInfo}return _createClass(PvWebGPUDevice,[{key:"getBufferKey",value:function getBufferKey(sizeInBytes,usage){return"".concat(usage,"_").concat(sizeInBytes)}},{key:"commandEncoder",get:function get(){if(!this._commandEncoder){this._commandEncoder=this.device.createCommandEncoder()}return this._commandEncoder}},{key:"numCommandsEncoded",get:function get(){return this._numCommandsEncoded},set:function set(value){this._numCommandsEncoded=value;if(this._numCommandsEncoded>=16){this.endComputePass();this.flushCommandEncoder()}}},{key:"endComputePass",value:function endComputePass(){if(this._passEncoder){this._passEncoder.end();this._passEncoder=null}}},{key:"getBuffer",value:function getBuffer(sizeBytes,usage){var mappedAtCreation=arguments.length>2&&arguments[2]!==undefined?arguments[2]:false;var label=arguments.length>3?arguments[3]:undefined;var key=this.getBufferKey(sizeBytes,usage);if(this.bufferReusePool.has(key)){var buffers=this.bufferReusePool.get(key);if(buffers&&buffers.length>0){return buffers.pop()}}return this.device.createBuffer({size:sizeBytes*Uint8Array.BYTES_PER_ELEMENT,usage:usage,mappedAtCreation:mappedAtCreation,label:label})}},{key:"scheduleUniformBufferForRelease",value:function scheduleUniformBufferForRelease(buffer){this._uniformBuffersPendingRelease.push(buffer)}},{key:"releaseBuffer",value:function releaseBuffer(buffer){var clearBuffer=arguments.length>1&&arguments[1]!==undefined?arguments[1]:true;if(clearBuffer){this.endComputePass();this.commandEncoder.clearBuffer(buffer,0,buffer.size)}var key=this.getBufferKey(buffer.size,buffer.usage);if(!this.bufferReusePool.has(key)){this.bufferReusePool.set(key,[])}this.bufferReusePool.get(key).push(buffer)}},{key:"sync",value:function(){var _sync=_asyncToGenerator(_regeneratorRuntime.mark(function _callee(){var _this=this;var _iterator,_step,k,buffers,_iterator3,_step3,b,_loop,_i,_Object$entries;return _regeneratorRuntime.wrap(function _callee$(_context3){while(1)switch(_context3.prev=_context3.next){case 0:this.endComputePass();this.flushCommandEncoder();_context3.next=4;return this.device.queue.onSubmittedWorkDone();case 4:_iterator=_createForOfIteratorHelper$1(this.bufferReusePool.keys());try{for(_iterator.s();!(_step=_iterator.n()).done;){k=_step.value;buffers=this.bufferReusePool.get(k);if(buffers&&buffers.length>0){_iterator3=_createForOfIteratorHelper$1(buffers);try{for(_iterator3.s();!(_step3=_iterator3.n()).done;){b=_step3.value;b===null||b===void 0||b.destroy()}}catch(err){_iterator3.e(err)}finally{_iterator3.f()}}}}catch(err){_iterator.e(err)}finally{_iterator.f()}this.bufferReusePool.clear();_loop=_regeneratorRuntime.mark(function _loop(){var _Object$entries$_i,shaderName,timestampBuffers,_iterator2,_step2,_loop2;return _regeneratorRuntime.wrap(function _loop$(_context2){while(1)switch(_context2.prev=_context2.next){case 0:_Object$entries$_i=_slicedToArray(_Object$entries[_i],2),shaderName=_Object$entries$_i[0],timestampBuffers=_Object$entries$_i[1];if(!_this.shaderTimes[shaderName]){_this.shaderTimes[shaderName]=[]}_iterator2=_createForOfIteratorHelper$1(timestampBuffers);_context2.prev=3;_loop2=_regeneratorRuntime.mark(function _loop2(){var timestampBuffer;return _regeneratorRuntime.wrap(function _loop2$(_context){while(1)switch(_context.prev=_context.next){case 0:timestampBuffer=_step2.value;timestampBuffer.mapAsync(GPUMapMode.READ).then(function(){var times=new BigInt64Array(timestampBuffer.getMappedRange());var timeDif=times[1]-times[0];timestampBuffer.unmap();timestampBuffer.destroy();_this.shaderTimes[shaderName].push(timeDif)});case 2:case"end":return _context.stop()}},_loop2)});_iterator2.s();case 6:if((_step2=_iterator2.n()).done){_context2.next=10;break}return _context2.delegateYield(_loop2(),"t0",8);case 8:_context2.next=6;break;case 10:_context2.next=15;break;case 12:_context2.prev=12;_context2.t1=_context2["catch"](3);_iterator2.e(_context2.t1);case 15:_context2.prev=15;_iterator2.f();return _context2.finish(15);case 18:case"end":return _context2.stop()}},_loop,null,[[3,12,15,18]])});_i=0,_Object$entries=Object.entries(this.timestampBuffers);case 9:if(!(_i<_Object$entries.length)){_context3.next=14;break}return _context3.delegateYield(_loop(),"t0",11);case 11:_i++;_context3.next=9;break;case 14:this.timestampBuffers={};case 15:case"end":return _context3.stop()}},_callee,this)}));function sync(){return _sync.apply(this,arguments)}return sync}()},{key:"reportShaderTimes",value:function reportShaderTimes(){for(var _i2=0,_Object$entries2=Object.entries(this.shaderTimes);_i2<_Object$entries2.length;_i2++){var _Object$entries2$_i=_slicedToArray(_Object$entries2[_i2],2),shaderName=_Object$entries2$_i[0],shaderTimes=_Object$entries2$_i[1];var timeSum=0n;var _iterator4=_createForOfIteratorHelper$1(shaderTimes),_step4;try{for(_iterator4.s();!(_step4=_iterator4.n()).done;){var shaderTime=_step4.value;timeSum=timeSum+shaderTime}}catch(err){_iterator4.e(err)}finally{_iterator4.f()}var totalSeconds=Number(timeSum)*1e-9;var avgSeconds=(totalSeconds/shaderTimes.length).toFixed(7);console.log("".concat(shaderName,", ").concat(totalSeconds.toFixed(5),", ").concat(avgSeconds))}this.shaderTimes={}}},{key:"flushCommandEncoder",value:function flushCommandEncoder(){var _this2=this;this.device.queue.submit([this.commandEncoder.finish()]);this._commandEncoder=null;this._numCommandsEncoded=0;this._stageBuffersPendingMap.forEach(function(buffer){buffer.destroy()});this._stageBuffersPendingMap=[];this._uniformBuffersPendingRelease.forEach(function(buffer){_this2.releaseBuffer(buffer,false)});this._uniformBuffersPendingRelease=[]}},{key:"writeBuffer",value:function writeBuffer(sizeBytes,offset,srcArray,dstBuffer){var stagingBuffer=this.getBuffer(sizeBytes,GPUBufferUsage.MAP_WRITE|GPUBufferUsage.COPY_SRC,true);new Uint8Array(stagingBuffer.getMappedRange()).set(srcArray);stagingBuffer.unmap();this._stageBuffersPendingMap.push(stagingBuffer);this.endComputePass();this.commandEncoder.copyBufferToBuffer(stagingBuffer,0,dstBuffer,offset,sizeBytes);this.numCommandsEncoded++}},{key:"dispatchComputerShader",value:function dispatchComputerShader(bindGroup,pipeline,shaderName,workgroupCountX,workgroupCountY,workgroupCountZ){if(this.isTimerEnabled){var querySet=this.device.createQuerySet({type:"timestamp",count:2});var timestampWrites={querySet:querySet,beginningOfPassWriteIndex:0,endOfPassWriteIndex:1};this.endComputePass();this._passEncoder=this.commandEncoder.beginComputePass({timestampWrites:timestampWrites});this._passEncoder.setBindGroup(0,bindGroup);this._passEncoder.setPipeline(pipeline);this._passEncoder.dispatchWorkgroups(workgroupCountX,workgroupCountY,workgroupCountZ);this.endComputePass();var size=2*BigInt64Array.BYTES_PER_ELEMENT;var resolveBuffer=this.device.createBuffer({size:size,usage:GPUBufferUsage.QUERY_RESOLVE|GPUBufferUsage.COPY_SRC});this.commandEncoder.resolveQuerySet(querySet,0,2,resolveBuffer,0);var resultBuffer=this.device.createBuffer({size:size,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ});this.commandEncoder.copyBufferToBuffer(resolveBuffer,0,resultBuffer,0,size);if(!this.timestampBuffers[shaderName]){this.timestampBuffers[shaderName]=[]}this.timestampBuffers[shaderName].push(resultBuffer);this.numCommandsEncoded+=3}else{if(!this._passEncoder){this._passEncoder=this.commandEncoder.beginComputePass()}this._passEncoder.setBindGroup(0,bindGroup);this._passEncoder.setPipeline(pipeline);this._passEncoder.dispatchWorkgroups(workgroupCountX,workgroupCountY,workgroupCountZ);this.numCommandsEncoded++}}}])}();var PV_PICOLLM_WEBGPU_DEFAULT_WORKGROUP_SIZE=256;var gpuDevices=new Map;var gpuBuffers=new Map;var emptyShader="\n@compute @workgroup_size(workgroup_size_x, workgroup_size_y, workgroup_size_z)\nfn main_empty() {}\n";var shaderEntryPoint="main";var PRECOMPUTE_ENCODING_SHADER_NAME="pv_picollm_attention_precompute_encoding_shader";var attentionPrecomputeEncodingShaderSource="\nstruct argsStruct {\n  dimension: u32,\n  steps: u32,\n  theta: f32,\n  encoding_offset: u32,\n  rope_scale: f32,\n};\n\n@group(0) @binding(0) \nvar<uniform> args: argsStruct;\n\n@group(0) @binding(1)\nvar<storage, read_write> encoding: array<f32>;\n\n@group(0) @binding(2)\nvar<storage, read_write> rope_scales: array<f32>;\n\noverride workgroup_size_x: u32 = 1;\noverride workgroup_size_y: u32 = 1;\noverride workgroup_size_z: u32 = 1;\n\n@compute @workgroup_size(workgroup_size_x, workgroup_size_y, workgroup_size_z)\nfn main(\n  @builtin(local_invocation_id) local_id: vec3<u32>,\n  @builtin(workgroup_id) workgroup_id: vec3<u32>,\n  @builtin(num_workgroups) num_workgroups: vec3<u32>\n) {\n  let ts = workgroup_id.x;\n  let ds = local_id.x;\n  \n  for (var t = ts; t < args.steps; t += num_workgroups.x) {\n    for (var d = ds; d < (args.dimension / 2u); d += workgroup_size_x) {\n      let f = 2u * d;\n      let x = f32(t) / (f32(rope_scales[f >> 1]) * pow(args.theta, f32(f) / f32(args.dimension)));\n      let encoding_idx = args.encoding_offset + (t * args.dimension) + f;\n      encoding[encoding_idx] = cos(x) * args.rope_scale;\n      encoding[encoding_idx + 1] = sin(x) * args.rope_scale;\n    }\n  }\n}\n\n".concat(emptyShader);var loadAttentionPrecomputeEncodingShader=function loadAttentionPrecomputeEncodingShader(device){var bindGroupLayout=device.createBindGroupLayout({label:"attention precompute encoding bind group layout",entries:[{binding:0,visibility:GPUShaderStage.COMPUTE,buffer:{type:"uniform"}},{binding:1,visibility:GPUShaderStage.COMPUTE,buffer:{type:"storage"}},{binding:2,visibility:GPUShaderStage.COMPUTE,buffer:{type:"storage"}}]});var pipelineLayout=device.createPipelineLayout({label:"attention precompute encoding pipeline layout",bindGroupLayouts:[bindGroupLayout]});var shaderModule=device.createShaderModule({label:"attention precompute encoding shader module",code:attentionPrecomputeEncodingShaderSource});var computePipeline=device.createComputePipeline({label:"attention precompute encoding pipeline",layout:pipelineLayout,compute:{module:shaderModule,entryPoint:shaderEntryPoint,constants:{workgroup_size_x:PV_PICOLLM_WEBGPU_DEFAULT_WORKGROUP_SIZE}}});return{computePipeline:computePipeline}};var ENCODE_ROPE_INTERLEAVED_SHADER_NAME="pv_picollm_attention_encode_rope_interleaved_shader";var attentionEncodeRopeInterleavedShaderSource="\nstruct argsStruct {  \n  n: u32,\n  num_heads: u32,\n  head_dimension: u32,\n  rope_dimension: u32,\n  position: u32,\n  encoding_offset: u32,\n  x_offset: u32,\n};\n\n@group(0) @binding(0) \nvar<uniform> args: argsStruct;\n\n@group(0) @binding(1)\nvar<storage, read> encoding: array<f32>;\n\n@group(0) @binding(2)\nvar<storage, read_write> x: array<f32>;\n          \noverride workgroup_size_x: u32 = 1;\noverride workgroup_size_y: u32 = 1;\noverride workgroup_size_z: u32 = 1;\n\n@compute @workgroup_size(workgroup_size_x, workgroup_size_y, workgroup_size_z)\nfn main(\n  @builtin(local_invocation_id) local_id: vec3<u32>,\n  @builtin(workgroup_id) workgroup_id: vec3<u32>,\n  @builtin(num_workgroups) num_workgroups: vec3<u32>\n) {\n  let ts = workgroup_id.x;\n  let h = workgroup_id.y;\n  let ds = local_id.x;\n\n  for (var t = ts; t < args.n; t += num_workgroups.x) {\n    let x_start = args.x_offset + (t * args.num_heads + h) * args.head_dimension;\n    let encoding_start = args.encoding_offset + ((t + args.position) * args.rope_dimension);    \n    for (var d = ds; d < (args.head_dimension / 2u); d += workgroup_size_x) {\n      let i = 2u * d;\n      let x_idx = x_start + i;\n      let encoding_idx = encoding_start + i;\n      \n      let re = x[x_idx];\n      let im = x[x_idx + 1];\n      x[x_idx] = (re * encoding[encoding_idx]) - (im * encoding[encoding_idx + 1]);\n      x[x_idx + 1] = (re * encoding[encoding_idx + 1]) + (im * encoding[encoding_idx]);\n    }\n  }\n}\n\n".concat(emptyShader);var loadAttentionEncodeRopeInterleavedShader=function loadAttentionEncodeRopeInterleavedShader(device){var bindGroupLayout=device.createBindGroupLayout({label:"attention encode rope interleave bind group layout",entries:[{binding:0,visibility:GPUShaderStage.COMPUTE,buffer:{type:"uniform"}},{binding:1,visibility:GPUShaderStage.COMPUTE,buffer:{type:"read-only-storage"}},{binding:2,visibility:GPUShaderStage.COMPUTE,buffer:{type:"storage"}}]});var pipelineLayout=device.createPipelineLayout({label:"attention encode rope interleave pipeline layout",bindGroupLayouts:[bindGroupLayout]});var shaderModule=device.createShaderModule({label:"attention encode rope interleave shader module",code:attentionEncodeRopeInterleavedShaderSource});var computePipeline=device.createComputePipeline({label:"attention encode rope interleave pipeline",layout:pipelineLayout,compute:{module:shaderModule,entryPoint:shaderEntryPoint,constants:{workgroup_size_x:PV_PICOLLM_WEBGPU_DEFAULT_WORKGROUP_SIZE}}});return{computePipeline:computePipeline}};var ENCODE_SHADER_NAME="pv_picollm_attention_encode_shader";var attentionEncodeShaderSource="\nstruct argsStruct {  \n  n: u32,\n  num_heads: u32,\n  head_dimension: u32,\n  rope_dimension: u32,\n  position: u32,\n  encoding_offset: u32,\n  x_offset: u32,\n};\n\n@group(0) @binding(0) \nvar<uniform> args: argsStruct;\n\n@group(0) @binding(1)\nvar<storage, read> encoding: array<f32>;\n\n@group(0) @binding(2)\nvar<storage, read_write> x: array<f32>;\n          \noverride workgroup_size_x: u32 = 1;\noverride workgroup_size_y: u32 = 1;\noverride workgroup_size_z: u32 = 1;\n\n@compute @workgroup_size(workgroup_size_x, workgroup_size_y, workgroup_size_z)\nfn main(\n  @builtin(local_invocation_id) local_id: vec3<u32>,\n  @builtin(workgroup_id) workgroup_id: vec3<u32>,\n  @builtin(num_workgroups) num_workgroups: vec3<u32>\n) {\n  let ts = workgroup_id.x;\n  let h = workgroup_id.y;\n  let ds = local_id.x;\n\n  for (var t = ts; t < args.n; t += num_workgroups.x) {\n    let half_rope = (args.rope_dimension / 2);\n    let xr_start = args.x_offset + ((t * args.num_heads + h) * args.head_dimension);\n    let xi_start = xr_start + half_rope;\n    let encoding_start = args.encoding_offset + ((t + args.position) * args.rope_dimension);  \n    for (var d = ds; d < half_rope; d += workgroup_size_x) {\n      let xr_idx = xr_start + d;\n      let xi_idx = xi_start + d;\n      let encoding_idx = encoding_start + (2 * d);\n\n      let re = x[xr_idx];\n      let im = x[xi_idx];\n      x[xr_idx] = (re * encoding[encoding_idx]) - (im * encoding[encoding_idx + 1]);\n      x[xi_idx] = (re * encoding[encoding_idx + 1]) + (im * encoding[encoding_idx]);\n    }\n  }\n}\n\n".concat(emptyShader);var loadAttentionEncodeShader=function loadAttentionEncodeShader(device){var bindGroupLayout=device.createBindGroupLayout({label:"attention encode bind layout",entries:[{binding:0,visibility:GPUShaderStage.COMPUTE,buffer:{type:"uniform"}},{binding:1,visibility:GPUShaderStage.COMPUTE,buffer:{type:"read-only-storage"}},{binding:2,visibility:GPUShaderStage.COMPUTE,buffer:{type:"storage"}}]});var pipelineLayout=device.createPipelineLayout({label:"attention encode pipeline layout",bindGroupLayouts:[bindGroupLayout]});var shaderModule=device.createShaderModule({label:"attention encode shader",code:attentionEncodeShaderSource});var computePipeline=device.createComputePipeline({label:"attention encode pipeline",layout:pipelineLayout,compute:{module:shaderModule,entryPoint:shaderEntryPoint,constants:{workgroup_size_x:PV_PICOLLM_WEBGPU_DEFAULT_WORKGROUP_SIZE}}});return{computePipeline:computePipeline}};var DOT_PRODUCT_SHADER_NAME="pv_picollm_attention_dot_product_shader";var attentionDotProductShaderSource="\nstruct argsStruct {  \n  n: u32,\n  tq: u32,\n  head_dimension: u32,\n  num_heads: u32,\n  num_kv_heads: u32,\n  window_length: u32,\n  start: u32,\n  norm: f32,\n  length1: u32,\n  num_keys: u32,\n  query_offset: u32,\n  keys_offset: u32,\n  key_intercepts_offset: u32,\n  key_slopes_offset: u32,\n  scores_offset: u32,\n};\n\n@group(0) @binding(0) \nvar<uniform> args: argsStruct;\n\n@group(0) @binding(1)\nvar<storage, read> query: array<f32>;\n\n@group(0) @binding(2)\nvar<storage, read> keys: array<u32>;\n\n@group(0) @binding(3)\nvar<storage, read> key_intercepts: array<f32>;\n\n@group(0) @binding(4)\nvar<storage, read> key_slopes: array<f32>;\n\n@group(0) @binding(5)\nvar<storage, read_write> scores: array<f32>;\n       \noverride workgroup_size_x: u32 = 1;\noverride workgroup_size_y: u32 = 1;\noverride workgroup_size_z: u32 = 1;\n\n@compute @workgroup_size(workgroup_size_x, workgroup_size_y, workgroup_size_z)\nfn main(@builtin(global_invocation_id) global_id: vec3<u32>) {\n  if (global_id.x >= args.num_heads) {\n    return;\n  }\n\n  let head = global_id.x / (args.num_heads / args.num_kv_heads);\n  \n  let head_offset = head * args.window_length;\n  let start_index = head_offset + args.start;\n    \n  let keys_local_a = args.keys_offset + (start_index * args.head_dimension);\n  let key_intercepts_local_a = args.key_intercepts_offset + start_index;  \n  let key_slopes_local_a = args.key_slopes_offset + start_index;\n  \n  let keys_local_b = args.keys_offset + (head_offset * args.head_dimension);\n  let key_intercepts_local_b = args.key_intercepts_offset + head_offset;  \n  let key_slopes_local_b = args.key_slopes_offset + head_offset;\n  \n  let scores_local = args.scores_offset + (global_id.x * args.num_keys);\n  let query_local = args.query_offset + (((global_id.x * args.n) + args.tq) * args.head_dimension);\n    \n  for (var i = 0u; i < args.head_dimension; i++) {      \n    for (var k = 0u; k < args.num_keys; k++) {\n      if (k < args.length1) { \n        let key_idx = keys_local_a + (k * args.head_dimension) + i;\n        let key_val = f32(extractBits(keys[key_idx / 4], (i * 8u) % 32u, 8u));\n        let tmp = query[query_local + i] * (key_intercepts[key_intercepts_local_a + k] + (key_slopes[key_slopes_local_a + k] * key_val));\n        scores[scores_local + k] += tmp;\n      }\n      else {\n        let j = k - args.length1;\n        let key_idx = keys_local_b + (j * args.head_dimension) + i;\n        let key_val = f32(extractBits(keys[key_idx / 4], (i * 8u) % 32u, 8u));\n        let tmp = query[query_local + i] * (key_intercepts[key_intercepts_local_b + j] + (key_slopes[key_slopes_local_b + j] * key_val));\n        scores[scores_local + k] += tmp;\n      }\n    }    \n  }\n  \n  for (var k = 0u; k < args.num_keys; k++) {\n    scores[scores_local + k] *= args.norm;\n  }\n}\n\n".concat(emptyShader);var loadAttentionDotProductShader=function loadAttentionDotProductShader(device){var bindGroupLayout=device.createBindGroupLayout({label:"attention dot product bind group layout",entries:[{binding:0,visibility:GPUShaderStage.COMPUTE,buffer:{type:"uniform"}},{binding:1,visibility:GPUShaderStage.COMPUTE,buffer:{type:"read-only-storage"}},{binding:2,visibility:GPUShaderStage.COMPUTE,buffer:{type:"read-only-storage"}},{binding:3,visibility:GPUShaderStage.COMPUTE,buffer:{type:"read-only-storage"}},{binding:4,visibility:GPUShaderStage.COMPUTE,buffer:{type:"read-only-storage"}},{binding:5,visibility:GPUShaderStage.COMPUTE,buffer:{type:"storage"}}]});var pipelineLayout=device.createPipelineLayout({label:"attention dot product pipeline layout",bindGroupLayouts:[bindGroupLayout]});var shaderModule=device.createShaderModule({label:"attention dot product shader module",code:attentionDotProductShaderSource});var computePipeline=device.createComputePipeline({label:"attention dot product pipeline",layout:pipelineLayout,compute:{module:shaderModule,entryPoint:shaderEntryPoint}});return{computePipeline:computePipeline}};var SOFTMAX_SHADER_NAME="pv_picollm_attention_softmax_shader";var attentionSoftmaxShaderSource="\nstruct argsStruct {  \n  num_heads: u32,\n  num_keys: u32,\n  scores_offset: u32,\n};\n\n@group(0) @binding(0) \nvar<uniform> args: argsStruct;\n\n@group(0) @binding(1)\nvar<storage, read_write> scores: array<f32>;\n\noverride workgroup_size_x: u32 = 1;\noverride workgroup_size_y: u32 = 1;\noverride workgroup_size_z: u32 = 1;\n\n@compute @workgroup_size(workgroup_size_x, workgroup_size_y, workgroup_size_z)\nfn main(@builtin(global_invocation_id) global_id: vec3<u32>) {\n  if (global_id.x >= args.num_heads) {\n    return;\n  }\n\n  let scores_start = args.scores_offset + (global_id.x * args.num_keys);\n  \n  var max_index: u32 = 0;\n  for (var i = 1u; i < args.num_keys; i++) {\n    if (scores[scores_start + i] > scores[scores_start + max_index]) {\n      max_index = i;\n    }\n  }\n  let max: f32 = scores[scores_start + max_index];\n\n  var sum: f32 = 0.0;\n  for (var i = 0u; i < args.num_keys; i++) {\n    scores[scores_start + i] = exp(scores[scores_start + i] - max);\n    sum += scores[scores_start + i];\n  }\n\n  for (var i = 0u; i < args.num_keys; i++) {\n    scores[scores_start + i] /= sum;\n  }\n}\n\n".concat(emptyShader);var loadAttentionSoftmaxShader=function loadAttentionSoftmaxShader(device){var bindGroupLayout=device.createBindGroupLayout({label:"attention softmax bind group layout",entries:[{binding:0,visibility:GPUShaderStage.COMPUTE,buffer:{type:"uniform"}},{binding:1,visibility:GPUShaderStage.COMPUTE,buffer:{type:"storage"}}]});var pipelineLayout=device.createPipelineLayout({label:"attention softmax pipeline layout",bindGroupLayouts:[bindGroupLayout]});var shaderModule=device.createShaderModule({label:"attention softmax shader module",code:attentionSoftmaxShaderSource});var computePipeline=device.createComputePipeline({label:"attention softmax pipeline",layout:pipelineLayout,compute:{module:shaderModule,entryPoint:shaderEntryPoint}});return{computePipeline:computePipeline}};var FIR_SHADER_NAME="pv_picollm_attention_fir_shader";var attentionFirShaderSource="\nstruct argsStruct {  \n  length1: u32,\n  length2: u32,\n  tq: u32,\n  head_dimension: u32,\n  num_heads: u32,\n  num_kv_heads: u32,\n  window_length: u32,\n  start: u32,\n  values_offset: u32,\n  value_intercepts_offset: u32,\n  value_slopes_offset: u32,\n  scores_offset: u32,\n  output_offset: u32,\n};\n\n@group(0) @binding(0) \nvar<uniform> args: argsStruct;\n\n@group(0) @binding(1)\nvar<storage, read> values: array<u32>;\n\n@group(0) @binding(2)\nvar<storage, read> value_intercepts: array<f32>;\n\n@group(0) @binding(3)\nvar<storage, read> value_slopes: array<f32>;\n\n@group(0) @binding(4)\nvar<storage, read> scores: array<f32>;\n\n@group(0) @binding(5)\nvar<storage, read_write> output: array<f32>;\n          \noverride workgroup_size_x: u32 = 1;\noverride workgroup_size_y: u32 = 1;\noverride workgroup_size_z: u32 = 1;\n\n@compute @workgroup_size(workgroup_size_x, workgroup_size_y, workgroup_size_z)\nfn main(@builtin(global_invocation_id) global_id: vec3<u32>) {\n  if (global_id.x >= args.num_heads) {\n    return;\n  }\n\n  let head = global_id.x / (args.num_heads / args.num_kv_heads);\n\n  let head_offset = head * args.window_length;\n  let start_index = head_offset + args.start;\n\n  let values_local_a = args.values_offset + (start_index * args.head_dimension);\n  let value_intercepts_local_a = args.value_intercepts_offset + start_index;\n  let value_slopes_local_a = args.value_slopes_offset + start_index;\n  let values_local_b = args.values_offset + (head_offset * args.head_dimension);\n  let value_intercepts_local_b = args.value_intercepts_offset + head_offset;\n  let value_slopes_local_b = args.value_slopes_offset + head_offset;\n  let scores_local = args.scores_offset + (global_id.x * (args.length1 + args.length2));\n  let output_local = args.output_offset + (((args.tq * args.num_heads) + global_id.x) * args.head_dimension);\n\n  for (var i = 0u; i < args.head_dimension; i++) {\n    var tmp: f32 = 0.0;\n    for (var k = 0u; k < args.length1; k++) {\n      let value_idx = values_local_a + (k * args.head_dimension) + i;\n      let value_val = f32(extractBits(values[value_idx / 4], (i * 8u) % 32u, 8u));\n      tmp += scores[scores_local + k] * (value_intercepts[value_intercepts_local_a + k] + (value_slopes[value_slopes_local_a + k] * value_val));             \n    }\n    for (var k = 0u; k < args.length2; k++) {\n      let value_idx = values_local_b + (k * args.head_dimension) + i;\n      let value_val = f32(extractBits(values[value_idx / 4], (i * 8u) % 32u, 8u));\n      tmp += scores[scores_local + args.length1 + k] * (value_intercepts[value_intercepts_local_b + k] + (value_slopes[value_slopes_local_b + k] * value_val));      \n    }\n    output[output_local + i] = tmp;\n  }\n}\n\n".concat(emptyShader);var loadAttentionFirShader=function loadAttentionFirShader(device){var bindGroupLayout=device.createBindGroupLayout({label:"attention fir bind group layout",entries:[{binding:0,visibility:GPUShaderStage.COMPUTE,buffer:{type:"uniform"}},{binding:1,visibility:GPUShaderStage.COMPUTE,buffer:{type:"read-only-storage"}},{binding:2,visibility:GPUShaderStage.COMPUTE,buffer:{type:"read-only-storage"}},{binding:3,visibility:GPUShaderStage.COMPUTE,buffer:{type:"read-only-storage"}},{binding:4,visibility:GPUShaderStage.COMPUTE,buffer:{type:"read-only-storage"}},{binding:5,visibility:GPUShaderStage.COMPUTE,buffer:{type:"storage"}}]});var pipelineLayout=device.createPipelineLayout({label:"attention fir pipeline layout",bindGroupLayouts:[bindGroupLayout]});var shaderModule=device.createShaderModule({label:"attention fir shader module",code:attentionFirShaderSource});var computePipeline=device.createComputePipeline({label:"attention fir pipeline",layout:pipelineLayout,compute:{module:shaderModule,entryPoint:shaderEntryPoint}});return{computePipeline:computePipeline}};var UPDATE_KV_SHADER_NAME="pv_picollm_attention_update_kv_shader";var attentionUpdateKvShaderSource="\nstruct argsStruct {\n  n: u32,\n  num_kv_heads: u32,\n  window_length: u32,\n  position: u32,\n  head_dimension: u32,\n  tf_offset: u32,\n  kv_offset: u32,\n  kv_intercepts_offset: u32,\n  kv_slopes_offset: u32,\n};\n\n@group(0) @binding(0) \nvar<uniform> args: argsStruct;\n\n@group(0) @binding(1)\nvar<storage, read> tf: array<f32>;\n\n@group(0) @binding(2)\nvar<storage, read_write> kv: array<u32>;\n\n@group(0) @binding(3)\nvar<storage, read_write> kv_intercepts: array<f32>;\n\n@group(0) @binding(4)\nvar<storage, read_write> kv_slopes: array<f32>;\n          \noverride workgroup_size_x: u32 = 1;\noverride workgroup_size_y: u32 = 1;\noverride workgroup_size_z: u32 = 1;\n\n@compute @workgroup_size(workgroup_size_x, workgroup_size_y, workgroup_size_z)\nfn main(@builtin(global_invocation_id) global_id: vec3<u32>) {  \n  if (global_id.x >= args.num_kv_heads) {\n    return;\n  }\n  \n  for (var i = 0u; i < args.n; i++) {\n    let index = (global_id.x * args.window_length) + ((args.position + i) % args.window_length);\n    let tf_start = args.tf_offset + (((i * args.num_kv_heads) + global_id.x) * args.head_dimension);\n    let kv_start = args.kv_offset + ((index * args.head_dimension) / 4);\n    let kv_intercepts_start = args.kv_intercepts_offset + index;\n    let kv_slopes_start = args.kv_slopes_offset + index;\n    \n    var xmax = tf[tf_start];    \n    var xmin = tf[tf_start];    \n    \n    for (var j = 1u; j < args.head_dimension; j++) {\n      xmax = max(xmax, tf[tf_start + j]);\n      xmin = min(xmin, tf[tf_start + j]);\n    }\n\n    kv_intercepts[kv_intercepts_start] = xmin;\n    kv_slopes[kv_slopes_start] = f32(xmax - xmin) / 255.0;\n\n    for (var j = 0u; j < args.head_dimension; j++) {\n      let kv_idx = kv_start + (j / 4);\n      let kv_val = u32(round((tf[tf_start + j] - xmin) / kv_slopes[kv_slopes_start]));      \n      kv[kv_idx] = insertBits(kv[kv_idx], extractBits(kv_val, 0u, 8u), (j * 8u) % 32u, 8u);      \n    }\n  }\n}\n\n".concat(emptyShader);var loadAttentionUpdateKvShader=function loadAttentionUpdateKvShader(device){var bindGroupLayout=device.createBindGroupLayout({label:"attention update kv bind group layout",entries:[{binding:0,visibility:GPUShaderStage.COMPUTE,buffer:{type:"uniform"}},{binding:1,visibility:GPUShaderStage.COMPUTE,buffer:{type:"read-only-storage"}},{binding:2,visibility:GPUShaderStage.COMPUTE,buffer:{type:"storage"}},{binding:3,visibility:GPUShaderStage.COMPUTE,buffer:{type:"storage"}},{binding:4,visibility:GPUShaderStage.COMPUTE,buffer:{type:"storage"}}]});var pipelineLayout=device.createPipelineLayout({label:"attention update kv pipeline layout",bindGroupLayouts:[bindGroupLayout]});var shaderModule=device.createShaderModule({label:"attention update kv shader module",code:attentionUpdateKvShaderSource});var computePipeline=device.createComputePipeline({label:"attention update kv pipeline",layout:pipelineLayout,compute:{module:shaderModule,entryPoint:shaderEntryPoint}});return{computePipeline:computePipeline}};var TRANSPOSE_QUERY_SHADER_NAME="pv_picollm_attention_transpose_query_shader";var attentionTransposeQueryShaderSource="\nstruct argsStruct {\n  n: u32,\n  num_heads: u32,\n  head_dimension: u32,\n  tf_offset: u32,\n  hf_offset: u32,\n};\n\n@group(0) @binding(0) \nvar<uniform> args: argsStruct;\n\n@group(0) @binding(1)\nvar<storage, read> tf: array<f32>;\n\n@group(0) @binding(2)\nvar<storage, read_write> hf: array<f32>;\n\noverride workgroup_size_x: u32 = 1;\noverride workgroup_size_y: u32 = 1;\noverride workgroup_size_z: u32 = 1;\n\n@compute @workgroup_size(workgroup_size_x, workgroup_size_y, workgroup_size_z)\nfn main(\n  @builtin(workgroup_id) workgroup_id : vec3<u32>,\n  @builtin(local_invocation_id) local_id : vec3<u32>\n) {\n\n  if (workgroup_id.x >= args.num_heads || workgroup_id.y >= args.n || local_id.x >= args.head_dimension) {\n    return;\n  }\n  \n  let tf_idx = args.tf_offset + (workgroup_id.y * args.num_heads * args.head_dimension) + (workgroup_id.x * args.head_dimension) + local_id.x; \n  let hf_idx = args.hf_offset + (workgroup_id.x * args.n * args.head_dimension) + (workgroup_id.y * args.head_dimension) + local_id.x;  \n  hf[hf_idx] = tf[tf_idx];\n}\n\n".concat(emptyShader);var loadAttentionTransposeQueryShader=function loadAttentionTransposeQueryShader(device){var bindGroupLayout=device.createBindGroupLayout({label:"attention transpose query bind group layout",entries:[{binding:0,visibility:GPUShaderStage.COMPUTE,buffer:{type:"uniform"}},{binding:1,visibility:GPUShaderStage.COMPUTE,buffer:{type:"read-only-storage"}},{binding:2,visibility:GPUShaderStage.COMPUTE,buffer:{type:"storage"}}]});var pipelineLayout=device.createPipelineLayout({label:"attention transpose query pipeline layout",bindGroupLayouts:[bindGroupLayout]});var shaderModule=device.createShaderModule({label:"attention transpose query shader module",code:attentionTransposeQueryShaderSource});var computePipeline=device.createComputePipeline({label:"attention transpose query pipeline",layout:pipelineLayout,compute:{module:shaderModule,entryPoint:shaderEntryPoint,constants:{workgroup_size_x:PV_PICOLLM_WEBGPU_DEFAULT_WORKGROUP_SIZE}}});return{computePipeline:computePipeline}};var attentionShaders=_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty({},PRECOMPUTE_ENCODING_SHADER_NAME,loadAttentionPrecomputeEncodingShader),ENCODE_ROPE_INTERLEAVED_SHADER_NAME,loadAttentionEncodeRopeInterleavedShader),ENCODE_SHADER_NAME,loadAttentionEncodeShader),DOT_PRODUCT_SHADER_NAME,loadAttentionDotProductShader),SOFTMAX_SHADER_NAME,loadAttentionSoftmaxShader),FIR_SHADER_NAME,loadAttentionFirShader),UPDATE_KV_SHADER_NAME,loadAttentionUpdateKvShader),TRANSPOSE_QUERY_SHADER_NAME,loadAttentionTransposeQueryShader);var SILU_SHADER_NAME="pv_picollm_feed_forward_silu_shader";var feedForwardSiluShaderSource="\nstruct argsStruct {\n  n: u32,\n};\n\n@group(0) @binding(0) \nvar<uniform> args: argsStruct;\n\n@group(0) @binding(1)\nvar<storage, read_write> x: array<f32>;\n\noverride workgroup_size_x: u32 = 1;\noverride workgroup_size_y: u32 = 1;\noverride workgroup_size_z: u32 = 1;\n\n@compute @workgroup_size(workgroup_size_x, workgroup_size_y, workgroup_size_z)\nfn main(@builtin(global_invocation_id) global_id: vec3<u32>) {\n  if (global_id.x >= args.n) {\n    return;\n  }\n  x[global_id.x] = x[global_id.x] / (1.0 + exp(-x[global_id.x]));\n}\n\n".concat(emptyShader);var loadFeedForwardSiluShader=function loadFeedForwardSiluShader(device){var bindGroupLayout=device.createBindGroupLayout({label:"ff silu bind group layout",entries:[{binding:0,visibility:GPUShaderStage.COMPUTE,buffer:{type:"uniform"}},{binding:1,visibility:GPUShaderStage.COMPUTE,buffer:{type:"storage"}}]});var pipelineLayout=device.createPipelineLayout({label:"ff silu pipeline layout",bindGroupLayouts:[bindGroupLayout]});var shaderModule=device.createShaderModule({label:"ff silu shader module",code:feedForwardSiluShaderSource});var computePipeline=device.createComputePipeline({label:"ff silu pipline",layout:pipelineLayout,compute:{module:shaderModule,entryPoint:shaderEntryPoint,constants:{workgroup_size_x:PV_PICOLLM_WEBGPU_DEFAULT_WORKGROUP_SIZE}}});return{computePipeline:computePipeline}};var GELU_SHADER_NAME="pv_picollm_feed_forward_gelu_shader";var feedForwardGeluShaderSource="\nstruct argsStruct {\n  n: u32,\n};\n\n@group(0) @binding(0) \nvar<uniform> args: argsStruct;\n\n@group(0) @binding(1)\nvar<storage, read_write> x: array<f32>;\n\nconst a1: f32 = 0.254829592;\nconst a2: f32 = -0.284496736;\nconst a3: f32 = 1.421413741;\nconst a4: f32 = -1.453152027;\nconst a5: f32 = 1.061405429;\nconst p: f32 = 0.3275911;\n\n// A&S formula 7.1.26\nfn erf(x: f32) -> f32 {    \n    var sign: f32 = 1.0;\n    if (x < 0) {\n        sign = -1.0;\n    }\n    var x_abs: f32 = abs(x);\n    \n    let t: f32 = 1.0 / fma(p, x_abs, 1.0);\n    let y: f32 = 1.0 - (((((a5 * t + a4) * t) + a3) * t + a2) * t + a1) * t * exp(-x_abs * x_abs);\n\n    return sign * y;\n}\n\noverride workgroup_size_x: u32 = 1;\noverride workgroup_size_y: u32 = 1;\noverride workgroup_size_z: u32 = 1;\n\n@compute @workgroup_size(workgroup_size_x, workgroup_size_y, workgroup_size_z)\nfn main(@builtin(global_invocation_id) global_id: vec3<u32>) {\n  if (global_id.x >= args.n) {\n    return;\n  }\n  x[global_id.x] = 0.5 * x[global_id.x] * (1.0 + erf(x[global_id.x] * 0.7071067811865475));\n}\n\n".concat(emptyShader);var loadFeedForwardGeluShader=function loadFeedForwardGeluShader(device){var bindGroupLayout=device.createBindGroupLayout({label:"ff gelu bind group layout",entries:[{binding:0,visibility:GPUShaderStage.COMPUTE,buffer:{type:"uniform"}},{binding:1,visibility:GPUShaderStage.COMPUTE,buffer:{type:"storage"}}]});var pipelineLayout=device.createPipelineLayout({label:"ff gelu pipeline layout",bindGroupLayouts:[bindGroupLayout]});var shaderModule=device.createShaderModule({label:"ff gelu shader module",code:feedForwardGeluShaderSource});var computePipeline=device.createComputePipeline({label:"ff gelu pipeline",layout:pipelineLayout,compute:{module:shaderModule,entryPoint:shaderEntryPoint,constants:{workgroup_size_x:PV_PICOLLM_WEBGPU_DEFAULT_WORKGROUP_SIZE}}});return{computePipeline:computePipeline}};var ALMOST_GELU_SHADER_NAME="pv_picollm_feed_forward_almost_gelu_shader";var feedForwardAlmostGeluShaderSource="\nstruct argsStruct {\n  n: u32,\n};\n\n@group(0) @binding(0) \nvar<uniform> args: argsStruct;\n\n@group(0) @binding(1)\nvar<storage, read_write> x: array<f32>;\n\noverride workgroup_size_x: u32 = 1;\noverride workgroup_size_y: u32 = 1;\noverride workgroup_size_z: u32 = 1;\n\n@compute @workgroup_size(workgroup_size_x, workgroup_size_y, workgroup_size_z)\nfn main(@builtin(global_invocation_id) global_id: vec3<u32>) {\n  if (global_id.x >= args.n) {\n    return;\n  }\n  x[global_id.x] = 0.5 * x[global_id.x] * (1 + tanh(0.7978845608028654 * (x[global_id.x] + (0.044715f * x[global_id.x] * x[global_id.x] * x[global_id.x]))));\n}\n\n".concat(emptyShader);var loadFeedForwardAlmostGeluShader=function loadFeedForwardAlmostGeluShader(device){var bindGroupLayout=device.createBindGroupLayout({label:"ff almost gelu bind group layout",entries:[{binding:0,visibility:GPUShaderStage.COMPUTE,buffer:{type:"uniform"}},{binding:1,visibility:GPUShaderStage.COMPUTE,buffer:{type:"storage"}}]});var pipelineLayout=device.createPipelineLayout({label:"ff almost gelu pipeline layout",bindGroupLayouts:[bindGroupLayout]});var shaderModule=device.createShaderModule({label:"ff almost gelu shader module",code:feedForwardAlmostGeluShaderSource});var computePipeline=device.createComputePipeline({label:"ff almost gelu pipeline",layout:pipelineLayout,compute:{module:shaderModule,entryPoint:shaderEntryPoint,constants:{workgroup_size_x:PV_PICOLLM_WEBGPU_DEFAULT_WORKGROUP_SIZE}}});return{computePipeline:computePipeline}};var MULTIPLY_BUFFERS_SHADER_NAME="pv_picollm_feed_forward_multiply_buffers_shader";var feedForwardMultiplyBuffersShaderSource="\nstruct argsStruct {\n  n: u32,\n};\n\n@group(0) @binding(0) \nvar<uniform> args: argsStruct;\n\n@group(0) @binding(1)\nvar<storage, read> x: array<f32>;\n\n@group(0) @binding(2)\nvar<storage, read_write> y: array<f32>;\n\noverride workgroup_size_x: u32 = 1;\noverride workgroup_size_y: u32 = 1;\noverride workgroup_size_z: u32 = 1;\n\n@compute @workgroup_size(workgroup_size_x, workgroup_size_y, workgroup_size_z)\nfn main(@builtin(global_invocation_id) global_id: vec3<u32>) {\n  if (global_id.x >= args.n) {\n    return;\n  }\n  y[global_id.x] *= x[global_id.x];\n}\n\n".concat(emptyShader);var loadFeedForwardMultiplyBuffersShader=function loadFeedForwardMultiplyBuffersShader(device){var bindGroupLayout=device.createBindGroupLayout({label:"ff multiply buffers bind group layout",entries:[{binding:0,visibility:GPUShaderStage.COMPUTE,buffer:{type:"uniform"}},{binding:1,visibility:GPUShaderStage.COMPUTE,buffer:{type:"read-only-storage"}},{binding:2,visibility:GPUShaderStage.COMPUTE,buffer:{type:"storage"}}]});var pipelineLayout=device.createPipelineLayout({label:"ff multiply buffers pipeline layout",bindGroupLayouts:[bindGroupLayout]});var shaderModule=device.createShaderModule({label:"ff multiply buffers shader module",code:feedForwardMultiplyBuffersShaderSource});var computePipeline=device.createComputePipeline({label:"ff multiply buffers pipeline",layout:pipelineLayout,compute:{module:shaderModule,entryPoint:shaderEntryPoint,constants:{workgroup_size_x:PV_PICOLLM_WEBGPU_DEFAULT_WORKGROUP_SIZE}}});return{computePipeline:computePipeline}};var feedForwardShaders=_defineProperty(_defineProperty(_defineProperty(_defineProperty({},SILU_SHADER_NAME,loadFeedForwardSiluShader),GELU_SHADER_NAME,loadFeedForwardGeluShader),ALMOST_GELU_SHADER_NAME,loadFeedForwardAlmostGeluShader),MULTIPLY_BUFFERS_SHADER_NAME,loadFeedForwardMultiplyBuffersShader);var FORWARD_SHADER_NAME$1="pv_picollm_gate_forward_shader";var gateForwardShaderSource="\n\nstruct pv_picollm_gate_ix_t {\n  i: u32,\n  x: f32,\n}\n\n@group(0) @binding(0)\nvar<storage, read> y: array<f32>;\n\n@group(0) @binding(1)\nvar<storage, read_write> indices: array<u32>;\n\n@group(0) @binding(2)\nvar<storage, read_write> weights: array<f32>;\n\noverride n: u32 = 0;\noverride k: u32 = 0;\noverride num_experts: u32 = 0;\n\noverride y_offset: u32 = 0;\noverride indices_offset: u32 = 0;\noverride weights_offset: u32 = 0;\n\nvar<workgroup> ixs: array<pv_picollm_gate_ix_t, num_experts>;\n  \noverride workgroup_size_x: u32 = 1;\noverride workgroup_size_y: u32 = 1;\noverride workgroup_size_z: u32 = 1;\n\n@compute @workgroup_size(workgroup_size_x, workgroup_size_y, workgroup_size_z)\nfn main(\n  @builtin(global_invocation_id) global_id : vec3<u32>\n) {\n  if (global_id.x >= n) {\n    return;\n  }\n  \n  var y_start: u32 = y_offset + global_id.x * num_experts;\n  for (var j = 0u; j < num_experts; j++) {\n      ixs[j].i = j;\n      ixs[j].x = y[y_start + j];\n  }\n\n  for (var i = 0u; i < num_experts - 1; i++) {\n    for (var j = 0u; j < num_experts - i - 1; j++) {\n      if (ixs[j].x < ixs[j + 1].x) {\n        let tmp = ixs[j];\n        ixs[j] = ixs[j + 1];\n        ixs[j + 1] = tmp;\n      }\n    }\n  }\n\n  for (var j = 0u; j < k; j++) {\n      indices[indices_offset + (global_id.x * k) + j] = ixs[j].i;\n      weights[weights_offset + (global_id.x * k) + j] = ixs[j].x;\n  }\n\n  var max_weight: f32 = weights[weights_offset + (global_id.x * k)];\n  for (var j = 1u; j < k; j++) {\n      max_weight = max(max_weight, weights[weights_offset + (global_id.x * k) + j]);\n  }\n\n  var sum_weight: f32 = 0.0;\n  for (var j = 0u; j < k; j++) {\n      weights[weights_offset + (global_id.x * k) + j] = exp(weights[weights_offset + (global_id.x * k) + j] - max_weight);\n      sum_weight += weights[weights_offset + (global_id.x * k) + j];\n  }\n\n  for (var j = 0u; j < k; j++) {\n      weights[weights_offset + (global_id.x * k) + j] /= sum_weight;\n  }\n}\n\n".concat(emptyShader);var loadGateForwardShader=function loadGateForwardShader(device){var bindGroupLayout=device.createBindGroupLayout({label:"gate forward bind group layout",entries:[{binding:0,visibility:GPUShaderStage.COMPUTE,buffer:{type:"read-only-storage"}},{binding:1,visibility:GPUShaderStage.COMPUTE,buffer:{type:"storage"}},{binding:2,visibility:GPUShaderStage.COMPUTE,buffer:{type:"storage"}}]});var pipelineLayout=device.createPipelineLayout({label:"gate forward pipeline",bindGroupLayouts:[bindGroupLayout]});var shaderModule=device.createShaderModule({label:"gate forward shader module",code:gateForwardShaderSource});var computePipeline=device.createComputePipeline({layout:pipelineLayout,compute:{module:shaderModule,entryPoint:shaderEntryPoint,constants:{num_experts:1}}});return{computePipeline:computePipeline,pipelineLayout:pipelineLayout,shaderModule:shaderModule}};var gateForwardShader=_defineProperty({},FORWARD_SHADER_NAME$1,loadGateForwardShader);var ADD_TO_BUFFER_SHADER_NAME$1="pv_picollm_moe_transformer_add_to_buffer_shader";var moeTransformerAddToBufferShaderSource="\nstruct argsStruct {\n  n: u32,  \n  x_offset: u32,\n  buffer_offset: u32,\n};\n\n@group(0) @binding(0) \nvar<uniform> args: argsStruct;\n\n@group(0) @binding(1)\nvar<storage, read> x: array<f32>;\n\n@group(0) @binding(2)\nvar<storage, read_write> buffer: array<f32>;\n\noverride workgroup_size_x: u32 = 1;\noverride workgroup_size_y: u32 = 1;\noverride workgroup_size_z: u32 = 1;\n\n@compute @workgroup_size(workgroup_size_x, workgroup_size_y, workgroup_size_z)\nfn main(@builtin(global_invocation_id) global_id: vec3<u32>) {\n  if (global_id.x >= args.n) {\n    return;\n  }\n\n  buffer[args.buffer_offset + global_id.x] += x[args.x_offset + global_id.x];  \n}\n\n".concat(emptyShader);var loadMoeTransformerAddToBufferShader=function loadMoeTransformerAddToBufferShader(device){var bindGroupLayout=device.createBindGroupLayout({label:"moe transformer add to buffer bind group layout",entries:[{binding:0,visibility:GPUShaderStage.COMPUTE,buffer:{type:"uniform"}},{binding:1,visibility:GPUShaderStage.COMPUTE,buffer:{type:"read-only-storage"}},{binding:2,visibility:GPUShaderStage.COMPUTE,buffer:{type:"storage"}}]});var pipelineLayout=device.createPipelineLayout({label:"moe transformer add to buffer pipeline",bindGroupLayouts:[bindGroupLayout]});var shaderModule=device.createShaderModule({label:"moe transformer add to buffer shader module",code:moeTransformerAddToBufferShaderSource});var computePipeline=device.createComputePipeline({label:"moe transformer add to buffer pipeline",layout:pipelineLayout,compute:{module:shaderModule,entryPoint:shaderEntryPoint}});return{computePipeline:computePipeline}};var MULTIPLY_WEIGHT_AND_ADD_TO_BUFFER_SHADER_NAME="pv_picollm_moe_transformer_multiply_weight_and_add_to_buffer_shader";var moeTransformerMultiplyWeightAndToBufferShaderSource="\nstruct argsStruct {\n  n: u32,  \n  weights_index: u32,\n  y_index: u32,\n  weights_offset: u32,\n  x_offset: u32,\n  y_offset: u32,\n};\n\n@group(0) @binding(0) \nvar<uniform> args: argsStruct;\n\n@group(0) @binding(1)\nvar<storage, read> weights: array<f32>;\n\n@group(0) @binding(2)\nvar<storage, read> x: array<f32>;\n\n@group(0) @binding(3)\nvar<storage, read_write> y: array<f32>;\n\noverride workgroup_size_x: u32 = 1;\noverride workgroup_size_y: u32 = 1;\noverride workgroup_size_z: u32 = 1;\n\n@compute @workgroup_size(workgroup_size_x, workgroup_size_y, workgroup_size_z)\nfn main(@builtin(global_invocation_id) global_id: vec3<u32>) {\n  if (global_id.x >= args.n) {\n    return;\n  }\n    \n  y[args.y_offset + args.y_index + global_id.x] += weights[args.weights_index] + x[args.x_offset + global_id.x];   \n}\n\n".concat(emptyShader);var loadMoeTransformerMultiplyWeightAndAddToBufferShader=function loadMoeTransformerMultiplyWeightAndAddToBufferShader(device){var bindGroupLayout=device.createBindGroupLayout({label:"moe transformer multiply weight and add to buffer bind group layout",entries:[{binding:0,visibility:GPUShaderStage.COMPUTE,buffer:{type:"uniform"}},{binding:1,visibility:GPUShaderStage.COMPUTE,buffer:{type:"read-only-storage"}},{binding:2,visibility:GPUShaderStage.COMPUTE,buffer:{type:"read-only-storage"}},{binding:3,visibility:GPUShaderStage.COMPUTE,buffer:{type:"storage"}}]});var pipelineLayout=device.createPipelineLayout({label:"moe transformer multiply weight and add to buffer pipeline",bindGroupLayouts:[bindGroupLayout]});var shaderModule=device.createShaderModule({label:"moe transformer multiply weight and add to buffer shader module",code:moeTransformerMultiplyWeightAndToBufferShaderSource});var computePipeline=device.createComputePipeline({label:"moe transformer multiply weight and add to buffer pipeline",layout:pipelineLayout,compute:{module:shaderModule,entryPoint:shaderEntryPoint}});return{computePipeline:computePipeline}};var ADD_BUFFERS_SHADER_NAME$1="pv_picollm_moe_transformer_add_buffers_shader";var moeTransformerAddBuffersShaderSource="\nstruct argsStruct {\n  n: u32,  \n  buffer1_offset: u32,\n  buffer2_offset: u32,\n  y_offset: u32,  \n};\n\n@group(0) @binding(0) \nvar<uniform> args: argsStruct;\n\n@group(0) @binding(1)\nvar<storage, read> buffer1: array<f32>;\n\n@group(0) @binding(2)\nvar<storage, read> buffer2: array<f32>;\n\n@group(0) @binding(3)\nvar<storage, read_write> y: array<f32>;\n\noverride workgroup_size_x: u32 = 1;\noverride workgroup_size_y: u32 = 1;\noverride workgroup_size_z: u32 = 1;\n\n@compute @workgroup_size(workgroup_size_x, workgroup_size_y, workgroup_size_z)\nfn main(@builtin(global_invocation_id) global_id: vec3<u32>) {\n  if (global_id.x >= args.n) {\n    return;\n  }\n    \n  y[args.y_offset + global_id.x] = buffer1[args.buffer1_offset + global_id.x] + buffer2[args.buffer2_offset + global_id.x];   \n}\n\n".concat(emptyShader);var loadMoeTransformerAddBuffersShader=function loadMoeTransformerAddBuffersShader(device){var bindGroupLayout=device.createBindGroupLayout({label:"moe transformer add buffers bind group layout",entries:[{binding:0,visibility:GPUShaderStage.COMPUTE,buffer:{type:"uniform"}},{binding:1,visibility:GPUShaderStage.COMPUTE,buffer:{type:"read-only-storage"}},{binding:2,visibility:GPUShaderStage.COMPUTE,buffer:{type:"read-only-storage"}},{binding:3,visibility:GPUShaderStage.COMPUTE,buffer:{type:"storage"}}]});var pipelineLayout=device.createPipelineLayout({label:"moe transformer add buffers pipeline layout",bindGroupLayouts:[bindGroupLayout]});var shaderModule=device.createShaderModule({label:"moe transformer add buffers shader module",code:moeTransformerAddBuffersShaderSource});var computePipeline=device.createComputePipeline({label:"moe transformer add buffers pipeline",layout:pipelineLayout,compute:{module:shaderModule,entryPoint:shaderEntryPoint}});return{computePipeline:computePipeline}};var moeTransformerForwardShaders=_defineProperty(_defineProperty(_defineProperty({},ADD_TO_BUFFER_SHADER_NAME$1,loadMoeTransformerAddToBufferShader),MULTIPLY_WEIGHT_AND_ADD_TO_BUFFER_SHADER_NAME,loadMoeTransformerMultiplyWeightAndAddToBufferShader),ADD_BUFFERS_SHADER_NAME$1,loadMoeTransformerAddBuffersShader);var sdataReduce="\n  for (var s: u32 = workgroup_size_x / 2; s > 0; s >>= 1) {\n    if tid < s {\n        sdata[tid] += sdata[tid + s];\n    }\n    workgroupBarrier();\n  }\n";var dividePadFunction="\n  fn divide_pad(a: u32, b: u32) -> u32 { \n    return (a + b - 1) / b;\n  }\n";var FORWARD_MULTI_BUFFER_SHADER_NAME$1="pv_picollm_norm_forward_multi_buffer_shader";var FORWARD_SINGLE_BUFFER_SHADER_NAME$1="pv_picollm_norm_forward_single_buffer_shader";var normForwardShaderSource=function normForwardShaderSource(isMulti){return"\nstruct argsStruct {\n  n: u32,\n  dimension: u32,\n  remainder: u32,\n  remainder_start: u32, \n  eps: f32,  \n  x_offset: u32,\n  y_offset: u32,\n};\n\n@group(0) @binding(0) \nvar<uniform> args: argsStruct;\n\n@group(0) @binding(1)\nvar<storage, read> weight: array<f32>;\n\n".concat(isMulti?"\n@group(0) @binding(2)\nvar<storage, read> x: array<f32>;\n\n@group(0) @binding(3) \nvar<storage, read_write> y: array<f32>;\n":"    \n@group(0) @binding(2)\nvar<storage, read_write> x: array<f32>;\n","\n\noverride workgroup_size_x: u32 = 1;\noverride workgroup_size_y: u32 = 1;\noverride workgroup_size_z: u32 = 1;\n\nvar<workgroup> sdata: array<vec4<f32>, workgroup_size_x>;\n\n@compute @workgroup_size(workgroup_size_x, workgroup_size_y, workgroup_size_z)\nfn main(\n  @builtin(local_invocation_id) local_id: vec3<u32>,\n  @builtin(workgroup_id) workgroup_id: vec3<u32>\n) {\n  let tid = local_id.x;\n  let m = workgroup_id.x;\n  let block_size = workgroup_size_x;\n  \n  var power_vec: vec4<f32>;\n  let x_start: u32 = args.x_offset + (m * args.dimension);\n  let skip = tid * 4;\n  let shift = (block_size * 4);\n  for (var j = 0u; j + skip < args.remainder_start; j += shift) {\n    let local_index = x_start + j + skip; \n\n    let x_vec = vec4(\n      x[local_index],\n      x[local_index + 1],\n      x[local_index + 2],\n      x[local_index + 3]);\n    \n    power_vec += x_vec * x_vec; \n  }  \n  \n  if (tid == 0 && args.remainder > 0) {\n    var remainder_vec = vec4<f32>(0.0, 0.0, 0.0, 0.0);\n    let x_idx = x_start + args.remainder_start;\n    for (var j = 0u; j < args.remainder; j++) {       \n      remainder_vec[j] = x[x_idx + j];\n    }    \n    power_vec += remainder_vec * remainder_vec;\n  }\n  \n  sdata[tid] = power_vec;\n  workgroupBarrier();\n\n  ").concat(sdataReduce,"\n  \n  let power = sdata[0].x + sdata[0].y + sdata[0].z + sdata[0].w;\n  let norm: vec4<f32> = vec4(1.0 / sqrt((power / f32(args.dimension)) + args.eps));\n  \n  let y_start: u32 = args.y_offset + (m * args.dimension);\n  for (var j = 0u; j + skip < args.remainder_start; j += shift) {\n    let local_index = j + skip;\n    let x_idx = x_start + local_index;\n    let x_vec = vec4(\n      x[x_idx],\n      x[x_idx + 1],\n      x[x_idx + 2],\n      x[x_idx + 3]);\n          \n    let weight_vec = vec4(\n      weight[local_index],\n      weight[local_index + 1],\n      weight[local_index + 2],\n      weight[local_index + 3]);\n    let y_vec = x_vec * norm * weight_vec;\n    \n    let y_idx = y_start + local_index;\n").concat(isMulti?" \n    y[y_idx] = y_vec.x;\n    y[y_idx + 1] = y_vec.y;\n    y[y_idx + 2] = y_vec.z;\n    y[y_idx + 3] = y_vec.w;\n":"    \n    x[y_idx] = y_vec.x;\n    x[y_idx + 1] = y_vec.y;\n    x[y_idx + 2] = y_vec.z;\n    x[y_idx + 3] = y_vec.w;\n","   \n  }\n  \n  if (tid == 0 && args.remainder > 0) {\n    let x_idx = x_start + args.remainder_start;\n    let weight_idx = args.remainder_start;    \n    let y_idx = y_start + args.remainder_start;\n    for (var j = 0u; j < args.remainder; j++) {\n").concat(isMulti?"    \n      y[y_idx + j] = x[x_idx + j] * norm[j] * weight[weight_idx + j];\n":"    \n      x[y_idx + j] = x[x_idx + j] * norm[j] * weight[weight_idx + j];\n"," \n    }    \n  }\n}\n\n").concat(emptyShader)};var loadNormForwardShader=function loadNormForwardShader(device,isMulti){var entries=[{binding:0,visibility:GPUShaderStage.COMPUTE,buffer:{type:"uniform"}},{binding:1,visibility:GPUShaderStage.COMPUTE,buffer:{type:"read-only-storage"}}];if(isMulti){entries.push({binding:2,visibility:GPUShaderStage.COMPUTE,buffer:{type:"read-only-storage"}});entries.push({binding:3,visibility:GPUShaderStage.COMPUTE,buffer:{type:"storage"}})}else{entries.push({binding:2,visibility:GPUShaderStage.COMPUTE,buffer:{type:"storage"}})}var bindGroupLayout=device.createBindGroupLayout({label:"norm forward ".concat(isMulti?"multi":"single"," buffer bind group layout"),entries:entries});var pipelineLayout=device.createPipelineLayout({label:"norm forward ".concat(isMulti?"multi":"single"," buffer pipeline layout"),bindGroupLayouts:[bindGroupLayout]});var shaderModule=device.createShaderModule({label:"norm forward ".concat(isMulti?"multi":"single"," buffer shader module"),code:normForwardShaderSource(isMulti)});var computePipeline=device.createComputePipeline({label:"norm forward ".concat(isMulti?"multi":"single"," buffer pipeline"),layout:pipelineLayout,compute:{module:shaderModule,entryPoint:shaderEntryPoint,constants:{workgroup_size_x:PV_PICOLLM_WEBGPU_DEFAULT_WORKGROUP_SIZE}}});return{computePipeline:computePipeline}};var normForwardShader=_defineProperty(_defineProperty({},FORWARD_SINGLE_BUFFER_SHADER_NAME$1,function(device){return loadNormForwardShader(device,false)}),FORWARD_MULTI_BUFFER_SHADER_NAME$1,function(device){return loadNormForwardShader(device,true)});var FORWARD_MULTI_BUFFER_SHADER_NAME="pv_picollm_norm_layer_forward_multi_buffer_shader";var normLayerForwardMultiBufferShaderSource="\nstruct argsStruct {\n  n: u32,\n  dimension: u32,\n  eps: f32,\n  weight_offset: u32,\n  bias_offset: u32,\n  x_offset: u32,\n  y_offset: u32,\n};\n\n@group(0) @binding(0) \nvar<uniform> args: argsStruct;\n\n@group(0) @binding(1)\nvar<storage, read> weight: array<f32>;\n\n@group(0) @binding(2)\nvar<storage, read> bias: array<f32>;\n\n@group(0) @binding(3)\nvar<storage, read> x: array<f32>;\n\n@group(0) @binding(4)\nvar<storage, read_write> y: array<f32>;\n\noverride workgroup_size_x: u32 = 1;\noverride workgroup_size_y: u32 = 1;\noverride workgroup_size_z: u32 = 1;\n\n@compute @workgroup_size(workgroup_size_x, workgroup_size_y, workgroup_size_z)\nfn main(@builtin(global_invocation_id) global_id: vec3<u32>) {\n  if (global_id.x >= args.n) {\n    return;\n  }\n  \n  let x_start: u32 = args.x_offset + (global_id.x * args.dimension);\n\n  var mean: f32 = 0.0;\n  for (var j = 0u; j < args.dimension; j++) {\n      mean += x[x_start + j];\n  }\n  mean /= f32(args.dimension);\n\n  var mean2: f32 = 0.0;\n  for (var j = 0u; j < args.dimension; j++) {\n      mean2 += (x[x_start + j] - mean) * (x[x_start + j] - mean);\n  }\n  mean2 /= f32(args.dimension);\n\n  var norm: f32 = 1.0 / sqrt(mean2 + args.eps);\n\n  var y_start = args.y_offset + (global_id.x * args.dimension);\n  for (var j = 0u; j < args.dimension; j++) {\n    y[y_start + j] = ((x[x_start + j] - mean) * norm * weight[args.weight_offset + j]) + bias[args.bias_offset + j];\n  }\n}\n\n".concat(emptyShader);var loadNormLayerForwardMultiBufferShader=function loadNormLayerForwardMultiBufferShader(device){var bindGroupLayout=device.createBindGroupLayout({label:"norm layer forward multi buffer bind group layout",entries:[{binding:0,visibility:GPUShaderStage.COMPUTE,buffer:{type:"uniform"}},{binding:1,visibility:GPUShaderStage.COMPUTE,buffer:{type:"read-only-storage"}},{binding:2,visibility:GPUShaderStage.COMPUTE,buffer:{type:"read-only-storage"}},{binding:3,visibility:GPUShaderStage.COMPUTE,buffer:{type:"read-only-storage"}},{binding:4,visibility:GPUShaderStage.COMPUTE,buffer:{type:"storage"}}]});var pipelineLayout=device.createPipelineLayout({label:"norm layer forward multi buffer pipeline layout",bindGroupLayouts:[bindGroupLayout]});var shaderModule=device.createShaderModule({label:"norm layer forward multi buffer shader module",code:normLayerForwardMultiBufferShaderSource});var computePipeline=device.createComputePipeline({label:"norm layer forward multi buffer pipeline",layout:pipelineLayout,compute:{module:shaderModule,entryPoint:shaderEntryPoint,constants:{workgroup_size_x:PV_PICOLLM_WEBGPU_DEFAULT_WORKGROUP_SIZE}}});return{computePipeline:computePipeline}};var FORWARD_SINGLE_BUFFER_SHADER_NAME="pv_picollm_norm_layer_forward_single_buffer_shader";var normLayerForwardSingleBufferShaderSource="\nstruct argsStruct {\n  n: u32,\n  dimension: u32,\n  eps: f32,\n  weight_offset: u32,\n  bias_offset: u32,\n  x_offset: u32,\n  y_offset: u32,\n};\n\n@group(0) @binding(0) \nvar<uniform> args: argsStruct;\n\n@group(0) @binding(1)\nvar<storage, read> weight: array<f32>;\n\n@group(0) @binding(2)\nvar<storage, read> bias: array<f32>;\n\n@group(0) @binding(3)\nvar<storage, read_write> y: array<f32>;\n\noverride workgroup_size_x: u32 = 1;\noverride workgroup_size_y: u32 = 1;\noverride workgroup_size_z: u32 = 1;\n\n@compute @workgroup_size(workgroup_size_x, workgroup_size_y, workgroup_size_z)\nfn main(@builtin(global_invocation_id) global_id: vec3<u32>) {\n  if (global_id.x >= args.n) {\n    return;\n  }\n  \n  let x_start: u32 = args.x_offset + (global_id.x * args.dimension);\n\n  var mean: f32 = 0.0;\n  for (var j = 0u; j < args.dimension; j++) {\n      mean += y[x_start + j];\n  }\n  mean /= f32(args.dimension);\n\n  var mean2: f32 = 0.0;\n  for (var j = 0u; j < args.dimension; j++) {\n      mean2 += (y[x_start + j] - mean) * (y[x_start + j] - mean);\n  }\n  mean2 /= f32(args.dimension);\n\n  var norm: f32 = 1.0 / sqrt(mean2 + args.eps);\n\n  var y_start = args.y_offset + (global_id.x * args.dimension);\n  for (var j = 0u; j < args.dimension; j++) {\n    y[y_start + j] = ((y[x_start + j] - mean) * norm * weight[args.weight_offset + j]) + bias[args.bias_offset + j];\n  }\n}\n\n".concat(emptyShader);var loadNormLayerForwardSingleBufferShader=function loadNormLayerForwardSingleBufferShader(device){var bindGroupLayout=device.createBindGroupLayout({label:"norm layer forward single buffer bind group layout",entries:[{binding:0,visibility:GPUShaderStage.COMPUTE,buffer:{type:"uniform"}},{binding:1,visibility:GPUShaderStage.COMPUTE,buffer:{type:"read-only-storage"}},{binding:2,visibility:GPUShaderStage.COMPUTE,buffer:{type:"read-only-storage"}},{binding:3,visibility:GPUShaderStage.COMPUTE,buffer:{type:"storage"}}]});var pipelineLayout=device.createPipelineLayout({label:"norm layer forward single buffer pipeline layout",bindGroupLayouts:[bindGroupLayout]});var shaderModule=device.createShaderModule({label:"norm layer forward single buffer shader module",code:normLayerForwardSingleBufferShaderSource});var computePipeline=device.createComputePipeline({label:"norm layer forward single buffer pipeline",layout:pipelineLayout,compute:{module:shaderModule,entryPoint:shaderEntryPoint,constants:{workgroup_size_x:PV_PICOLLM_WEBGPU_DEFAULT_WORKGROUP_SIZE}}});return{computePipeline:computePipeline}};var normLayerForwardShader=_defineProperty(_defineProperty({},FORWARD_SINGLE_BUFFER_SHADER_NAME,loadNormLayerForwardSingleBufferShader),FORWARD_MULTI_BUFFER_SHADER_NAME,loadNormLayerForwardMultiBufferShader);var ADD_TO_BUFFER_SHADER_NAME="pv_picollm_transformer_add_to_buffer_shader";var transformerAddToBufferShaderSource="\nstruct argsStruct {\n  n: u32,\n  x_offset: u32,\n  buffer_offset: u32,  \n};\n\n@group(0) @binding(0) \nvar<uniform> args: argsStruct;\n\n@group(0) @binding(1)\nvar<storage, read> x: array<f32>;\n\n@group(0) @binding(2)\nvar<storage, read_write> buffer: array<f32>;\n\noverride workgroup_size_x: u32 = 1;\noverride workgroup_size_y: u32 = 1;\noverride workgroup_size_z: u32 = 1;\n\n@compute @workgroup_size(workgroup_size_x, workgroup_size_y, workgroup_size_z)\nfn main(@builtin(global_invocation_id) global_id: vec3<u32>) {\n  if (global_id.x >= args.n) {\n    return;\n  }\n    \n  buffer[args.buffer_offset + global_id.x] += x[args.x_offset + global_id.x];  \n}\n\n".concat(emptyShader);var loadTransformerAddToBufferShader=function loadTransformerAddToBufferShader(device){var bindGroupLayout=device.createBindGroupLayout({label:"transformer add to buffer bind group layout",entries:[{binding:0,visibility:GPUShaderStage.COMPUTE,buffer:{type:"uniform"}},{binding:1,visibility:GPUShaderStage.COMPUTE,buffer:{type:"read-only-storage"}},{binding:2,visibility:GPUShaderStage.COMPUTE,buffer:{type:"storage"}}]});var pipelineLayout=device.createPipelineLayout({label:"transformer add to buffer pipeline layout",bindGroupLayouts:[bindGroupLayout]});var shaderModule=device.createShaderModule({label:"transformer add to buffer shader module",code:transformerAddToBufferShaderSource});var computePipeline=device.createComputePipeline({label:"transformer add to buffer compute",layout:pipelineLayout,compute:{module:shaderModule,entryPoint:shaderEntryPoint,constants:{workgroup_size_x:PV_PICOLLM_WEBGPU_DEFAULT_WORKGROUP_SIZE}}});return{computePipeline:computePipeline}};var ADD_BUFFERS_SHADER_NAME="pv_picollm_transformer_add_buffers_shader";var transformerAddBuffersShaderSource="\n\nstruct argsStruct {\n  n: u32,\n  buffer1_offset: u32,\n  buffer2_offset: u32,\n  y_offset: u32,  \n};\n\n@group(0) @binding(0) \nvar<uniform> args: argsStruct;\n\n@group(0) @binding(1)\nvar<storage, read> buffer1: array<f32>;\n\n@group(0) @binding(2)\nvar<storage, read> buffer2: array<f32>;\n\n@group(0) @binding(3)\nvar<storage, read_write> y: array<f32>;\n\noverride workgroup_size_x: u32 = 1;\noverride workgroup_size_y: u32 = 1;\noverride workgroup_size_z: u32 = 1;\n\n@compute @workgroup_size(workgroup_size_x, workgroup_size_y, workgroup_size_z)\nfn main(@builtin(global_invocation_id) global_id: vec3<u32>) {\n  if (global_id.x >= args.n) {\n    return;\n  }\n    \n  y[args.y_offset + global_id.x] = buffer1[args.buffer1_offset + global_id.x] + buffer2[args.buffer2_offset + global_id.x];   \n}\n\n".concat(emptyShader);var loadTransformerAddBuffersShader=function loadTransformerAddBuffersShader(device){var bindGroupLayout=device.createBindGroupLayout({label:"transformer add buffers bind group layout",entries:[{binding:0,visibility:GPUShaderStage.COMPUTE,buffer:{type:"uniform"}},{binding:1,visibility:GPUShaderStage.COMPUTE,buffer:{type:"read-only-storage"}},{binding:2,visibility:GPUShaderStage.COMPUTE,buffer:{type:"read-only-storage"}},{binding:3,visibility:GPUShaderStage.COMPUTE,buffer:{type:"storage"}}]});var pipelineLayout=device.createPipelineLayout({label:"transformer add buffers pipeline layout",bindGroupLayouts:[bindGroupLayout]});var shaderModule=device.createShaderModule({label:"transformer add buffers shader module",code:transformerAddBuffersShaderSource});var computePipeline=device.createComputePipeline({label:"transformer add buffers pipeline",layout:pipelineLayout,compute:{module:shaderModule,entryPoint:shaderEntryPoint,constants:{workgroup_size_x:PV_PICOLLM_WEBGPU_DEFAULT_WORKGROUP_SIZE}}});return{computePipeline:computePipeline}};var transformerForwardShaders=_defineProperty(_defineProperty({},ADD_TO_BUFFER_SHADER_NAME,loadTransformerAddToBufferShader),ADD_BUFFERS_SHADER_NAME,loadTransformerAddBuffersShader);var FORWARD_SHADER_NAME="pv_picollm_weight_float_forward_shader";var weightFloatForwardShaderSource="\n\nstruct argsStruct {\n  nr: u32,\n  nc: u32,\n  w_offset: u32,\n  x_offset: u32,\n  y_offset: u32,\n};\n\n@group(0) @binding(0) \nvar<uniform> args: argsStruct;\n\n@group(0) @binding(1)\nvar<storage, read> w: array<f32>;\n\n@group(0) @binding(2)\nvar<storage, read> x: array<f32>;\n\n@group(0) @binding(3)\nvar<storage, read_write> y: array<f32>;\n\noverride workgroup_size_x: u32 = 1;\noverride workgroup_size_y: u32 = 1;\noverride workgroup_size_z: u32 = 1;\n\n@compute @workgroup_size(workgroup_size_x, workgroup_size_y, workgroup_size_z)\nfn main(\n  @builtin(workgroup_id) workgroup_id : vec3<u32>,\n  @builtin(local_invocation_id) local_id : vec3<u32>\n) {\n  if (local_id.x >= args.nr) {\n    return;\n  }\n  let x_start: u32 = args.x_offset + (workgroup_id.x * args.nc);\n  let y_idx: u32 = local_id.x + args.y_offset + (workgroup_id.x * args.nr);\n  \n  let w_start: u32 = args.w_offset + (local_id.x * args.nc);\n  for (var j = 0u; j < args.nc; j++) {\n    y[y_idx] += w[w_start + j] * x[x_start + j]; \n  }\n}\n\n".concat(emptyShader);var loadWeightFloatForwardShader=function loadWeightFloatForwardShader(device){var bindGroupLayout=device.createBindGroupLayout({label:"weight float forward bind group layout",entries:[{binding:0,visibility:GPUShaderStage.COMPUTE,buffer:{type:"uniform"}},{binding:1,visibility:GPUShaderStage.COMPUTE,buffer:{type:"read-only-storage"}},{binding:2,visibility:GPUShaderStage.COMPUTE,buffer:{type:"read-only-storage"}},{binding:3,visibility:GPUShaderStage.COMPUTE,buffer:{type:"storage"}}]});var pipelineLayout=device.createPipelineLayout({label:"weight float forward pipeline layout",bindGroupLayouts:[bindGroupLayout]});var shaderModule=device.createShaderModule({label:"weight float forward shader module",code:weightFloatForwardShaderSource});var computePipeline=device.createComputePipeline({label:"weight float forward pipeline",layout:pipelineLayout,compute:{module:shaderModule,entryPoint:shaderEntryPoint,constants:{workgroup_size_x:PV_PICOLLM_WEBGPU_DEFAULT_WORKGROUP_SIZE}}});return{computePipeline:computePipeline}};var weightFloatForwardShader=_defineProperty({},FORWARD_SHADER_NAME,loadWeightFloatForwardShader);var rowsPerBlock=16;var columnsPerBlock=8;var preprocessDim=16;var weightBlockSize=256;var unpackBlock128BitDepth3="\nvar<private> unpacked: array<u32, 128>;\n\nfn unpack_block_128_bit_depth_3(packed_offset: u32) {\n  let val_0 = blocks[packed_offset]; \n  unpacked[0] = extractBits(val_0, 0u, 3u);\n  unpacked[1] = extractBits(val_0, 3u, 3u);\n  unpacked[2] = extractBits(val_0, 6u, 3u);\n  unpacked[3] = extractBits(val_0, 9u, 3u);\n  unpacked[4] = extractBits(val_0, 12u, 3u);\n  unpacked[5] = extractBits(val_0, 15u, 3u);\n  unpacked[6] = extractBits(val_0, 18u, 3u);\n  unpacked[7] = extractBits(val_0, 21u, 3u);\n  unpacked[8] = extractBits(val_0, 24u, 3u);\n  unpacked[9] = extractBits(val_0, 27u, 3u);\n  unpacked[10] = extractBits(val_0, 30u, 2u);\n  \n  let val_1 = blocks[packed_offset + 1];\n  unpacked[10] = insertBits(unpacked[10], extractBits(val_1, 0u, 1u), 2u, 1u);\n  unpacked[11] = extractBits(val_1, 1u, 3u);\n  unpacked[12] = extractBits(val_1, 4u, 3u);\n  unpacked[13] = extractBits(val_1, 7u, 3u);\n  unpacked[14] = extractBits(val_1, 10u, 3u);\n  unpacked[15] = extractBits(val_1, 13u, 3u);\n  unpacked[16] = extractBits(val_1, 16u, 3u);\n  unpacked[17] = extractBits(val_1, 19u, 3u);\n  unpacked[18] = extractBits(val_1, 22u, 3u);\n  unpacked[19] = extractBits(val_1, 25u, 3u);\n  unpacked[20] = extractBits(val_1, 28u, 3u);\n  unpacked[21] = extractBits(val_1, 31u, 1u);\n  \n  let val_2 = blocks[packed_offset + 2];\n  unpacked[21] = insertBits(unpacked[21], extractBits(val_2, 0u, 2u), 1u, 2u); \n  unpacked[22] = extractBits(val_2, 2u, 3u);\n  unpacked[23] = extractBits(val_2, 5u, 3u);\n  unpacked[24] = extractBits(val_2, 8u, 3u);\n  unpacked[25] = extractBits(val_2, 11u, 3u);\n  unpacked[26] = extractBits(val_2, 14u, 3u);\n  unpacked[27] = extractBits(val_2, 17u, 3u);\n  unpacked[28] = extractBits(val_2, 20u, 3u);\n  unpacked[29] = extractBits(val_2, 23u, 3u);\n  unpacked[30] = extractBits(val_2, 26u, 3u);\n  unpacked[31] = extractBits(val_2, 29u, 3u);\n  \n  let val_3 = blocks[packed_offset + 3]; \n  unpacked[32] = extractBits(val_3, 0u, 3u);\n  unpacked[33] = extractBits(val_3, 3u, 3u);\n  unpacked[34] = extractBits(val_3, 6u, 3u);\n  unpacked[35] = extractBits(val_3, 9u, 3u);\n  unpacked[36] = extractBits(val_3, 12u, 3u);\n  unpacked[37] = extractBits(val_3, 15u, 3u);\n  unpacked[38] = extractBits(val_3, 18u, 3u);\n  unpacked[39] = extractBits(val_3, 21u, 3u);\n  unpacked[40] = extractBits(val_3, 24u, 3u);\n  unpacked[41] = extractBits(val_3, 27u, 3u);\n  unpacked[42] = extractBits(val_3, 30u, 2u);\n  \n  let val_4 = blocks[packed_offset + 4];\n  unpacked[42] = insertBits(unpacked[42], extractBits(val_4, 0u, 1u), 2u, 1u);\n  unpacked[43] = extractBits(val_4, 1u, 3u);\n  unpacked[44] = extractBits(val_4, 4u, 3u);\n  unpacked[45] = extractBits(val_4, 7u, 3u);\n  unpacked[46] = extractBits(val_4, 10u, 3u);\n  unpacked[47] = extractBits(val_4, 13u, 3u);\n  unpacked[48] = extractBits(val_4, 16u, 3u);\n  unpacked[49] = extractBits(val_4, 19u, 3u);\n  unpacked[50] = extractBits(val_4, 22u, 3u);\n  unpacked[51] = extractBits(val_4, 25u, 3u);\n  unpacked[52] = extractBits(val_4, 28u, 3u);\n  unpacked[53] = extractBits(val_4, 31u, 1u);\n  \n  let val_5 = blocks[packed_offset + 5];\n  unpacked[53] = insertBits(unpacked[53], extractBits(val_5, 0u, 2u), 1u, 2u); \n  unpacked[54] = extractBits(val_5, 2u, 3u);\n  unpacked[55] = extractBits(val_5, 5u, 3u);\n  unpacked[56] = extractBits(val_5, 8u, 3u);\n  unpacked[57] = extractBits(val_5, 11u, 3u);\n  unpacked[58] = extractBits(val_5, 14u, 3u);\n  unpacked[59] = extractBits(val_5, 17u, 3u);\n  unpacked[60] = extractBits(val_5, 20u, 3u);\n  unpacked[61] = extractBits(val_5, 23u, 3u);\n  unpacked[62] = extractBits(val_5, 26u, 3u);\n  unpacked[63] = extractBits(val_5, 29u, 3u);\n  \n  let val_6 = blocks[packed_offset + 6];\n  unpacked[64] = extractBits(val_6, 0u, 3u);\n  unpacked[65] = extractBits(val_6, 3u, 3u);\n  unpacked[66] = extractBits(val_6, 6u, 3u);\n  unpacked[67] = extractBits(val_6, 9u, 3u);\n  unpacked[68] = extractBits(val_6, 12u, 3u);\n  unpacked[69] = extractBits(val_6, 15u, 3u);\n  unpacked[70] = extractBits(val_6, 18u, 3u);\n  unpacked[71] = extractBits(val_6, 21u, 3u);\n  unpacked[72] = extractBits(val_6, 24u, 3u);\n  unpacked[73] = extractBits(val_6, 27u, 3u);\n  unpacked[74] = extractBits(val_6, 30u, 2u);\n  \n  let val_7 = blocks[packed_offset + 7];\n  unpacked[74] = insertBits(unpacked[74], extractBits(val_7, 0u, 1u), 2u, 1u);\n  unpacked[75] = extractBits(val_7, 1u, 3u);\n  unpacked[76] = extractBits(val_7, 4u, 3u);\n  unpacked[77] = extractBits(val_7, 7u, 3u);\n  unpacked[78] = extractBits(val_7, 10u, 3u);\n  unpacked[79] = extractBits(val_7, 13u, 3u);\n  unpacked[80] = extractBits(val_7, 16u, 3u);\n  unpacked[81] = extractBits(val_7, 19u, 3u);\n  unpacked[82] = extractBits(val_7, 22u, 3u);\n  unpacked[83] = extractBits(val_7, 25u, 3u);\n  unpacked[84] = extractBits(val_7, 28u, 3u);\n  unpacked[85] = extractBits(val_7, 31u, 1u);\n  \n  let val_8 = blocks[packed_offset + 8];\n  unpacked[85] = insertBits(unpacked[85], extractBits(val_8, 0u, 2u), 1u, 2u); \n  unpacked[86] = extractBits(val_8, 2u, 3u);\n  unpacked[87] = extractBits(val_8, 5u, 3u);\n  unpacked[88] = extractBits(val_8, 8u, 3u);\n  unpacked[89] = extractBits(val_8, 11u, 3u);\n  unpacked[90] = extractBits(val_8, 14u, 3u);\n  unpacked[91] = extractBits(val_8, 17u, 3u);\n  unpacked[92] = extractBits(val_8, 20u, 3u);\n  unpacked[93] = extractBits(val_8, 23u, 3u);\n  unpacked[94] = extractBits(val_8, 26u, 3u);\n  unpacked[95] = extractBits(val_8, 29u, 3u);\n  \n  let val_9 = blocks[packed_offset + 9];\n  unpacked[96] = extractBits(val_9, 0u, 3u);\n  unpacked[97] = extractBits(val_9, 3u, 3u);\n  unpacked[98] = extractBits(val_9, 6u, 3u);\n  unpacked[99] = extractBits(val_9, 9u, 3u);\n  unpacked[100] = extractBits(val_9, 12u, 3u);\n  unpacked[101] = extractBits(val_9, 15u, 3u);\n  unpacked[102] = extractBits(val_9, 18u, 3u);\n  unpacked[103] = extractBits(val_9, 21u, 3u);\n  unpacked[104] = extractBits(val_9, 24u, 3u);\n  unpacked[105] = extractBits(val_9, 27u, 3u);\n  unpacked[106] = extractBits(val_9, 30u, 2u);\n  \n  let val_10 = blocks[packed_offset + 10];\n  unpacked[106] = insertBits(unpacked[106], extractBits(val_10, 0u, 1u), 2u, 1u);\n  unpacked[107] = extractBits(val_10, 1u, 3u);\n  unpacked[108] = extractBits(val_10, 4u, 3u);\n  unpacked[109] = extractBits(val_10, 7u, 3u);\n  unpacked[110] = extractBits(val_10, 10u, 3u);\n  unpacked[111] = extractBits(val_10, 13u, 3u);\n  unpacked[112] = extractBits(val_10, 16u, 3u);\n  unpacked[113] = extractBits(val_10, 19u, 3u);\n  unpacked[114] = extractBits(val_10, 22u, 3u);\n  unpacked[115] = extractBits(val_10, 25u, 3u);\n  unpacked[116] = extractBits(val_10, 28u, 3u);\n  unpacked[117] = extractBits(val_10, 31u, 1u);\n  \n  let val_11 = blocks[packed_offset + 11];\n  unpacked[117] = insertBits(unpacked[117], extractBits(val_11, 0u, 2u), 1u, 2u); \n  unpacked[118] = extractBits(val_11, 2u, 3u);\n  unpacked[119] = extractBits(val_11, 5u, 3u);\n  unpacked[120] = extractBits(val_11, 8u, 3u);\n  unpacked[121] = extractBits(val_11, 11u, 3u);\n  unpacked[122] = extractBits(val_11, 14u, 3u);\n  unpacked[123] = extractBits(val_11, 17u, 3u);\n  unpacked[124] = extractBits(val_11, 20u, 3u);\n  unpacked[125] = extractBits(val_11, 23u, 3u);\n  unpacked[126] = extractBits(val_11, 26u, 3u);\n  unpacked[127] = extractBits(val_11, 29u, 3u);\n}\n";var unpackBlock128BitDepth5="\nvar<private> unpacked: array<u32, 128>;\n\nfn unpack_block_128_bit_depth_5(packed_offset: u32) {    \n  let val_0 = blocks[packed_offset];\n  unpacked[0] = extractBits(val_0, 0u, 5u);\n  unpacked[1] = extractBits(val_0, 5u, 5u);\n  unpacked[2] = extractBits(val_0, 10u, 5u);\n  unpacked[3] = extractBits(val_0, 15u, 5u);\n  unpacked[4] = extractBits(val_0, 20u, 5u);\n  unpacked[5] = extractBits(val_0, 25u, 5u);\n  unpacked[6] = extractBits(val_0, 30u, 2u);\n  \n  let val_1 = blocks[packed_offset + 1];\n  unpacked[6] = insertBits(unpacked[6], extractBits(val_1, 0u, 3u), 2u, 3u);    \n  unpacked[7] = extractBits(val_1, 3u, 5u);\n  unpacked[8] = extractBits(val_1, 8u, 5u);\n  unpacked[9] = extractBits(val_1, 13u, 5u);\n  unpacked[10] = extractBits(val_1, 18u, 5u);\n  unpacked[11] = extractBits(val_1, 23u, 5u);\n  unpacked[12] = extractBits(val_1, 28u, 4u);\n  \n  let val_2 = blocks[packed_offset + 2];\n  unpacked[12] = insertBits(unpacked[12], extractBits(val_2, 0u, 1u), 4u, 1u);\n  unpacked[13] = extractBits(val_2, 1u, 5u);\n  unpacked[14] = extractBits(val_2, 6u, 5u);\n  unpacked[15] = extractBits(val_2, 11u, 5u);\n  unpacked[16] = extractBits(val_2, 16u, 5u);\n  unpacked[17] = extractBits(val_2, 21u, 5u);\n  unpacked[18] = extractBits(val_2, 26u, 5u);\n  unpacked[19] = extractBits(val_2, 31u, 1u);\n  \n  let val_3 = blocks[packed_offset + 3];\n  unpacked[19] = insertBits(unpacked[19], extractBits(val_3, 0u, 4u), 1u, 4u);\n  unpacked[20] = extractBits(val_3, 4u, 5u);\n  unpacked[21] = extractBits(val_3, 9u, 5u);\n  unpacked[22] = extractBits(val_3, 14u, 5u);\n  unpacked[23] = extractBits(val_3, 19u, 5u);\n  unpacked[24] = extractBits(val_3, 24u, 5u);\n  unpacked[25] = extractBits(val_3, 29u, 3u);\n  \n  let val_4 = blocks[packed_offset + 4];\n  unpacked[25] = insertBits(unpacked[25], extractBits(val_4, 0u, 2u), 3u, 2u);\n  unpacked[26] = extractBits(val_4, 2u, 5u);\n  unpacked[27] = extractBits(val_4, 7u, 5u);\n  unpacked[28] = extractBits(val_4, 12u, 5u);\n  unpacked[29] = extractBits(val_4, 17u, 5u);\n  unpacked[30] = extractBits(val_4, 22u, 5u);\n  unpacked[31] = extractBits(val_4, 27u, 5u);\n  \n  let val_5 = blocks[packed_offset + 5];\n  unpacked[32] = extractBits(val_5, 0u, 5u);\n  unpacked[33] = extractBits(val_5, 5u, 5u);\n  unpacked[34] = extractBits(val_5, 10u, 5u);\n  unpacked[35] = extractBits(val_5, 15u, 5u);\n  unpacked[36] = extractBits(val_5, 20u, 5u);\n  unpacked[37] = extractBits(val_5, 25u, 5u);\n  unpacked[38] = extractBits(val_5, 30u, 2u);\n\n  let val_6 = blocks[packed_offset + 6];\n  unpacked[38] = insertBits(unpacked[38], extractBits(val_6, 0u, 3u), 2u, 3u);\n  unpacked[39] = extractBits(val_6, 3u, 5u);\n  unpacked[40] = extractBits(val_6, 8u, 5u);\n  unpacked[41] = extractBits(val_6, 13u, 5u);\n  unpacked[42] = extractBits(val_6, 18u, 5u);\n  unpacked[43] = extractBits(val_6, 23u, 5u);\n  unpacked[44] = extractBits(val_6, 28u, 4u);\n\n  let val_7 = blocks[packed_offset + 7];\n  unpacked[44] = insertBits(unpacked[44], extractBits(val_7, 0u, 1u), 4u, 1u);\n  unpacked[45] = extractBits(val_7, 1u, 5u);\n  unpacked[46] = extractBits(val_7, 6u, 5u);\n  unpacked[47] = extractBits(val_7, 11u, 5u);\n  unpacked[48] = extractBits(val_7, 16u, 5u);\n  unpacked[49] = extractBits(val_7, 21u, 5u);\n  unpacked[50] = extractBits(val_7, 26u, 5u);\n  unpacked[51] = extractBits(val_7, 31u, 1u);\n\n  let val_8 = blocks[packed_offset + 8];\n  unpacked[51] = insertBits(unpacked[51], extractBits(val_8, 0u, 4u), 1u, 4u);\n  unpacked[52] = extractBits(val_8, 4u, 5u);\n  unpacked[53] = extractBits(val_8, 9u, 5u);\n  unpacked[54] = extractBits(val_8, 14u, 5u);\n  unpacked[55] = extractBits(val_8, 19u, 5u);\n  unpacked[56] = extractBits(val_8, 24u, 5u);\n  unpacked[57] = extractBits(val_8, 29u, 3u);\n  \n  let val_9 = blocks[packed_offset + 9];\n  unpacked[57] = insertBits(unpacked[57], extractBits(val_9, 0u, 2u), 3u, 2u);\n  unpacked[58] = extractBits(val_9, 2u, 5u);\n  unpacked[59] = extractBits(val_9, 7u, 5u);\n  unpacked[60] = extractBits(val_9, 12u, 5u);\n  unpacked[61] = extractBits(val_9, 17u, 5u);\n  unpacked[62] = extractBits(val_9, 22u, 5u);\n  unpacked[63] = extractBits(val_9, 27u, 5u);\n  \n  let val_10 = blocks[packed_offset + 10];\n  unpacked[64] = extractBits(val_10, 0u, 5u);\n  unpacked[65] = extractBits(val_10, 5u, 5u);\n  unpacked[66] = extractBits(val_10, 10u, 5u);\n  unpacked[67] = extractBits(val_10, 15u, 5u);\n  unpacked[68] = extractBits(val_10, 20u, 5u);\n  unpacked[69] = extractBits(val_10, 25u, 5u);\n  unpacked[70] = extractBits(val_10, 30u, 2u);\n\n  let val_11 = blocks[packed_offset + 11];\n  unpacked[70] = insertBits(unpacked[70], extractBits(val_11, 0u, 3u), 2u, 3u);\n  unpacked[71] = extractBits(val_11, 3u, 5u);\n  unpacked[72] = extractBits(val_11, 8u, 5u);\n  unpacked[73] = extractBits(val_11, 13u, 5u);\n  unpacked[74] = extractBits(val_11, 18u, 5u);\n  unpacked[75] = extractBits(val_11, 23u, 5u);\n  unpacked[76] = extractBits(val_11, 28u, 4u);\n\n  let val_12 = blocks[packed_offset + 12];\n  unpacked[76] = insertBits(unpacked[76], extractBits(val_12, 0u, 1u), 4u, 1u);\n  unpacked[77] = extractBits(val_12, 1u, 5u);\n  unpacked[78] = extractBits(val_12, 6u, 5u);\n  unpacked[79] = extractBits(val_12, 11u, 5u);\n  unpacked[80] = extractBits(val_12, 16u, 5u);\n  unpacked[81] = extractBits(val_12, 21u, 5u);\n  unpacked[82] = extractBits(val_12, 26u, 5u);\n  unpacked[83] = extractBits(val_12, 31u, 1u);\n\n  let val_13 = blocks[packed_offset + 13];\n  unpacked[83] = insertBits(unpacked[83], extractBits(val_13, 0u, 4u), 1u, 4u);\n  unpacked[84] = extractBits(val_13, 4u, 5u);\n  unpacked[85] = extractBits(val_13, 9u, 5u);\n  unpacked[86] = extractBits(val_13, 14u, 5u);\n  unpacked[87] = extractBits(val_13, 19u, 5u);\n  unpacked[88] = extractBits(val_13, 24u, 5u);\n  unpacked[89] = extractBits(val_13, 29u, 3u);\n  \n  let val_14 = blocks[packed_offset + 14];\n  unpacked[89] = insertBits(unpacked[89], extractBits(val_14, 0u, 2u), 3u, 2u);\n  unpacked[90] = extractBits(val_14, 2u, 5u);\n  unpacked[91] = extractBits(val_14, 7u, 5u);\n  unpacked[92] = extractBits(val_14, 12u, 5u);\n  unpacked[93] = extractBits(val_14, 17u, 5u);\n  unpacked[94] = extractBits(val_14, 22u, 5u);\n  unpacked[95] = extractBits(val_14, 27u, 5u);\n\n  let val_15 = blocks[packed_offset + 15];\n  unpacked[96] = extractBits(val_15, 0u, 5u);\n  unpacked[97] = extractBits(val_15, 5u, 5u);\n  unpacked[98] = extractBits(val_15, 10u, 5u);\n  unpacked[99] = extractBits(val_15, 15u, 5u);\n  unpacked[100] = extractBits(val_15, 20u, 5u);\n  unpacked[101] = extractBits(val_15, 25u, 5u);\n  unpacked[102] = extractBits(val_15, 30u, 2u);\n\n  let val_16 = blocks[packed_offset + 16];\n  unpacked[102] = insertBits(unpacked[102], extractBits(val_16, 0u, 3u), 2u, 3u);\n  unpacked[103] = extractBits(val_16, 3u, 5u);\n  unpacked[104] = extractBits(val_16, 8u, 5u);\n  unpacked[105] = extractBits(val_16, 13u, 5u);\n  unpacked[106] = extractBits(val_16, 18u, 5u);\n  unpacked[107] = extractBits(val_16, 23u, 5u);\n  unpacked[108] = extractBits(val_16, 28u, 4u);\n\n  let val_17 = blocks[packed_offset + 17];\n  unpacked[108] = insertBits(unpacked[108], extractBits(val_17, 0u, 1u), 4u, 1u);\n  unpacked[109] = extractBits(val_17, 1u, 5u);\n  unpacked[110] = extractBits(val_17, 6u, 5u);\n  unpacked[111] = extractBits(val_17, 11u, 5u);\n  unpacked[112] = extractBits(val_17, 16u, 5u);\n  unpacked[113] = extractBits(val_17, 21u, 5u);\n  unpacked[114] = extractBits(val_17, 26u, 5u);\n  unpacked[115] = extractBits(val_17, 31u, 1u);\n  \n  let val_18 = blocks[packed_offset + 18];\n  unpacked[115] = insertBits(unpacked[115], extractBits(val_18, 0u, 4u), 1u, 4u);\n  unpacked[116] = extractBits(val_18, 4u, 5u);\n  unpacked[117] = extractBits(val_18, 9u, 5u);\n  unpacked[118] = extractBits(val_18, 14u, 5u);\n  unpacked[119] = extractBits(val_18, 19u, 5u);\n  unpacked[120] = extractBits(val_18, 24u, 5u);\n  unpacked[121] = extractBits(val_18, 29u, 3u);\n\n  let val_19 = blocks[packed_offset + 19];\n  unpacked[121] = insertBits(unpacked[121], extractBits(val_19, 0u, 2u), 3u, 2u);\n  unpacked[122] = extractBits(val_19, 2u, 5u);\n  unpacked[123] = extractBits(val_19, 7u, 5u);\n  unpacked[124] = extractBits(val_19, 12u, 5u);\n  unpacked[125] = extractBits(val_19, 17u, 5u);\n  unpacked[126] = extractBits(val_19, 22u, 5u);\n  unpacked[127] = extractBits(val_19, 27u, 5u);\n}\n";var unpackBlock128BitDepth6="\nvar<private> unpacked: array<u32, 128>;\n\nfn unpack_block_128_bit_depth_6(packed_offset: u32) {\n  let val_0 = blocks[packed_offset];\n  unpacked[0] = extractBits(val_0, 0u, 6u);\n  unpacked[1] = extractBits(val_0, 6u, 6u);\n  unpacked[2] = extractBits(val_0, 12u, 6u);\n  unpacked[3] = extractBits(val_0, 18u, 6u);\n  unpacked[4] = extractBits(val_0, 24u, 6u);\n  unpacked[5] = extractBits(val_0, 30u, 2u);\n  \n  let val_1 = blocks[packed_offset + 1];\n  unpacked[5] = insertBits(unpacked[5], extractBits(val_1, 0u, 4u), 2u, 4u);\n  unpacked[6] = extractBits(val_1, 4u, 6u);\n  unpacked[7] = extractBits(val_1, 10u, 6u);\n  unpacked[8] = extractBits(val_1, 16u, 6u);\n  unpacked[9] = extractBits(val_1, 22u, 6u);\n  unpacked[10] = extractBits(val_1, 28u, 4u);\n  \n  let val_2 = blocks[packed_offset + 2];\n  unpacked[10] = insertBits(unpacked[10], extractBits(val_2, 0u, 2u), 4u, 2u);\n  unpacked[11] = extractBits(val_2, 2u, 6u);\n  unpacked[12] = extractBits(val_2, 8u, 6u);\n  unpacked[13] = extractBits(val_2, 14u, 6u);\n  unpacked[14] = extractBits(val_2, 20u, 6u);\n  unpacked[15] = extractBits(val_2, 26u, 6u);\n  \n  let val_3 = blocks[packed_offset + 3];\n  unpacked[16] = extractBits(val_3, 0u, 6u);\n  unpacked[17] = extractBits(val_3, 6u, 6u);\n  unpacked[18] = extractBits(val_3, 12u, 6u);\n  unpacked[19] = extractBits(val_3, 18u, 6u);\n  unpacked[20] = extractBits(val_3, 24u, 6u);\n  unpacked[21] = extractBits(val_3, 30u, 2u);\n  \n  let val_4 = blocks[packed_offset + 4];\n  unpacked[21] = insertBits(unpacked[21], extractBits(val_4, 0u, 4u), 2u, 4u);\n  unpacked[22] = extractBits(val_4, 4u, 6u);\n  unpacked[23] = extractBits(val_4, 10u, 6u);\n  unpacked[24] = extractBits(val_4, 16u, 6u);\n  unpacked[25] = extractBits(val_4, 22u, 6u);\n  unpacked[26] = extractBits(val_4, 28u, 4u);\n\n  let val_5 = blocks[packed_offset + 5];\n  unpacked[26] = insertBits(unpacked[26], extractBits(val_5, 0u, 2u), 4u, 2u);\n  unpacked[27] = extractBits(val_5, 2u, 6u);\n  unpacked[28] = extractBits(val_5, 8u, 6u);\n  unpacked[29] = extractBits(val_5, 14u, 6u);\n  unpacked[30] = extractBits(val_5, 20u, 6u);\n  unpacked[31] = extractBits(val_5, 26u, 6u);\n\n  let val_6 = blocks[packed_offset + 6];\n  unpacked[32] = extractBits(val_6, 0u, 6u);\n  unpacked[33] = extractBits(val_6, 6u, 6u);\n  unpacked[34] = extractBits(val_6, 12u, 6u);\n  unpacked[35] = extractBits(val_6, 18u, 6u);\n  unpacked[36] = extractBits(val_6, 24u, 6u);\n  unpacked[37] = extractBits(val_6, 30u, 2u);\n\n  let val_7 = blocks[packed_offset + 7];\n  unpacked[37] = insertBits(unpacked[37], extractBits(val_7, 0u, 4u), 2u, 4u);\n  unpacked[38] = extractBits(val_7, 4u, 6u);\n  unpacked[39] = extractBits(val_7, 10u, 6u);\n  unpacked[40] = extractBits(val_7, 16u, 6u);\n  unpacked[41] = extractBits(val_7, 22u, 6u);\n  unpacked[42] = extractBits(val_7, 28u, 4u);\n  \n  let val_8 = blocks[packed_offset + 8];\n  unpacked[42] = insertBits(unpacked[42], extractBits(val_8, 0u, 2u), 4u, 2u);\n  unpacked[43] = extractBits(val_8, 2u, 6u);\n  unpacked[44] = extractBits(val_8, 8u, 6u);\n  unpacked[45] = extractBits(val_8, 14u, 6u);\n  unpacked[46] = extractBits(val_8, 20u, 6u);\n  unpacked[47] = extractBits(val_8, 26u, 6u);\n\n  let val_9 = blocks[packed_offset + 9];\n  unpacked[48] = extractBits(val_9, 0u, 6u);\n  unpacked[49] = extractBits(val_9, 6u, 6u);\n  unpacked[50] = extractBits(val_9, 12u, 6u);\n  unpacked[51] = extractBits(val_9, 18u, 6u);\n  unpacked[52] = extractBits(val_9, 24u, 6u);\n  unpacked[53] = extractBits(val_9, 30u, 2u);\n\n  let val_10 = blocks[packed_offset + 10];\n  unpacked[53] = insertBits(unpacked[53], extractBits(val_10, 0u, 4u), 2u, 4u);\n  unpacked[54] = extractBits(val_10, 4u, 6u);\n  unpacked[55] = extractBits(val_10, 10u, 6u);\n  unpacked[56] = extractBits(val_10, 16u, 6u);\n  unpacked[57] = extractBits(val_10, 22u, 6u);\n  unpacked[58] = extractBits(val_10, 28u, 4u);\n\n  let val_11 = blocks[packed_offset + 11];\n  unpacked[58] = insertBits(unpacked[58], extractBits(val_11, 0u, 2u), 4u, 2u);\n  unpacked[59] = extractBits(val_11, 2u, 6u);\n  unpacked[60] = extractBits(val_11, 8u, 6u);\n  unpacked[61] = extractBits(val_11, 14u, 6u);\n  unpacked[62] = extractBits(val_11, 20u, 6u);\n  unpacked[63] = extractBits(val_11, 26u, 6u);\n  \n  let val_12 = blocks[packed_offset + 12];\n  unpacked[64] = extractBits(val_12, 0u, 6u);\n  unpacked[65] = extractBits(val_12, 6u, 6u);\n  unpacked[66] = extractBits(val_12, 12u, 6u);\n  unpacked[67] = extractBits(val_12, 18u, 6u);\n  unpacked[68] = extractBits(val_12, 24u, 6u);\n  unpacked[69] = extractBits(val_12, 30u, 2u);\n\n  let val_13 = blocks[packed_offset + 13];\n  unpacked[69] = insertBits(unpacked[69], extractBits(val_13, 0u, 4u), 2u, 4u);\n  unpacked[70] = extractBits(val_13, 4u, 6u);\n  unpacked[71] = extractBits(val_13, 10u, 6u);\n  unpacked[72] = extractBits(val_13, 16u, 6u);\n  unpacked[73] = extractBits(val_13, 22u, 6u);\n  unpacked[74] = extractBits(val_13, 28u, 4u);\n\n  let val_14 = blocks[packed_offset + 14];\n  unpacked[74] = insertBits(unpacked[74], extractBits(val_14, 0u, 2u), 4u, 2u);\n  unpacked[75] = extractBits(val_14, 2u, 6u);\n  unpacked[76] = extractBits(val_14, 8u, 6u);\n  unpacked[77] = extractBits(val_14, 14u, 6u);\n  unpacked[78] = extractBits(val_14, 20u, 6u);\n  unpacked[79] = extractBits(val_14, 26u, 6u);\n\n  let val_15 = blocks[packed_offset + 15];\n  unpacked[80] = extractBits(val_15, 0u, 6u);\n  unpacked[81] = extractBits(val_15, 6u, 6u);\n  unpacked[82] = extractBits(val_15, 12u, 6u);\n  unpacked[83] = extractBits(val_15, 18u, 6u);\n  unpacked[84] = extractBits(val_15, 24u, 6u);\n  unpacked[85] = extractBits(val_15, 30u, 2u);\n  \n  let val_16 = blocks[packed_offset + 16];\n  unpacked[85] = insertBits(unpacked[85], extractBits(val_16, 0u, 4u), 2u, 4u);\n  unpacked[86] = extractBits(val_16, 4u, 6u);\n  unpacked[87] = extractBits(val_16, 10u, 6u);\n  unpacked[88] = extractBits(val_16, 16u, 6u);\n  unpacked[89] = extractBits(val_16, 22u, 6u);\n  unpacked[90] = extractBits(val_16, 28u, 4u);\n\n  let val_17 = blocks[packed_offset + 17];\n  unpacked[90] = insertBits(unpacked[90], extractBits(val_17, 0u, 2u), 4u, 2u);\n  unpacked[91] = extractBits(val_17, 2u, 6u);\n  unpacked[92] = extractBits(val_17, 8u, 6u);\n  unpacked[93] = extractBits(val_17, 14u, 6u);\n  unpacked[94] = extractBits(val_17, 20u, 6u);\n  unpacked[95] = extractBits(val_17, 26u, 6u);\n\n  let val_18 = blocks[packed_offset + 18];\n  unpacked[96] = extractBits(val_18, 0u, 6u);\n  unpacked[97] = extractBits(val_18, 6u, 6u);\n  unpacked[98] = extractBits(val_18, 12u, 6u);\n  unpacked[99] = extractBits(val_18, 18u, 6u);\n  unpacked[100] = extractBits(val_18, 24u, 6u);\n  unpacked[101] = extractBits(val_18, 30u, 2u);\n\n  let val_19 = blocks[packed_offset + 19];\n  unpacked[101] = insertBits(unpacked[101], extractBits(val_19, 0u, 4u), 2u, 4u);\n  unpacked[102] = extractBits(val_19, 4u, 6u);\n  unpacked[103] = extractBits(val_19, 10u, 6u);\n  unpacked[104] = extractBits(val_19, 16u, 6u);\n  unpacked[105] = extractBits(val_19, 22u, 6u);\n  unpacked[106] = extractBits(val_19, 28u, 4u);\n  \n  let val_20 = blocks[packed_offset + 20];\n  unpacked[106] = insertBits(unpacked[106], extractBits(val_20, 0u, 2u), 4u, 2u);\n  unpacked[107] = extractBits(val_20, 2u, 6u);\n  unpacked[108] = extractBits(val_20, 8u, 6u);\n  unpacked[109] = extractBits(val_20, 14u, 6u);\n  unpacked[110] = extractBits(val_20, 20u, 6u);\n  unpacked[111] = extractBits(val_20, 26u, 6u);\n\n  let val_21 = blocks[packed_offset + 21];\n  unpacked[112] = extractBits(val_21, 0u, 6u);\n  unpacked[113] = extractBits(val_21, 6u, 6u);\n  unpacked[114] = extractBits(val_21, 12u, 6u);\n  unpacked[115] = extractBits(val_21, 18u, 6u);\n  unpacked[116] = extractBits(val_21, 24u, 6u);\n  unpacked[117] = extractBits(val_21, 30u, 2u);\n\n  let val_22 = blocks[packed_offset + 22];\n  unpacked[117] = insertBits(unpacked[117], extractBits(val_22, 0u, 4u), 2u, 4u);\n  unpacked[118] = extractBits(val_22, 4u, 6u);\n  unpacked[119] = extractBits(val_22, 10u, 6u);\n  unpacked[120] = extractBits(val_22, 16u, 6u);\n  unpacked[121] = extractBits(val_22, 22u, 6u);\n  unpacked[122] = extractBits(val_22, 28u, 4u);\n\n  let val_23 = blocks[packed_offset + 23];\n  unpacked[122] = insertBits(unpacked[122], extractBits(val_23, 0u, 2u), 4u, 2u);\n  unpacked[123] = extractBits(val_23, 2u, 6u);\n  unpacked[124] = extractBits(val_23, 8u, 6u);\n  unpacked[125] = extractBits(val_23, 14u, 6u);\n  unpacked[126] = extractBits(val_23, 20u, 6u);\n  unpacked[127] = extractBits(val_23, 26u, 6u);\n}\n";var unpackBlock128BitDepth7="\nvar<private> unpacked: array<u32, 128>;\n\nfn unpack_block_128_bit_depth_7(packed_offset: u32) {\n  let val_0 = blocks[packed_offset];\n  unpacked[0] = extractBits(val_0, 0u, 7u);\n  unpacked[1] = extractBits(val_0, 7u, 7u);\n  unpacked[2] = extractBits(val_0, 14u, 7u);\n  unpacked[3] = extractBits(val_0, 21u, 7u);\n  unpacked[4] = extractBits(val_0, 28u, 4u);\n  \n  let val_1 = blocks[packed_offset + 1];\n  unpacked[4] = insertBits(unpacked[4], extractBits(val_1, 0u, 3u), 4u, 3u);\n  unpacked[5] = extractBits(val_1, 3u, 7u);\n  unpacked[6] = extractBits(val_1, 10u, 7u);\n  unpacked[7] = extractBits(val_1, 17u, 7u);\n  unpacked[8] = extractBits(val_1, 24u, 7u);\n  unpacked[9] = extractBits(val_1, 31u, 1u);\n  \n  let val_2 = blocks[packed_offset + 2];\n  unpacked[9] = insertBits(unpacked[9], extractBits(val_2, 0u, 6u), 1u, 6u);\n  unpacked[10] = extractBits(val_2, 6u, 7u);\n  unpacked[11] = extractBits(val_2, 13u, 7u);\n  unpacked[12] = extractBits(val_2, 20u, 7u);\n  unpacked[13] = extractBits(val_2, 27u, 5u);\n  \n  let val_3 = blocks[packed_offset + 3];\n  unpacked[13] = insertBits(unpacked[13], extractBits(val_3, 0u, 2u), 5u, 2u);\n  unpacked[14] = extractBits(val_3, 2u, 7u);\n  unpacked[15] = extractBits(val_3, 9u, 7u);\n  unpacked[16] = extractBits(val_3, 16u, 7u);\n  unpacked[17] = extractBits(val_3, 23u, 7u);\n  unpacked[18] = extractBits(val_3, 30u, 2u);\n  \n  let val_4 = blocks[packed_offset + 4];\n  unpacked[18] = insertBits(unpacked[18], extractBits(val_4, 0u, 5u), 2u, 5u);\n  unpacked[19] = extractBits(val_4, 5u, 7u);\n  unpacked[20] = extractBits(val_4, 12u, 7u);\n  unpacked[21] = extractBits(val_4, 19u, 7u);\n  unpacked[22] = extractBits(val_4, 26u, 6u);\n  \n  let val_5 = blocks[packed_offset + 5];\n  unpacked[22] = insertBits(unpacked[22], extractBits(val_5, 0u, 1u), 6u, 1u);\n  unpacked[23] = extractBits(val_5, 1u, 7u);\n  unpacked[24] = extractBits(val_5, 8u, 7u);\n  unpacked[25] = extractBits(val_5, 15u, 7u);\n  unpacked[26] = extractBits(val_5, 22u, 7u);\n  unpacked[27] = extractBits(val_5, 29u, 3u);\n  \n  let val_6 = blocks[packed_offset + 6];\n  unpacked[27] = insertBits(unpacked[27], extractBits(val_6, 0u, 4u), 3u, 4u);\n  unpacked[28] = extractBits(val_6, 4u, 7u);\n  unpacked[29] = extractBits(val_6, 11u, 7u);\n  unpacked[30] = extractBits(val_6, 18u, 7u);\n  unpacked[31] = extractBits(val_6, 25u, 7u);\n  \n  let val_7 = blocks[packed_offset + 7];\n  unpacked[32] = extractBits(val_7, 0u, 7u);\n  unpacked[33] = extractBits(val_7, 7u, 7u);\n  unpacked[34] = extractBits(val_7, 14u, 7u);\n  unpacked[35] = extractBits(val_7, 21u, 7u);\n  unpacked[36] = extractBits(val_7, 28u, 4u);\n  \n  let val_8 = blocks[packed_offset + 8];\n  unpacked[36] = insertBits(unpacked[36], extractBits(val_8, 0u, 3u), 4u, 3u);\n  unpacked[37] = extractBits(val_8, 3u, 7u);\n  unpacked[38] = extractBits(val_8, 10u, 7u);\n  unpacked[39] = extractBits(val_8, 17u, 7u);\n  unpacked[40] = extractBits(val_8, 24u, 7u);\n  unpacked[41] = extractBits(val_8, 31u, 1u);\n  \n  let val_9 = blocks[packed_offset + 9];\n  unpacked[41] = insertBits(unpacked[41], extractBits(val_9, 0u, 6u), 1u, 6u);\n  unpacked[42] = extractBits(val_9, 6u, 7u);\n  unpacked[43] = extractBits(val_9, 13u, 7u);\n  unpacked[44] = extractBits(val_9, 20u, 7u);\n  unpacked[45] = extractBits(val_9, 27u, 5u);\n  \n  let val_10 = blocks[packed_offset + 10];\n  unpacked[45] = insertBits(unpacked[45], extractBits(val_10, 0u, 2u), 5u, 2u);\n  unpacked[46] = extractBits(val_10, 2u, 7u);\n  unpacked[47] = extractBits(val_10, 9u, 7u);\n  unpacked[48] = extractBits(val_10, 16u, 7u);\n  unpacked[49] = extractBits(val_10, 23u, 7u);\n  unpacked[50] = extractBits(val_10, 30u, 2u);\n  \n  let val_11 = blocks[packed_offset + 11];\n  unpacked[50] = insertBits(unpacked[50], extractBits(val_11, 0u, 5u), 2u, 5u);\n  unpacked[51] = extractBits(val_11, 5u, 7u);\n  unpacked[52] = extractBits(val_11, 12u, 7u);\n  unpacked[53] = extractBits(val_11, 19u, 7u);\n  unpacked[54] = extractBits(val_11, 26u, 6u);\n  \n  let val_12 = blocks[packed_offset + 12];\n  unpacked[54] = insertBits(unpacked[54], extractBits(val_12, 0u, 1u), 6u, 1u);\n  unpacked[55] = extractBits(val_12, 1u, 7u);\n  unpacked[56] = extractBits(val_12, 8u, 7u);\n  unpacked[57] = extractBits(val_12, 15u, 7u);\n  unpacked[58] = extractBits(val_12, 22u, 7u);\n  unpacked[59] = extractBits(val_12, 29u, 3u);\n  \n  let val_13 = blocks[packed_offset + 13];\n  unpacked[59] = insertBits(unpacked[59], extractBits(val_13, 0u, 4u), 3u, 4u);\n  unpacked[60] = extractBits(val_13, 4u, 7u);\n  unpacked[61] = extractBits(val_13, 11u, 7u);\n  unpacked[62] = extractBits(val_13, 18u, 7u);\n  unpacked[63] = extractBits(val_13, 25u, 7u);\n  \n  let val_14 = blocks[packed_offset + 14];\n  unpacked[64] = extractBits(val_14, 0u, 7u);\n  unpacked[65] = extractBits(val_14, 7u, 7u);\n  unpacked[66] = extractBits(val_14, 14u, 7u);\n  unpacked[67] = extractBits(val_14, 21u, 7u);\n  unpacked[68] = extractBits(val_14, 28u, 4u);\n  \n  let val_15 = blocks[packed_offset + 15];\n  unpacked[68] = insertBits(unpacked[68], extractBits(val_15, 0u, 3u), 4u, 3u);\n  unpacked[69] = extractBits(val_15, 3u, 7u);\n  unpacked[70] = extractBits(val_15, 10u, 7u);\n  unpacked[71] = extractBits(val_15, 17u, 7u);\n  unpacked[72] = extractBits(val_15, 24u, 7u);\n  unpacked[73] = extractBits(val_15, 31u, 1u);\n  \n  let val_16 = blocks[packed_offset + 16];\n  unpacked[73] = insertBits(unpacked[73], extractBits(val_16, 0u, 6u), 1u, 6u);\n  unpacked[74] = extractBits(val_16, 6u, 7u);\n  unpacked[75] = extractBits(val_16, 13u, 7u);\n  unpacked[76] = extractBits(val_16, 20u, 7u);\n  unpacked[77] = extractBits(val_16, 27u, 5u);\n  \n  let val_17 = blocks[packed_offset + 17];\n  unpacked[77] = insertBits(unpacked[77], extractBits(val_17, 0u, 2u), 5u, 2u);\n  unpacked[78] = extractBits(val_17, 2u, 7u);\n  unpacked[79] = extractBits(val_17, 9u, 7u);\n  unpacked[80] = extractBits(val_17, 16u, 7u);\n  unpacked[81] = extractBits(val_17, 23u, 7u);\n  unpacked[82] = extractBits(val_17, 30u, 2u);\n  \n  let val_18 = blocks[packed_offset + 18];\n  unpacked[82] = insertBits(unpacked[82], extractBits(val_18, 0u, 5u), 2u, 5u);\n  unpacked[83] = extractBits(val_18, 5u, 7u);\n  unpacked[84] = extractBits(val_18, 12u, 7u);\n  unpacked[85] = extractBits(val_18, 19u, 7u);\n  unpacked[86] = extractBits(val_18, 26u, 6u);\n  \n  let val_19 = blocks[packed_offset + 19];\n  unpacked[86] = insertBits(unpacked[86], extractBits(val_19, 0u, 1u), 6u, 1u);\n  unpacked[87] = extractBits(val_19, 1u, 7u);\n  unpacked[88] = extractBits(val_19, 8u, 7u);\n  unpacked[89] = extractBits(val_19, 15u, 7u);\n  unpacked[90] = extractBits(val_19, 22u, 7u);\n  unpacked[91] = extractBits(val_19, 29u, 3u);\n  \n  let val_20 = blocks[packed_offset + 20];\n  unpacked[91] = insertBits(unpacked[91], extractBits(val_20, 0u, 4u), 3u, 4u);\n  unpacked[92] = extractBits(val_20, 4u, 7u);\n  unpacked[93] = extractBits(val_20, 11u, 7u);\n  unpacked[94] = extractBits(val_20, 18u, 7u);\n  unpacked[95] = extractBits(val_20, 25u, 7u);\n  \n  let val_21 = blocks[packed_offset + 21];\n  unpacked[96] = extractBits(val_21, 0u, 7u);\n  unpacked[97] = extractBits(val_21, 7u, 7u);\n  unpacked[98] = extractBits(val_21, 14u, 7u);\n  unpacked[99] = extractBits(val_21, 21u, 7u);\n  unpacked[100] = extractBits(val_21, 28u, 4u);\n  \n  let val_22 = blocks[packed_offset + 22];\n  unpacked[100] = insertBits(unpacked[100], extractBits(val_22, 0u, 3u), 4u, 3u);\n  unpacked[101] = extractBits(val_22, 3u, 7u);\n  unpacked[102] = extractBits(val_22, 10u, 7u);\n  unpacked[103] = extractBits(val_22, 17u, 7u);\n  unpacked[104] = extractBits(val_22, 24u, 7u);\n  unpacked[105] = extractBits(val_22, 31u, 1u);\n  \n  let val_23 = blocks[packed_offset + 23];\n  unpacked[105] = insertBits(unpacked[105], extractBits(val_23, 0u, 6u), 1u, 6u);\n  unpacked[106] = extractBits(val_23, 6u, 7u);\n  unpacked[107] = extractBits(val_23, 13u, 7u);\n  unpacked[108] = extractBits(val_23, 20u, 7u);\n  unpacked[109] = extractBits(val_23, 27u, 5u);\n  \n  let val_24 = blocks[packed_offset + 24];\n  unpacked[109] = insertBits(unpacked[109], extractBits(val_24, 0u, 2u), 5u, 2u);\n  unpacked[110] = extractBits(val_24, 2u, 7u);\n  unpacked[111] = extractBits(val_24, 9u, 7u);\n  unpacked[112] = extractBits(val_24, 16u, 7u);\n  unpacked[113] = extractBits(val_24, 23u, 7u);\n  unpacked[114] = extractBits(val_24, 30u, 2u);\n  \n  let val_25 = blocks[packed_offset + 25];\n  unpacked[114] = insertBits(unpacked[114], extractBits(val_25, 0u, 5u), 2u, 5u);\n  unpacked[115] = extractBits(val_25, 5u, 7u);\n  unpacked[116] = extractBits(val_25, 12u, 7u);\n  unpacked[117] = extractBits(val_25, 19u, 7u);\n  unpacked[118] = extractBits(val_25, 26u, 6u);\n  \n  let val_26 = blocks[packed_offset + 26];\n  unpacked[118] = insertBits(unpacked[118], extractBits(val_26, 0u, 1u), 6u, 1u);\n  unpacked[119] = extractBits(val_26, 1u, 7u);\n  unpacked[120] = extractBits(val_26, 8u, 7u);\n  unpacked[121] = extractBits(val_26, 15u, 7u);\n  unpacked[122] = extractBits(val_26, 22u, 7u);\n  unpacked[123] = extractBits(val_26, 29u, 3u);\n  \n  let val_27 = blocks[packed_offset + 27];\n  unpacked[123] = insertBits(unpacked[123], extractBits(val_27, 0u, 4u), 3u, 4u);\n  unpacked[124] = extractBits(val_27, 4u, 7u);\n  unpacked[125] = extractBits(val_27, 11u, 7u);\n  unpacked[126] = extractBits(val_27, 18u, 7u);\n  unpacked[127] = extractBits(val_27, 25u, 7u);    \n}\n";var fromFP510Function="\n\nconst exponents: array<f32, 32> = array(\n  2.9103830456733704e-11, \n  5.820766091346741e-11, \n  1.1641532182693481e-10, \n  2.3283064365386963e-10,\n  4.656612873077393e-10, \n  9.313225746154785e-10, \n  1.862645149230957e-09, \n  3.725290298461914e-09,\n  7.450580596923828e-09, \n  1.4901161193847656e-08, \n  2.9802322387695312e-08, \n  5.960464477539063e-08,\n  1.1920928955078125e-07, \n  2.384185791015625e-07, \n  4.76837158203125e-07, \n  9.5367431640625e-07,\n  1.9073486328125e-06, \n  3.814697265625e-06, \n  7.62939453125e-06, \n  1.52587890625e-05, \n  3.0517578125e-05,\n  6.103515625e-05, \n  0.0001220703125, \n  0.000244140625, \n  0.00048828125, \n  0.0009765625, \n  0.001953125, \n  0.00390625,\n  0.0078125, \n  0.015625, \n  0.03125, \n  0.0625);\n\nfn from_fp510(x: u32) -> f32 {\n    let exponent = f32(exponents[extractBits(x, 10u, 5u)]);        \n    let fractional = f32(extractBits(x, 0u, 10u));        \n    let abs = exponent * fractional;\n    return abs * (1.0 - (2.0 * f32(extractBits(x, 15u, 1u))));\n}\n";var preprocessBlocks3BitShaderSource="\n\nstruct argsStruct {\n  nbr: u32,\n  nbc: u32,\n  blocks_offset: u32\n};\n\n@group(0) @binding(0) \nvar<uniform> args: argsStruct;\n\n@group(0) @binding(1)\nvar<storage, read_write> blocks: array<u32>;\n\n".concat(unpackBlock128BitDepth3,"\n\noverride workgroup_size_x: u32 = 1;\noverride workgroup_size_y: u32 = 1;\noverride workgroup_size_z: u32 = 1;\n\n@compute @workgroup_size(workgroup_size_x, workgroup_size_y, workgroup_size_z)\nfn main(@builtin(global_invocation_id) global_id: vec3<u32>) {\n  if (global_id.x >= args.nbr || global_id.y >= args.nbc) {\n      return;\n  }\n  \n  let blocks_start: u32 = args.blocks_offset + ((global_id.x * args.nbc + global_id.y) * 12u);    \n  unpack_block_128_bit_depth_3(blocks_start);    \n      \n  let b01: u32 = blocks_start;\n  let b2: u32 = blocks_start + 8u;\n  \n  for (var r = 0u; r < ").concat(rowsPerBlock,"u; r++) {\n    let unpacked_idx = r * ").concat(columnsPerBlock,"u;\n    let b01_idx = b01 + (r / 2u);\n    let b2_idx = b2 + (r / 4u);\n\n    blocks[b01_idx] = insertBits(blocks[b01_idx], extractBits(unpacked[unpacked_idx], 0u, 2u), (r * 16u) % 32u, 16u);\n    blocks[b2_idx] = insertBits(blocks[b2_idx], extractBits(unpacked[unpacked_idx], 2u, 1u), (r * 8u) % 32u, 8u);  \n  }\n    \n  for (var c = 1u; c < ").concat(columnsPerBlock,"u; c++) {\n    for (var r = 0u; r < ").concat(rowsPerBlock,"u; r++) {\n      let unpacked_idx = r * ").concat(columnsPerBlock,"u + c;\n      let b01_idx = b01 + (r / 2u);\n      let b2_idx = b2 + (r / 4u);\n                \n      blocks[b01_idx] = insertBits(blocks[b01_idx], extractBits(unpacked[unpacked_idx], 0u, 2u), ((r * 16u) % 32u) + (2u * c), 2u);\n      blocks[b2_idx] = insertBits(blocks[b2_idx], extractBits(unpacked[unpacked_idx], 2u, 1u), ((r * 8u) % 32u) + c, 1u);  \n    }\n  }\n}\n\n").concat(emptyShader);var preprocessBlocks5BitShaderSource="\n\nstruct argsStruct {\n  nbr: u32,\n  nbc: u32,\n  blocks_offset: u32\n};\n\n@group(0) @binding(0) \nvar<uniform> args: argsStruct;\n\n@group(0) @binding(1)\nvar<storage, read_write> blocks: array<u32>;\n\n".concat(unpackBlock128BitDepth5,"\n\noverride workgroup_size_x: u32 = 1;\noverride workgroup_size_y: u32 = 1;\noverride workgroup_size_z: u32 = 1;\n\n@compute @workgroup_size(workgroup_size_x, workgroup_size_y, workgroup_size_z)\nfn main(@builtin(global_invocation_id) global_id: vec3<u32>) {\n  if (global_id.x >= args.nbr || global_id.y >= args.nbc) {\n      return;\n  }\n\n  let blocks_start: u32 = args.blocks_offset + ((global_id.x * args.nbc + global_id.y) * 20u);\n  unpack_block_128_bit_depth_5(blocks_start);    \n  \n  let b03: u32 = blocks_start;\n  let b4: u32 = blocks_start + 16u;\n\n  for (var r = 0u; r < ").concat(rowsPerBlock,"u; r++) {\n    let unpacked_idx = r * ").concat(columnsPerBlock,"u;\n    let b03_idx = b03 + r;\n    let b4_idx = b4 + (r / 4u);\n          \n    blocks[b03_idx] = insertBits(blocks[b03_idx], extractBits(unpacked[unpacked_idx], 0u, 4u), 0u, 32u);\n    blocks[b4_idx] = insertBits(blocks[b4_idx], extractBits(unpacked[unpacked_idx], 4u, 1u), (r * 8u) % 32u, 8u);\n  }\n      \n  for (var c = 1u; c < ").concat(columnsPerBlock,"u; c++) {\n    for (var r = 0u; r < ").concat(rowsPerBlock,"u; r++) {\n      let unpacked_idx = r * ").concat(columnsPerBlock,"u + c;\n      let b03_idx = b03 + r;\n      let b4_idx = b4 + (r / 4u);\n                                \n      blocks[b03_idx] = insertBits(blocks[b03_idx], extractBits(unpacked[unpacked_idx], 0u, 4u), 4 * c, 4u);\n      blocks[b4_idx] = insertBits(blocks[b4_idx], extractBits(unpacked[unpacked_idx], 4u, 1u), ((r * 8u) % 32u) + c, 1u);\n    }\n  }   \n}\n\n").concat(emptyShader);var preprocessBlocks6BitShaderSource="\n\nstruct argsStruct {\n  nbr: u32,\n  nbc: u32,\n  blocks_offset: u32\n};\n\n@group(0) @binding(0) \nvar<uniform> args: argsStruct;\n\n@group(0) @binding(1)\nvar<storage, read_write> blocks: array<u32>;\n\n".concat(unpackBlock128BitDepth6,"\n\noverride workgroup_size_x: u32 = 1;\noverride workgroup_size_y: u32 = 1;\noverride workgroup_size_z: u32 = 1;\n\n@compute @workgroup_size(workgroup_size_x, workgroup_size_y, workgroup_size_z)\nfn main(@builtin(global_invocation_id) global_id: vec3<u32>) {\n  if (global_id.x >= args.nbr || global_id.y >= args.nbc) {\n      return;\n  }\n  \n  let blocks_start: u32 = args.blocks_offset + ((global_id.x * args.nbc + global_id.y) * 24u);\n  unpack_block_128_bit_depth_6(blocks_start);\n  \n  let b03: u32 = blocks_start;\n  let b45: u32 = blocks_start + 16u;    \n  for (var r = 0u; r < ").concat(rowsPerBlock,"u; r++) {\n    let unpacked_idx = r * ").concat(columnsPerBlock,"u;\n    let b03_idx = b03 + r;\n    let b45_idx = b45 + (r / 2u);\n    \n    blocks[b03_idx] = insertBits(blocks[b03_idx], extractBits(unpacked[unpacked_idx], 0u, 4u), 0u, 32u);\n    blocks[b45_idx] = insertBits(blocks[b45_idx], extractBits(unpacked[unpacked_idx], 4u, 2u), ((r * 16u) % 32u), 16u);\n  }\n\n  for (var c = 1u; c < ").concat(columnsPerBlock,"u; c++) {\n    for (var r = 0u; r < ").concat(rowsPerBlock,"u; r++) {\n      let unpacked_idx = r * ").concat(columnsPerBlock,"u + c;\n      let b03_idx = b03 + r;\n      let b45_idx = b45 + (r / 2u);\n      \n      blocks[b03_idx] = insertBits(blocks[b03_idx], extractBits(unpacked[unpacked_idx], 0u, 4u), 4 * c, 4u);\n      blocks[b45_idx] = insertBits(blocks[b45_idx], extractBits(unpacked[unpacked_idx], 4u, 2u), ((r * 16u) % 32u) + (2 * c), 2u);\n    }\n  }\n}\n\n").concat(emptyShader);var preprocessBlocks7BitShaderSource="\n\nstruct argsStruct {\n  nbr: u32,\n  nbc: u32,\n  blocks_offset: u32\n};\n\n@group(0) @binding(0) \nvar<uniform> args: argsStruct;\n\n@group(0) @binding(1)\nvar<storage, read_write> blocks: array<u32>;\n\n".concat(unpackBlock128BitDepth7,"\n\noverride workgroup_size_x: u32 = 1;\noverride workgroup_size_y: u32 = 1;\noverride workgroup_size_z: u32 = 1;\n\n@compute @workgroup_size(workgroup_size_x, workgroup_size_y, workgroup_size_z)\nfn main(@builtin(global_invocation_id) global_id: vec3<u32>) {\n  if (global_id.x >= args.nbr || global_id.y >= args.nbc) {\n      return;\n  }\n  \n  let blocks_start: u32 = args.blocks_offset + ((global_id.x * args.nbc + global_id.y) * 28u);\n  unpack_block_128_bit_depth_7(blocks_start);\n  \n  let b03: u32 = blocks_start;\n  let b45: u32 = blocks_start + 16u;\n  let b6: u32 = blocks_start + 24u;  \n  for (var r = 0u; r < ").concat(rowsPerBlock,"u; r++) {\n    let unpacked_idx = r * ").concat(columnsPerBlock,"u;\n    let b03_idx = b03 + r;\n    let b45_idx = b45 + (r / 2u);\n    let b6_idx = b6 + (r / 4u);\n    \n    blocks[b03_idx] = insertBits(blocks[b03_idx], extractBits(unpacked[unpacked_idx], 0u, 4u), 0, 32u);\n    blocks[b45_idx] = insertBits(blocks[b45_idx], extractBits(unpacked[unpacked_idx], 4u, 2u), ((r * 16u) % 32u), 16u);\n    blocks[b6_idx] = insertBits(blocks[b6_idx], extractBits(unpacked[unpacked_idx], 6u, 1u), ((r * 8u) % 32u), 8u);\n  }\n  \n  for (var c = 1u; c < ").concat(columnsPerBlock,"u; c++) {\n    for (var r = 0u; r < ").concat(rowsPerBlock,"u; r++) {\n      let unpacked_idx = r * ").concat(columnsPerBlock,"u + c;\n      let b03_idx = b03 + r;\n      let b45_idx = b45 + (r / 2u);\n      let b6_idx = b6 + (r / 4u);\n      \n      blocks[b03_idx] = insertBits(blocks[b03_idx], extractBits(unpacked[unpacked_idx], 0u, 4u), 4 * c, 4u);\n      blocks[b45_idx] = insertBits(blocks[b45_idx], extractBits(unpacked[unpacked_idx], 4u, 2u), ((r * 16u) % 32u) + (2 * c), 2u);\n      blocks[b6_idx] = insertBits(blocks[b6_idx], extractBits(unpacked[unpacked_idx], 6u, 1u), ((r * 8u) % 32u) + c, 1u);\n    }\n  }\n}\n\n").concat(emptyShader);var preprocessShaderSources={3:preprocessBlocks3BitShaderSource,5:preprocessBlocks5BitShaderSource,6:preprocessBlocks6BitShaderSource,7:preprocessBlocks7BitShaderSource};var preprocessShaderNames={3:"pv_picollm_weight_block_mixed_16x8_preprocess_blocks_3bit_shader",5:"pv_picollm_weight_block_mixed_16x8_preprocess_blocks_5bit_shader",6:"pv_picollm_weight_block_mixed_16x8_preprocess_blocks_6bit_shader",7:"pv_picollm_weight_block_mixed_16x8_preprocess_blocks_7bit_shader"};var BM=8;var BN=32;var TM=2;var TN=16;var TC=rowsPerBlock*BM*BN/(TM*TN);var constantSnippet="\nconst BM = ".concat(BM,"u;\nconst BN = ").concat(BN,"u;\n\nconst TM = ").concat(TM,"u;\nconst TN = ").concat(TN,"u;\n\nconst TC = ").concat(TC,"u;\n\nconst ROW_PER_BLOCK = ").concat(rowsPerBlock,"u;\nconst COL_PER_BLOCK = ").concat(columnsPerBlock,"u;\n\nconst VEC_COL_PER_BLOCK = COL_PER_BLOCK / 4u;\n\nconst block_size: u32 = (COL_PER_BLOCK * ROW_PER_BLOCK * bit_depth) / 32u;\n\n");var forwardMultipleInputArgsSnippet="\nstruct argsStruct {\n  n: u32,\n  m: u32,\n  total_nbc: u32,\n  k: u32,\n  x_offset: u32,\n  metas_offset: u32,\n  blocks_offset: u32,\n  y_offset: u32,\n};\n\n@group(0) @binding(0) \nvar<uniform> args: argsStruct;\n\n@group(0) @binding(1)\nvar<storage, read> x: array<vec4<f32>>;\n\n@group(0) @binding(2)\nvar<storage, read> metas: array<u32>;\n\n@group(0) @binding(3)\nvar<storage, read> blocks: array<u32>;\n\n@group(0) @binding(4)\nvar<storage, read_write> y: array<f32>;\n";var forwardMultipleSharedPrivateMemSnippet="\nvar<workgroup> shared_x: array<vec4<f32>, BN * VEC_COL_PER_BLOCK>;\nvar<workgroup> shared_ab: array<f32, BM * 2>;\nvar<workgroup> shared_w: array<vec4<f32>, BM * ROW_PER_BLOCK * VEC_COL_PER_BLOCK>;\n\nvar<private> local_x: array<vec4<f32>, TN * VEC_COL_PER_BLOCK>;\nvar<private> local_x_sums: array<f32, TN>;\nvar<private> local_results: array<f32, TM * TN>;\n";var forwardMultipleLocalVarSnippet="\n  let tid = local_id.x;\n  let bm_idx = workgroup_id.x;\n  let bn_idx = workgroup_id.y;\n\n  let local_bm_idx = bm_idx * BM;\n  let local_bn_idx = bn_idx * BN;\n  \n  let n_idx = tid % (BN / TN);\n  let k_idx = tid / (BN / TN) / (BM * ROW_PER_BLOCK / TM);\n  let m_idx = tid / (BN / TN) % (BM * ROW_PER_BLOCK / TM);\n";var forwardMultipleLoadW1Bit="\n  let b0 = blocks[src + (row / 4u)];\n\n  let b0_offset_base = (row * 8u) % 32u;\n  for (var c = 0u; c < VEC_COL_PER_BLOCK; c++) {\n    let b0_offset = b0_offset_base + (c * 4u); \n    shared_w[dst + c] = vec4(\n      f32(extractBits(b0, b0_offset, 1u)), \n      f32(extractBits(b0, b0_offset + 1, 1u)),\n      f32(extractBits(b0, b0_offset + 2, 1u)),\n      f32(extractBits(b0, b0_offset + 3, 1u)));\n  }\n";var forwardMultipleLoadW2Bit="\n  let b01 = blocks[src + (row / 2u)];\n \n  let b01_offset_base = (row * 16u) % 32u;\n  for (var c = 0u; c < VEC_COL_PER_BLOCK; c++) {  \n    let b01_offset = b01_offset_base + (c * 8u);\n    shared_w[dst + c] = vec4(\n      f32(extractBits(b01, b01_offset, 2u)), \n      f32(extractBits(b01, b01_offset + 2, 2u)),\n      f32(extractBits(b01, b01_offset + 4, 2u)),\n      f32(extractBits(b01, b01_offset + 6, 2u)));\n  }  \n";var forwardMultipleLoadW3Bit="\n  let b01 = blocks[src + (row / 2u)];\n  let b2 = blocks[src + 8u + (row / 4u)]; \n\n  let b01_offset_base = (row * 16u) % 32u;\n  let b2_offset_base = (row * 8u) % 32u;\n  for (var c = 0u; c < VEC_COL_PER_BLOCK; c++) {\n    let b01_offset = b01_offset_base + (c * 8u);\n    let b2_offset = b2_offset_base + (c * 4u);\n\n    shared_w[dst + c] = vec4(\n      f32(insertBits(extractBits(b01, b01_offset, 2u), extractBits(b2, b2_offset, 1u), 2u, 1u)), \n      f32(insertBits(extractBits(b01, b01_offset + 2, 2u), extractBits(b2, b2_offset + 1, 1u), 2u, 1u)),\n      f32(insertBits(extractBits(b01, b01_offset + 4, 2u), extractBits(b2, b2_offset + 2, 1u), 2u, 1u)),\n      f32(insertBits(extractBits(b01, b01_offset + 6, 2u), extractBits(b2, b2_offset + 3, 1u), 2u, 1u)));    \n  }\n";var forwardMultipleLoadW4Bit="\n  let b03 = blocks[src + row];\n    \n  for (var c = 0u; c < VEC_COL_PER_BLOCK; c++) {\n    let b03_offset = (c * 16u); \n    shared_w[dst + c] = vec4(\n      f32(extractBits(b03, b03_offset, 4u)), \n      f32(extractBits(b03, b03_offset + 4, 4u)),\n      f32(extractBits(b03, b03_offset + 8, 4u)),\n      f32(extractBits(b03, b03_offset + 12, 4u)));\n  }\n";var forwardMultipleLoadW5Bit="\n  let b03 = blocks[src + row];\n  let b4 = blocks[src + 16u + (row / 4u)];\n  \n  let b4_offset_base = (row * 8u) % 32u;\n  for (var c = 0u; c < VEC_COL_PER_BLOCK; c++) {\n    let b03_offset = (c * 16u);\n    let b4_offset = b4_offset_base + (c * 4u);\n    shared_w[dst + c] = vec4(\n      f32(insertBits(extractBits(b03, b03_offset, 4u), extractBits(b4, b4_offset, 1u), 4u, 1u)), \n      f32(insertBits(extractBits(b03, b03_offset + 4, 4u), extractBits(b4, b4_offset + 1, 1u), 4u, 1u)),\n      f32(insertBits(extractBits(b03, b03_offset + 8, 4u), extractBits(b4, b4_offset + 2, 1u), 4u, 1u)),\n      f32(insertBits(extractBits(b03, b03_offset + 12, 4u), extractBits(b4, b4_offset + 3, 1u), 4u, 1u)));\n  }\n";var forwardMultipleLoadW6Bit="\n  let b03 = blocks[src + row];\n  let b45 = blocks[src + 16u + (row / 2u)];\n  \n  let b45_offset_base = (row * 16u) % 32u;\n  for (var c = 0u; c < VEC_COL_PER_BLOCK; c++) {   \n    let b03_offset = (c * 16u);\n    let b45_offset = b45_offset_base + (c * 8u);\n    shared_w[dst + c] = vec4(\n      f32(insertBits(extractBits(b03, b03_offset, 4u), extractBits(b45, b45_offset, 2u), 4u, 2u)), \n      f32(insertBits(extractBits(b03, b03_offset + 4, 4u), extractBits(b45, b45_offset + 2, 2u), 4u, 2u)),\n      f32(insertBits(extractBits(b03, b03_offset + 8, 4u), extractBits(b45, b45_offset + 4, 2u), 4u, 2u)),\n      f32(insertBits(extractBits(b03, b03_offset + 12, 4u), extractBits(b45, b45_offset + 6, 2u), 4u, 2u)));\n  }\n";var forwardMultipleLoadW7Bit="\n  let b03 = blocks[src + row];\n  let b45 = blocks[src + 16u + (row / 2u)];\n  let b6 = blocks[src + 24u + (row / 4u)];\n  \n  let b45_offset_base = (row * 16u) % 32u;\n  let b6_offset_base = (row * 8u) % 32u;\n  for (var c = 0u; c < VEC_COL_PER_BLOCK; c++) {\n    let b03_offset = (c * 16u);\n    let b45_offset = b45_offset_base + (c * 8u);\n    let b6_offset = b6_offset_base + (c * 4u);\n    \n    shared_w[dst + c] = vec4(\n      f32(insertBits(insertBits(extractBits(b03, b03_offset, 4u), extractBits(b45, b45_offset, 2u), 4u, 2u), extractBits(b6, b6_offset, 1u), 6u, 1u)), \n      f32(insertBits(insertBits(extractBits(b03, b03_offset + 4, 4u), extractBits(b45, b45_offset + 2, 2u), 4u, 2u), extractBits(b6, b6_offset + 1, 1u), 6u, 1u)),\n      f32(insertBits(insertBits(extractBits(b03, b03_offset + 8, 4u), extractBits(b45, b45_offset + 4, 2u), 4u, 2u), extractBits(b6, b6_offset + 2, 1u), 6u, 1u)),\n      f32(insertBits(insertBits(extractBits(b03, b03_offset + 12, 4u), extractBits(b45, b45_offset + 6, 2u), 4u, 2u), extractBits(b6, b6_offset + 3, 1u), 6u, 1u)));\n  }\n";var forwardMultipleLoadW8Bit="\n  let b07_offset = src + (row * 2);\n  \n  for (var c = 0u; c < VEC_COL_PER_BLOCK; c++) {\n    let b07 = blocks[b07_offset + c];\n    shared_w[dst + c] = vec4(\n      f32(extractBits(b07, 0u, 8u)), \n      f32(extractBits(b07, 8u, 8u)),\n      f32(extractBits(b07, 16u, 8u)),\n      f32(extractBits(b07, 24u, 8u)));\n  }\n";var forwardLoadWBitDepthSnippets={1:forwardMultipleLoadW1Bit,2:forwardMultipleLoadW2Bit,3:forwardMultipleLoadW3Bit,4:forwardMultipleLoadW4Bit,5:forwardMultipleLoadW5Bit,6:forwardMultipleLoadW6Bit,7:forwardMultipleLoadW7Bit,8:forwardMultipleLoadW8Bit};var forwardMultipleLoadXSnippet="\n  let total_work_x = VEC_COL_PER_BLOCK * BN;\n  for (var local_idx = 0u; local_idx < divide_pad(total_work_x, TC); local_idx++) {\n    let idx = local_idx * TC + tid;\n    if (idx < total_work_x) {      \n      let n_load_idx = local_bn_idx + idx / VEC_COL_PER_BLOCK;\n      let inner_idx = idx % VEC_COL_PER_BLOCK;\n      \n      if (bk_idx < args.k && n_load_idx < args.n) {  \n        let x_idx = (args.x_offset / 4u) + ((bk_idx * args.n + n_load_idx) * VEC_COL_PER_BLOCK + inner_idx);                                   \n        shared_x[idx] = x[x_idx];\n      } else {\n        shared_x[idx] = vec4(0.0);\n      }\n    }\n  }\n";var forwardMultipleLoadABSnippet="\n  let total_work_ab = BM * 2;\n  for (var local_idx = 0u; local_idx < divide_pad(total_work_ab, TC); local_idx++) {\n    let idx = local_idx * TC + tid;\n    if (idx < total_work_ab) {\n      let m_load_idx = local_bm_idx + idx / 2;      \n      let inner_idx = (idx % 2) * 16u;\n        \n      if (m_load_idx < args.m && bk_idx < args.k) {\n        let ab_bits = extractBits(metas[args.metas_offset + (m_load_idx * args.k + bk_idx)], inner_idx, 16u);\n        shared_ab[idx] = from_fp510(ab_bits);          \n      } else {\n        shared_ab[idx] = 0.0;\n      }\n    }\n  }\n";var forwardMultipleLoadWSnippet=function forwardMultipleLoadWSnippet(bitDepth){return"\n  let total_work_w = BM * ROW_PER_BLOCK;\n  for (var local_idx = 0u; local_idx < divide_pad(total_work_w, TC); local_idx++) {\n    let idx = local_idx * TC + tid;\n    if (idx < total_work_w) {\n      let m_load_idx = local_bm_idx + idx / ROW_PER_BLOCK;\n      let row = idx % ROW_PER_BLOCK;\n      let dst = idx * VEC_COL_PER_BLOCK;\n\n      if (m_load_idx < args.m) {\n        let src = args.blocks_offset + (m_load_idx * args.k + bk_idx) * block_size;\n        ".concat(forwardLoadWBitDepthSnippets[bitDepth],"\n      } else {   \n        for (var c = 0u; c < VEC_COL_PER_BLOCK; c++) {\n          shared_w[dst + c] = vec4(0.0);\n        }\n      }\n    }\n  }\n")};var forwardMultipleCopyXSnippet="\nfor (var tn_idx = 0u; tn_idx < TN; tn_idx++) {  \n  var x_sum_vec = vec4(0.0);  \n  let local_x_idx = tn_idx * VEC_COL_PER_BLOCK;\n  let shared_x_idx = (n_idx * TN + tn_idx) * VEC_COL_PER_BLOCK + (k_idx * VEC_COL_PER_BLOCK);\n  for (var c = 0u; c < VEC_COL_PER_BLOCK; c++) {\n    local_x[local_x_idx + c] = shared_x[shared_x_idx + c];\n    x_sum_vec += local_x[local_x_idx + c];\n  }\n  local_x_sums[tn_idx] = x_sum_vec.x + x_sum_vec.y + x_sum_vec.z + x_sum_vec.w;  \n}\n";var forwardMultipleComputeResultsSnippet="\n  for (var tm_idx = 0u; tm_idx < TM; tm_idx++) {      \n    let shared_ab_idx = ((m_idx * TM + tm_idx) / ROW_PER_BLOCK + k_idx) * 2;\n    let alpha = shared_ab[shared_ab_idx];\n    let beta = shared_ab[shared_ab_idx + 1];             \n    let shared_w_idx = ((m_idx * TM + tm_idx) + k_idx) * VEC_COL_PER_BLOCK;\n    \n    for (var tn_idx = 0u; tn_idx < TN; tn_idx++) {      \n      let local_x_idx = tn_idx * VEC_COL_PER_BLOCK;\n      \n      var swx_vec = vec4(0.0); \n      for (var c = 0u; c < VEC_COL_PER_BLOCK; c++) {        \n        swx_vec += shared_w[shared_w_idx + c] * local_x[local_x_idx + c];\n      }\n      let swx = swx_vec.x + swx_vec.y + swx_vec.z + swx_vec.w;\n      \n      let kappa = alpha * local_x_sums[tn_idx]; \n      let results_idx = tm_idx * TN + tn_idx;\n      local_results[results_idx] += kappa + (beta * swx);\n    }\n  }\n";var forwardMultipleWriteResultsSnippet="\nfor (var tm_idx = 0u; tm_idx < TM; tm_idx++) {\n  let row = local_bm_idx * ROW_PER_BLOCK + (m_idx * TM + tm_idx);  \n  for (var tn_idx = 0u; tn_idx < TN; tn_idx++) {    \n    let col = local_bn_idx + (n_idx * TN + tn_idx);\n    if (row < args.m * ROW_PER_BLOCK && col < args.n) {\n      let y_idx = args.y_offset + ((row / ROW_PER_BLOCK) * args.n + col) * ROW_PER_BLOCK + (row % ROW_PER_BLOCK);\n      let results_idx = tm_idx * TN + tn_idx;\n      \n      y[y_idx] += local_results[results_idx];\n    }\n  }\n}\n";var forwardMultipleShaderSources=function forwardMultipleShaderSources(bitDepth){return"\n\n".concat(forwardMultipleInputArgsSnippet,"\n\n").concat(constantSnippet,"\n\n").concat(forwardMultipleSharedPrivateMemSnippet,"\n\n").concat(fromFP510Function,"\n\n").concat(dividePadFunction,"\n\nconst bit_depth: u32 = ").concat(bitDepth,"u;\n\noverride workgroup_size_x: u32 = 1;\noverride workgroup_size_y: u32 = 1;\noverride workgroup_size_z: u32 = 1;\n \n@compute @workgroup_size(workgroup_size_x, workgroup_size_y, workgroup_size_z)\nfn main(\n  @builtin(local_invocation_id) local_id: vec3<u32>,\n  @builtin(workgroup_id) workgroup_id: vec3<u32>\n) {\n  ").concat(forwardMultipleLocalVarSnippet,"\n    \n  for (var bk_idx = 0u; bk_idx < args.k; bk_idx++) {      \n    ").concat(forwardMultipleLoadXSnippet,"\n    ").concat(forwardMultipleLoadABSnippet,"    \n    ").concat(forwardMultipleLoadWSnippet(bitDepth),"    \n    workgroupBarrier();\n        \n    ").concat(forwardMultipleCopyXSnippet,"\n    ").concat(forwardMultipleComputeResultsSnippet,"\n    workgroupBarrier();\n  }\n    \n  ").concat(forwardMultipleWriteResultsSnippet,"\n}\n\n").concat(emptyShader,"\n")};var forwardShuffleXShaderSource="\nstruct argsStruct {\n  n: u32,\n  shape1: u32,\n  x_offset: u32,\n  indices_offset: u32,  \n};\n\n@group(0) @binding(0) \nvar<uniform> args: argsStruct;\n\n@group(0) @binding(1)\nvar<storage, read> x: array<f32>;\n\n@group(0) @binding(2)\nvar<storage, read> indices: array<u32>;\n\n@group(0) @binding(3)\nvar<storage, read_write> y: array<f32>;\n\noverride workgroup_size_x: u32 = 1;\noverride workgroup_size_y: u32 = 1;\noverride workgroup_size_z: u32 = 1;\n\n@compute @workgroup_size(workgroup_size_x, workgroup_size_y, workgroup_size_z)\nfn main(@builtin(global_invocation_id) global_id: vec3<u32>) {\n  if (global_id.x >= args.n || global_id.y >= args.shape1) {\n    return;\n  } \n\n  let b = global_id.x;\n  let i = global_id.y;\n      \n  let c = i / 8u;\n  let j = i % 8u;\n  y[((c * args.n) + b) * 8 + j] = x[args.x_offset + (b * args.shape1) + indices[args.indices_offset + i]];\n}\n\n".concat(emptyShader,"\n");var forwardSingleReduceYShaderSource="\nstruct argsStruct {\n  nvr: u32,\n  nbc: u32,  \n};\n\n@group(0) @binding(0) \nvar<uniform> args: argsStruct;\n\n@group(0) @binding(1)\nvar<storage, read> x: array<vec4<f32>>;\n\n@group(0) @binding(2)\nvar<storage, read_write> y: array<vec4<f32>>;\n\noverride workgroup_size_x: u32 = 1;\noverride workgroup_size_y: u32 = 1;\noverride workgroup_size_z: u32 = 1;\n\n@compute @workgroup_size(workgroup_size_x, workgroup_size_y, workgroup_size_z)\nfn main(@builtin(global_invocation_id) global_id: vec3<u32>) {   \n  if (global_id.x > args.nvr) {\n    return;\n  }\n\n  let x_start = global_id.x * args.nbc;\n  var sum: vec4<f32> = vec4(0.0, 0.0, 0.0, 0.0);\n  for (var i = 0u; i < args.nbc; i++) {\n    sum += x[x_start + i];    \n  }\n  y[global_id.x] += sum;\n}\n\n".concat(emptyShader);var forwardShuffleYShaderSource="\nstruct argsStruct {\n  n: u32,\n  shape0: u32,  \n};\n\n@group(0) @binding(0) \nvar<uniform> args: argsStruct;\n\n@group(0) @binding(1)\nvar<storage, read> x: array<f32>;\n\n@group(0) @binding(2)\nvar<storage, read_write> y: array<f32>;\n\noverride workgroup_size_x: u32 = 1;\noverride workgroup_size_y: u32 = 1;\noverride workgroup_size_z: u32 = 1;\n\n@compute @workgroup_size(workgroup_size_x, workgroup_size_y, workgroup_size_z)\nfn main(@builtin(global_invocation_id) global_id: vec3<u32>) {\n    if (global_id.x >= args.n || global_id.y >= args.shape0) {\n      return;\n    } \n    \n    let b = global_id.x;\n    let i = global_id.y;\n        \n    let r = i / 16u;\n    let j = i % 16u;\n    y[(b * args.shape0) + (r * 16) + j] = x[(((r * args.n) + b) * 16) + j];\n}\n\n".concat(emptyShader);var addBiasShaderSource="\nstruct argsStruct {\n  dimension: u32\n};\n\n@group(0) @binding(0) \nvar<uniform> args: argsStruct;\n\n@group(0) @binding(1)\nvar<storage, read> bias: array<f32>;\n\n@group(0) @binding(2)\nvar<storage, read_write> y: array<f32>;\n\n".concat(fromFP510Function,"\n\noverride workgroup_size_x: u32 = 1;\noverride workgroup_size_y: u32 = 1;\noverride workgroup_size_z: u32 = 1;\n\n@compute @workgroup_size(workgroup_size_x, workgroup_size_y, workgroup_size_z)\nfn main(@builtin(global_invocation_id) global_id: vec3<u32>) {  \n  y[(global_id.x * args.dimension) + global_id.y] += bias[global_id.y];\n}\n\n").concat(emptyShader);var forwardSingleBitDepth1ShaderSource="\n\nstruct argsStruct {\n  n: u32,\n  nbr: u32,\n  total_nbc: u32,\n  bit_depth_nbc: u32,\n  x_offset: u32,\n  metas_offset: u32,\n  blocks_offset: u32,\n  y_offset: u32,\n};\n\n@group(0) @binding(0) \nvar<uniform> args: argsStruct;\n\n@group(0) @binding(1)\nvar<storage, read> x: array<vec4<f32>>;\n\n@group(0) @binding(2)\nvar<storage, read> metas: array<u32>;\n\n@group(0) @binding(3)\nvar<storage, read> blocks: array<u32>;\n\n@group(0) @binding(4)\nvar<storage, read_write> y: array<vec4<f32>>;\n\n".concat(fromFP510Function,"\n\nconst block_size: u32 = 4u;\n\noverride workgroup_size_x: u32 = 1;\noverride workgroup_size_y: u32 = 1;\noverride workgroup_size_z: u32 = 1;\n\n@compute @workgroup_size(workgroup_size_x, workgroup_size_y, workgroup_size_z)\nfn main(@builtin(global_invocation_id) global_id: vec3<u32>) {\n  if (global_id.x >= (args.nbr * 4) || global_id.y >= args.bit_depth_nbc) {\n    return;\n  }\n\n  let r = global_id.x * 4u;\n  let c = global_id.y * ").concat(columnsPerBlock,";\n  let br = global_id.x / 4u;  \n  let bc = global_id.y;\n  let br_offset = global_id.x % 4u;\n  \n  let row_metas_start: u32 = args.metas_offset + (br * args.bit_depth_nbc);\n  let row_blocks_start: u32 = args.blocks_offset + (br * args.bit_depth_nbc * block_size);  \n  \n  let alpha = from_fp510(extractBits(metas[row_metas_start + bc], 0, 16u));        \n  let beta = from_fp510(extractBits(metas[row_metas_start + bc], 16u, 16u));\n  \n  let x_start = ((args.x_offset + c) / 4u);\n   \n  var b0_start = row_blocks_start + br_offset + (bc * block_size);\n  var b0_offset = 0u;\n  \n  var res: array<vec4<f32>, 2u>;\n  var x_sum: f32 = 0.0;\n  \n  for (var j = 0u; j < ").concat(columnsPerBlock,"; j+=4) {\n    \n    var b0 = blocks[b0_start];\n    \n    let w0_0 = f32(extractBits(b0, b0_offset + j, 1u));    \n    let w0_1 = f32(extractBits(b0, b0_offset + j + 1, 1u));    \n    let w0_2 = f32(extractBits(b0, b0_offset + j + 2, 1u));\n    let w0_3 = f32(extractBits(b0, b0_offset + j + 3, 1u));\n        \n    b0_offset = 8u;\n    \n    let w1_0 = f32(extractBits(b0, b0_offset + j, 1u));    \n    let w1_1 = f32(extractBits(b0, b0_offset + j + 1, 1u));    \n    let w1_2 = f32(extractBits(b0, b0_offset + j + 2, 1u));\n    let w1_3 = f32(extractBits(b0, b0_offset + j + 3, 1u));\n        \n    b0_offset = 16u;\n    \n    let w2_0 = f32(extractBits(b0, b0_offset + j, 1u));    \n    let w2_1 = f32(extractBits(b0, b0_offset + j + 1, 1u));    \n    let w2_2 = f32(extractBits(b0, b0_offset + j + 2, 1u));\n    let w2_3 = f32(extractBits(b0, b0_offset + j + 3, 1u));\n        \n    b0_offset = 24u;\n    \n    let w3_0 = f32(extractBits(b0, b0_offset + j, 1u));    \n    let w3_1 = f32(extractBits(b0, b0_offset + j + 1, 1u));    \n    let w3_2 = f32(extractBits(b0, b0_offset + j + 2, 1u));\n    let w3_3 = f32(extractBits(b0, b0_offset + j + 3, 1u));\n    \n    b0_offset = 0u;\n    \n    let m = mat4x4(\n      w0_0, w1_0, w2_0, w3_0,\n      w0_1, w1_1, w2_1, w3_1, \n      w0_2, w1_2, w2_2, w3_2,\n      w0_3, w1_3, w2_3, w3_3);\n\n    let x_idx = (j / 4u);\n    let x_vec = x[x_start + x_idx];\n    res[x_idx] = m * x_vec;\n    \n    x_sum += x_vec.x + x_vec.y + x_vec.z + x_vec.w;      \n  }\n  \n  let swx = res[0] + res[1];\n  let kappa = alpha * x_sum;\n    \n  let y_start = (args.y_offset + (r * args.total_nbc)) / 4u;\n  y[y_start + bc] += (swx * beta) + vec4(kappa);\n}\n\n").concat(emptyShader);var forwardSingleBitDepth2ShaderSource="\n\nstruct argsStruct {\n  n: u32,\n  nbr: u32,\n  total_nbc: u32,\n  bit_depth_nbc: u32,\n  x_offset: u32,\n  metas_offset: u32,\n  blocks_offset: u32,\n  y_offset: u32,\n};\n\n@group(0) @binding(0) \nvar<uniform> args: argsStruct;\n\n@group(0) @binding(1)\nvar<storage, read> x: array<vec4<f32>>;\n\n@group(0) @binding(2)\nvar<storage, read> metas: array<u32>;\n\n@group(0) @binding(3)\nvar<storage, read> blocks: array<u32>;\n\n@group(0) @binding(4)\nvar<storage, read_write> y: array<vec4<f32>>;\n\n".concat(fromFP510Function,"\n\nconst block_size: u32 = 8u;\n\noverride workgroup_size_x: u32 = 1;\noverride workgroup_size_y: u32 = 1;\noverride workgroup_size_z: u32 = 1;\n\n@compute @workgroup_size(workgroup_size_x, workgroup_size_y, workgroup_size_z)\nfn main(@builtin(global_invocation_id) global_id: vec3<u32>) {\n  if (global_id.x >= (args.nbr * 4) || global_id.y >= args.bit_depth_nbc) {\n    return;\n  }\n\n  let r = global_id.x * 4u;\n  let c = global_id.y * ").concat(columnsPerBlock,";\n  let br = global_id.x / 4u;  \n  let bc = global_id.y;\n  let br_offset = global_id.x % 4u;\n  \n  let row_metas_start: u32 = args.metas_offset + (br * args.bit_depth_nbc);\n  let row_blocks_start: u32 = args.blocks_offset + (br * args.bit_depth_nbc * block_size);  \n  \n  let alpha = from_fp510(extractBits(metas[row_metas_start + bc], 0, 16u));        \n  let beta = from_fp510(extractBits(metas[row_metas_start + bc], 16u, 16u));\n  \n  let x_start = ((args.x_offset + c) / 4u);\n   \n  var b01_start = row_blocks_start + (br_offset * 2u) + (bc * block_size);\n  var b01_offset = 0u;\n  \n  var res: array<vec4<f32>, 2u>;\n  var x_sum: f32 = 0.0;\n  \n  for (var j = 0u; j < ").concat(columnsPerBlock,"; j+=4) {\n    \n    var b01 = blocks[b01_start];\n    \n    let w0_0 = f32(extractBits(b01, b01_offset + (2u * j), 2u));    \n    let w0_1 = f32(extractBits(b01, b01_offset + (2u * (j + 1)), 2u));    \n    let w0_2 = f32(extractBits(b01, b01_offset + (2u * (j + 2)), 2u));\n    let w0_3 = f32(extractBits(b01, b01_offset + (2u * (j + 3)), 2u));\n        \n    b01_offset = 16u;\n    \n    let w1_0 = f32(extractBits(b01, b01_offset + (2u * j), 2u));    \n    let w1_1 = f32(extractBits(b01, b01_offset + (2u * (j + 1)), 2u));    \n    let w1_2 = f32(extractBits(b01, b01_offset + (2u * (j + 2)), 2u));\n    let w1_3 = f32(extractBits(b01, b01_offset + (2u * (j + 3)), 2u));\n        \n    b01_offset = 0u;    \n    b01 = blocks[b01_start + 1u];\n    \n    let w2_0 = f32(extractBits(b01, b01_offset + (2u * j), 2u));    \n    let w2_1 = f32(extractBits(b01, b01_offset + (2u * (j + 1)), 2u));    \n    let w2_2 = f32(extractBits(b01, b01_offset + (2u * (j + 2)), 2u));\n    let w2_3 = f32(extractBits(b01, b01_offset + (2u * (j + 3)), 2u));\n        \n    b01_offset = 16u;\n    \n    let w3_0 = f32(extractBits(b01, b01_offset + (2u * j), 2u));    \n    let w3_1 = f32(extractBits(b01, b01_offset + (2u * (j + 1)), 2u));    \n    let w3_2 = f32(extractBits(b01, b01_offset + (2u * (j + 2)), 2u));\n    let w3_3 = f32(extractBits(b01, b01_offset + (2u * (j + 3)), 2u));\n    \n    b01_offset = 0u;\n    \n    let m = mat4x4(\n      w0_0, w1_0, w2_0, w3_0,\n      w0_1, w1_1, w2_1, w3_1, \n      w0_2, w1_2, w2_2, w3_2,\n      w0_3, w1_3, w2_3, w3_3);\n\n    let x_idx = (j / 4u);\n    let x_vec = x[x_start + x_idx];\n    res[x_idx] = m * x_vec;\n    \n    x_sum += x_vec.x + x_vec.y + x_vec.z + x_vec.w;      \n  }\n  \n  let swx = res[0] + res[1];\n  let kappa = alpha * x_sum;\n    \n  let y_start = (args.y_offset + (r * args.total_nbc)) / 4u;\n  y[y_start + bc] += (swx * beta) + vec4(kappa);\n}\n\n").concat(emptyShader);var forwardSingleBitDepth3ShaderSource="\n\nstruct argsStruct {\n  n: u32,\n  nbr: u32,\n  total_nbc: u32,\n  bit_depth_nbc: u32,\n  x_offset: u32,\n  metas_offset: u32,\n  blocks_offset: u32,\n  y_offset: u32,\n};\n\n@group(0) @binding(0) \nvar<uniform> args: argsStruct;\n\n@group(0) @binding(1)\nvar<storage, read> x: array<vec4<f32>>;\n\n@group(0) @binding(2)\nvar<storage, read> metas: array<u32>;\n\n@group(0) @binding(3)\nvar<storage, read> blocks: array<u32>;\n\n@group(0) @binding(4)\nvar<storage, read_write> y: array<vec4<f32>>;\n\n".concat(fromFP510Function,"\n\nconst block_size: u32 = 12u;\n\noverride workgroup_size_x: u32 = 1;\noverride workgroup_size_y: u32 = 1;\noverride workgroup_size_z: u32 = 1;\n\n@compute @workgroup_size(workgroup_size_x, workgroup_size_y, workgroup_size_z)\nfn main(@builtin(global_invocation_id) global_id : vec3<u32>) {\n  if (global_id.x >= (args.nbr * 4) || global_id.y >= args.bit_depth_nbc) {\n    return;\n  }\n  \n  let r = global_id.x * 4u;\n  let c = global_id.y * ").concat(columnsPerBlock,";\n  let br = global_id.x / 4u;  \n  let bc = global_id.y;\n  let br_offset = global_id.x % 4u;\n    \n  let row_metas_start: u32 = args.metas_offset + (br * args.bit_depth_nbc);\n  let row_blocks_start: u32 = args.blocks_offset + (br * args.bit_depth_nbc * block_size);  \n    \n  let alpha = from_fp510(extractBits(metas[row_metas_start + bc], 0, 16u));        \n  let beta = from_fp510(extractBits(metas[row_metas_start + bc], 16u, 16u));\n\n  let x_start = ((args.x_offset + c) / 4u);\n  \n  var b01_start = row_blocks_start + (br_offset * 2u) + (bc * block_size);\n  var b2_start = row_blocks_start + br_offset + (bc * block_size) + 8u;\n  var b01_offset = 0u;\n  var b2_offset = 0u;\n\n  var res: array<vec4<f32>, 2u>;\n  var x_sum: f32 = 0.0;\n  \n  for (var j = 0u; j < ").concat(columnsPerBlock,"; j+=4) {    \n         \n    var b01 = blocks[b01_start];\n    var b2 = blocks[b2_start];\n    \n    var b01_bits = extractBits(b01, b01_offset + (2u * j), 2u);\n    var b2_bit = extractBits(b2, b2_offset + j, 1u);\n    let w0_0 = f32(insertBits(b01_bits, b2_bit, 2u, 1u));\n    \n    b01_bits = extractBits(b01, b01_offset + (2u * (j + 1)), 2u);\n    b2_bit = extractBits(b2, b2_offset + (j + 1), 1u);\n    let w0_1 = f32(insertBits(b01_bits, b2_bit, 2u, 1u));\n    \n    b01_bits = extractBits(b01, b01_offset + (2u * (j + 2)), 2u);\n    b2_bit = extractBits(b2, b2_offset + (j + 2), 1u);\n    let w0_2 = f32(insertBits(b01_bits, b2_bit, 2u, 1u));\n    \n    b01_bits = extractBits(b01, b01_offset + (2u * (j + 3)), 2u);\n    b2_bit = extractBits(b2, b2_offset + (j + 3), 1u);\n    let w0_3 = f32(insertBits(b01_bits, b2_bit, 2u, 1u));\n        \n    b01_offset = 16u;\n    b2_offset = 8u;\n        \n    b01_bits = extractBits(b01, b01_offset + (2u * j), 2u);\n    b2_bit = extractBits(b2, b2_offset + j, 1u);    \n    let w1_0 = f32(insertBits(b01_bits, b2_bit, 2u, 1u));\n    \n    b01_bits = extractBits(b01, b01_offset + (2u * (j + 1)), 2u);\n    b2_bit = extractBits(b2, b2_offset + (j + 1), 1u);\n    let w1_1 = f32(insertBits(b01_bits, b2_bit, 2u, 1u));\n    \n    b01_bits = extractBits(b01, b01_offset + (2u * (j + 2)), 2u);\n    b2_bit = extractBits(b2, b2_offset + (j + 2), 1u);\n    let w1_2 = f32(insertBits(b01_bits, b2_bit, 2u, 1u));\n    \n    b01_bits = extractBits(b01, b01_offset + (2u * (j + 3)), 2u);\n    b2_bit = extractBits(b2, b2_offset + (j + 3), 1u);\n    let w1_3 = f32(insertBits(b01_bits, b2_bit, 2u, 1u));\n            \n    b01_offset = 0u;\n    b2_offset = 16u;  \n    b01 = blocks[b01_start + 1u];\n    \n    b01_bits = extractBits(b01, b01_offset + (2u * j), 2u);\n    b2_bit = extractBits(b2, b2_offset + j, 1u);    \n    let w2_0 = f32(insertBits(b01_bits, b2_bit, 2u, 1u));\n    \n    b01_bits = extractBits(b01, b01_offset + (2u * (j + 1)), 2u);\n    b2_bit = extractBits(b2, b2_offset + (j + 1), 1u);\n    let w2_1 = f32(insertBits(b01_bits, b2_bit, 2u, 1u));\n    \n    b01_bits = extractBits(b01, b01_offset + (2u * (j + 2)), 2u);\n    b2_bit = extractBits(b2, b2_offset + (j + 2), 1u);\n    let w2_2 = f32(insertBits(b01_bits, b2_bit, 2u, 1u));\n    \n    b01_bits = extractBits(b01, b01_offset + (2u * (j + 3)), 2u);\n    b2_bit = extractBits(b2, b2_offset + (j + 3), 1u);\n    let w2_3 = f32(insertBits(b01_bits, b2_bit, 2u, 1u));\n        \n    b01_offset = 16u;\n    b2_offset = 24u;      \n    \n    b01_bits = extractBits(b01, b01_offset + (2u * j), 2u);\n    b2_bit = extractBits(b2, b2_offset + j, 1u);    \n    let w3_0 = f32(insertBits(b01_bits, b2_bit, 2u, 1u));\n    \n    b01_bits = extractBits(b01, b01_offset + (2u * (j + 1)), 2u);\n    b2_bit = extractBits(b2, b2_offset + (j + 1), 1u);\n    let w3_1 = f32(insertBits(b01_bits, b2_bit, 2u, 1u));\n    \n    b01_bits = extractBits(b01, b01_offset + (2u * (j + 2)), 2u);\n    b2_bit = extractBits(b2, b2_offset + (j + 2), 1u);\n    let w3_2 = f32(insertBits(b01_bits, b2_bit, 2u, 1u));\n    \n    b01_bits = extractBits(b01, b01_offset + (2u * (j + 3)), 2u);\n    b2_bit = extractBits(b2, b2_offset + (j + 3), 1u);\n    let w3_3 = f32(insertBits(b01_bits, b2_bit, 2u, 1u));\n    \n    b01_offset = 0u;\n    b2_offset = 0u; \n    \n    let m = mat4x4(\n      w0_0, w1_0, w2_0, w3_0,\n      w0_1, w1_1, w2_1, w3_1, \n      w0_2, w1_2, w2_2, w3_2,\n      w0_3, w1_3, w2_3, w3_3);\n      \n    let x_idx = (j / 4u);\n    let x_vec = x[x_start + x_idx];\n    res[x_idx] = m * x_vec;\n    \n    x_sum += x_vec.x + x_vec.y + x_vec.z + x_vec.w;\n  }\n\n  let swx = res[0] + res[1];\n  let kappa = alpha * x_sum;\n    \n  let y_start = (args.y_offset + (r * args.total_nbc)) / 4u;\n  y[y_start + bc] += (swx * beta) + vec4(kappa);\n}\n\n").concat(emptyShader);var forwardSingleBitDepth4ShaderSource="\n\nstruct argsStruct {\n  n: u32,\n  nbr: u32,\n  total_nbc: u32,\n  bit_depth_nbc: u32,\n  x_offset: u32,\n  metas_offset: u32,\n  blocks_offset: u32,\n  y_offset: u32,\n};\n\n@group(0) @binding(0) \nvar<uniform> args: argsStruct;\n\n@group(0) @binding(1)\nvar<storage, read> x: array<vec4<f32>>;\n\n@group(0) @binding(2)\nvar<storage, read> metas: array<u32>;\n\n@group(0) @binding(3)\nvar<storage, read> blocks: array<u32>;\n\n@group(0) @binding(4)\nvar<storage, read_write> y: array<vec4<f32>>;\n\n".concat(fromFP510Function,"\n\nconst block_size: u32 = 16u;\n\noverride workgroup_size_x: u32 = 1;\noverride workgroup_size_y: u32 = 1;\noverride workgroup_size_z: u32 = 1;\n\n@compute @workgroup_size(workgroup_size_x, workgroup_size_y, workgroup_size_z)\nfn main(@builtin(global_invocation_id) global_id: vec3<u32>) {\n  if (global_id.x >= (args.nbr * 4) || global_id.y >= args.bit_depth_nbc) {\n    return;\n  }\n  \n  let r = global_id.x * 4u;\n  let c = global_id.y * ").concat(columnsPerBlock,";\n  let br = global_id.x / 4u;  \n  let bc = global_id.y;\n  let br_offset = global_id.x % 4u;\n  \n  let row_metas_start: u32 = args.metas_offset + (br * args.bit_depth_nbc);\n  let row_blocks_start: u32 = args.blocks_offset + (br * args.bit_depth_nbc * block_size);  \n    \n  let alpha = from_fp510(extractBits(metas[row_metas_start + bc], 0, 16u));        \n  let beta = from_fp510(extractBits(metas[row_metas_start + bc], 16u, 16u));\n \n  let x_start = ((args.x_offset + c) / 4u);\n  \n  var b03_start = row_blocks_start + (br_offset * 4u) + (bc * block_size);    \n\n  var res: array<vec4<f32>, 2u>;\n  var x_sum: f32 = 0.0;\n\n  for (var j = 0u; j < ").concat(columnsPerBlock,"; j+=4) {\n  \n    var b03 = blocks[b03_start];        \n    \n    let w0_0 = f32(extractBits(b03, 4u * j, 4u));    \n    let w0_1 = f32(extractBits(b03, 4u * (j + 1), 4u));    \n    let w0_2 = f32(extractBits(b03, 4u * (j + 2), 4u));\n    let w0_3 = f32(extractBits(b03, 4u * (j + 3), 4u));\n    \n    b03 = blocks[b03_start + 1];\n    \n    let w1_0 = f32(extractBits(b03, 4u * j, 4u));    \n    let w1_1 = f32(extractBits(b03, 4u * (j + 1), 4u));    \n    let w1_2 = f32(extractBits(b03, 4u * (j + 2), 4u));\n    let w1_3 = f32(extractBits(b03, 4u * (j + 3), 4u));\n    \n    b03 = blocks[b03_start + 2];\n    \n    let w2_0 = f32(extractBits(b03, 4u * j, 4u));    \n    let w2_1 = f32(extractBits(b03, 4u * (j + 1), 4u));    \n    let w2_2 = f32(extractBits(b03, 4u * (j + 2), 4u));\n    let w2_3 = f32(extractBits(b03, 4u * (j + 3), 4u));\n    \n    b03 = blocks[b03_start + 3];\n    \n    let w3_0 = f32(extractBits(b03, 4u * j, 4u));    \n    let w3_1 = f32(extractBits(b03, 4u * (j + 1), 4u));    \n    let w3_2 = f32(extractBits(b03, 4u * (j + 2), 4u));\n    let w3_3 = f32(extractBits(b03, 4u * (j + 3), 4u));\n    \n    let m = mat4x4(\n      w0_0, w1_0, w2_0, w3_0,\n      w0_1, w1_1, w2_1, w3_1, \n      w0_2, w1_2, w2_2, w3_2,\n      w0_3, w1_3, w2_3, w3_3);\n\n    let x_idx = (j / 4u);\n    let x_vec = x[x_start + x_idx];\n    res[x_idx] = m * x_vec;\n    \n    x_sum += x_vec.x + x_vec.y + x_vec.z + x_vec.w;\n  }\n  let swx = res[0] + res[1];\n  let kappa = alpha * x_sum;\n    \n  let y_start = (args.y_offset + (r * args.total_nbc)) / 4u;\n  y[y_start + bc] += (swx * beta) + vec4(kappa);\n}\n\n").concat(emptyShader);var forwardSingleBitDepth5ShaderSource="\n\nstruct argsStruct {\n  n: u32,\n  nbr: u32,\n  total_nbc: u32,\n  bit_depth_nbc: u32,\n  x_offset: u32,\n  metas_offset: u32,\n  blocks_offset: u32,\n  y_offset: u32,\n};\n\n@group(0) @binding(0) \nvar<uniform> args: argsStruct;\n\n@group(0) @binding(1)\nvar<storage, read> x: array<vec4<f32>>;\n\n@group(0) @binding(2)\nvar<storage, read> metas: array<u32>;\n\n@group(0) @binding(3)\nvar<storage, read> blocks: array<u32>;\n\n@group(0) @binding(4)\nvar<storage, read_write> y: array<vec4<f32>>;\n\n".concat(fromFP510Function,"\n\nconst block_size: u32 = 20u;\n\noverride workgroup_size_x: u32 = 1;\noverride workgroup_size_y: u32 = 1;\noverride workgroup_size_z: u32 = 1;\n\n@compute @workgroup_size(workgroup_size_x, workgroup_size_y, workgroup_size_z)\nfn main(@builtin(global_invocation_id) global_id: vec3<u32>) {\n  if (global_id.x >= (args.nbr * 4) || global_id.y >= args.bit_depth_nbc) {\n    return;\n  }\n  \n  let r = global_id.x * 4u;\n  let c = global_id.y * ").concat(columnsPerBlock,";\n  let br = global_id.x / 4u;  \n  let bc = global_id.y;\n  let br_offset = global_id.x % 4u;\n  \n  let row_metas_start: u32 = args.metas_offset + (br * args.bit_depth_nbc);\n  let row_blocks_start: u32 = args.blocks_offset + (br * args.bit_depth_nbc * block_size);  \n    \n  let alpha = from_fp510(extractBits(metas[row_metas_start + bc], 0, 16u));        \n  let beta = from_fp510(extractBits(metas[row_metas_start + bc], 16u, 16u));\n \n  let x_start = ((args.x_offset + c) / 4u);\n  \n  var b03_start = row_blocks_start + (br_offset * 4u) + (bc * block_size);\n  var b4_start = row_blocks_start + br_offset + (bc * block_size) + 16u;\n  \n  var b4_offset = 0u;\n  \n  var res: array<vec4<f32>, 2u>;\n  var x_sum: f32 = 0.0;\n  \n  for (var j = 0u; j < ").concat(columnsPerBlock,"; j+=4) {\n  \n    var b03 = blocks[b03_start];\n    var b4 = blocks[b4_start];\n    \n    var b03_bits = extractBits(b03, 4u * j, 4u);\n    var b4_bit = extractBits(b4, b4_offset + j, 1u);    \n    let w0_0 = f32(insertBits(b03_bits, b4_bit, 4u, 1u));\n    \n    b03_bits = extractBits(b03, 4u * (j + 1), 4u);\n    b4_bit = extractBits(b4, b4_offset + (j + 1), 1u);\n    let w0_1 = f32(insertBits(b03_bits, b4_bit, 4u, 1u));\n    \n    b03_bits = extractBits(b03, 4u * (j + 2), 4u);\n    b4_bit = extractBits(b4, b4_offset + (j + 2), 1u);\n    let w0_2 = f32(insertBits(b03_bits, b4_bit, 4u, 1u));\n    \n    b03_bits = extractBits(b03, 4u * (j + 3), 4u);\n    b4_bit = extractBits(b4, b4_offset + (j + 3), 1u);\n    let w0_3 = f32(insertBits(b03_bits, b4_bit, 4u, 1u));\n    \n    b03 = blocks[b03_start + 1];\n    b4_offset = 8u;\n    \n    b03_bits = extractBits(b03, 4u * j, 4u);\n    b4_bit = extractBits(b4, b4_offset + j, 1u);    \n    let w1_0 = f32(insertBits(b03_bits, b4_bit, 4u, 1u));\n    \n    b03_bits = extractBits(b03, 4u * (j + 1), 4u);\n    b4_bit = extractBits(b4, b4_offset + (j + 1), 1u);\n    let w1_1 = f32(insertBits(b03_bits, b4_bit, 4u, 1u));\n    \n    b03_bits = extractBits(b03, 4u * (j + 2), 4u);\n    b4_bit = extractBits(b4, b4_offset + (j + 2), 1u);\n    let w1_2 = f32(insertBits(b03_bits, b4_bit, 4u, 1u));\n    \n    b03_bits = extractBits(b03, 4u * (j + 3), 4u);\n    b4_bit = extractBits(b4, b4_offset + (j + 3), 1u);\n    let w1_3 = f32(insertBits(b03_bits, b4_bit, 4u, 1u));\n    \n    b03 = blocks[b03_start + 2];\n    b4_offset = 16u;\n    \n    b03_bits = extractBits(b03, 4u * j, 4u);\n    b4_bit = extractBits(b4, b4_offset + j, 1u);    \n    let w2_0 = f32(insertBits(b03_bits, b4_bit, 4u, 1u));\n    \n    b03_bits = extractBits(b03, 4u * (j + 1), 4u);\n    b4_bit = extractBits(b4, b4_offset + (j + 1), 1u);\n    let w2_1 = f32(insertBits(b03_bits, b4_bit, 4u, 1u));\n    \n    b03_bits = extractBits(b03, 4u * (j + 2), 4u);\n    b4_bit = extractBits(b4, b4_offset + (j + 2), 1u);\n    let w2_2 = f32(insertBits(b03_bits, b4_bit, 4u, 1u));\n    \n    b03_bits = extractBits(b03, 4u * (j + 3), 4u);\n    b4_bit = extractBits(b4, b4_offset + (j + 3), 1u);\n    let w2_3 = f32(insertBits(b03_bits, b4_bit, 4u, 1u));\n    \n    b03 = blocks[b03_start + 3];\n    b4_offset = 24u;\n    \n    b03_bits = extractBits(b03, 4u * j, 4u);\n    b4_bit = extractBits(b4, b4_offset + j, 1u);    \n    let w3_0 = f32(insertBits(b03_bits, b4_bit, 4u, 1u));\n    \n    b03_bits = extractBits(b03, 4u * (j + 1), 4u);\n    b4_bit = extractBits(b4, b4_offset + (j + 1), 1u);\n    let w3_1 = f32(insertBits(b03_bits, b4_bit, 4u, 1u));\n    \n    b03_bits = extractBits(b03, 4u * (j + 2), 4u);\n    b4_bit = extractBits(b4, b4_offset + (j + 2), 1u);\n    let w3_2 = f32(insertBits(b03_bits, b4_bit, 4u, 1u));\n    \n    b03_bits = extractBits(b03, 4u * (j + 3), 4u);\n    b4_bit = extractBits(b4, b4_offset + (j + 3), 1u);\n    let w3_3 = f32(insertBits(b03_bits, b4_bit, 4u, 1u));\n    \n    b4_offset = 0u;\n    \n    let m = mat4x4(\n      w0_0, w1_0, w2_0, w3_0,\n      w0_1, w1_1, w2_1, w3_1, \n      w0_2, w1_2, w2_2, w3_2,\n      w0_3, w1_3, w2_3, w3_3);\n\n    let x_idx = (j / 4u);\n    let x_vec = x[x_start + x_idx];\n    res[x_idx] = m * x_vec;\n    \n    x_sum += x_vec.x + x_vec.y + x_vec.z + x_vec.w;\n  }\n  let swx = res[0] + res[1];\n  let kappa = alpha * x_sum;\n    \n  let y_start = (args.y_offset + (r * args.total_nbc)) / 4u;\n  y[y_start + bc] += (swx * beta) + vec4(kappa);\n}\n\n").concat(emptyShader);var forwardSingleBitDepth6ShaderSource="\n\nstruct argsStruct {\n  n: u32,\n  nbr: u32,\n  total_nbc: u32,\n  bit_depth_nbc: u32,\n  x_offset: u32,\n  metas_offset: u32,\n  blocks_offset: u32,\n  y_offset: u32,\n};\n\n@group(0) @binding(0) \nvar<uniform> args: argsStruct;\n\n@group(0) @binding(1)\nvar<storage, read> x: array<vec4<f32>>;\n\n@group(0) @binding(2)\nvar<storage, read> metas: array<u32>;\n\n@group(0) @binding(3)\nvar<storage, read> blocks: array<u32>;\n\n@group(0) @binding(4)\nvar<storage, read_write> y: array<vec4<f32>>;\n\n".concat(fromFP510Function,"\n\nconst block_size: u32 = 24u;\n\noverride workgroup_size_x: u32 = 1;\noverride workgroup_size_y: u32 = 1;\noverride workgroup_size_z: u32 = 1;\n\n@compute @workgroup_size(workgroup_size_x, workgroup_size_y, workgroup_size_z)\nfn main(@builtin(global_invocation_id) global_id: vec3<u32>) {\n  if (global_id.x >= (args.nbr * 4) || global_id.y >= args.bit_depth_nbc) {\n    return;\n  }\n  \n  let r = global_id.x * 4u;\n  let c = global_id.y * ").concat(columnsPerBlock,";\n  let br = global_id.x / 4u;  \n  let bc = global_id.y;\n  let br_offset = global_id.x % 4u;\n  \n  let row_metas_start: u32 = args.metas_offset + (br * args.bit_depth_nbc);\n  let row_blocks_start: u32 = args.blocks_offset + (br * args.bit_depth_nbc * block_size);  \n    \n  let alpha = from_fp510(extractBits(metas[row_metas_start + bc], 0, 16u));        \n  let beta = from_fp510(extractBits(metas[row_metas_start + bc], 16u, 16u));\n \n  let x_start = ((args.x_offset + c) / 4u);\n  \n  var b03_start = row_blocks_start + (br_offset * 4u) + (bc * block_size);\n  var b45_start = row_blocks_start + (br_offset * 2u) + (bc * block_size) + 16u;\n  \n  var b45_offset = 0u;\n  \n  var res: array<vec4<f32>, 2u>;\n  var x_sum: f32 = 0.0;\n  \n  for (var j = 0u; j < ").concat(columnsPerBlock,"; j+=4) {\n  \n    var b03 = blocks[b03_start];\n    var b45 = blocks[b45_start];\n    \n    var b03_bits = extractBits(b03, 4u * j, 4u);\n    var b45_bits = extractBits(b45, b45_offset + (j * 2), 2u);\n    let w0_0 = f32(insertBits(b03_bits, b45_bits, 4u, 2u));\n    \n    b03_bits = extractBits(b03, 4u * (j + 1), 4u);\n    b45_bits = extractBits(b45, b45_offset + (2u * (j + 1)), 2u);\n    let w0_1 = f32(insertBits(b03_bits, b45_bits, 4u, 2u));\n    \n    b03_bits = extractBits(b03, 4u * (j + 2), 4u);\n    b45_bits = extractBits(b45, b45_offset + (2u * (j + 2)), 2u);\n    let w0_2 = f32(insertBits(b03_bits, b45_bits, 4u, 2u));\n    \n    b03_bits = extractBits(b03, 4u * (j + 3), 4u);\n    b45_bits = extractBits(b45, b45_offset + (2u * (j + 3)), 2u);\n    let w0_3 = f32(insertBits(b03_bits, b45_bits, 4u, 2u));\n    \n    b03 = blocks[b03_start + 1];\n    b45_offset = 16u;\n    \n    b03_bits = extractBits(b03, 4u * j, 4u);\n    b45_bits = extractBits(b45, b45_offset + (j * 2), 2u);\n    let w1_0 = f32(insertBits(b03_bits, b45_bits, 4u, 2u));\n    \n    b03_bits = extractBits(b03, 4u * (j + 1), 4u);\n    b45_bits = extractBits(b45, b45_offset + (2u * (j + 1)), 2u);\n    let w1_1 = f32(insertBits(b03_bits, b45_bits, 4u, 2u));\n    \n    b03_bits = extractBits(b03, 4u * (j + 2), 4u);\n    b45_bits = extractBits(b45, b45_offset + (2u * (j + 2)), 2u);\n    let w1_2 = f32(insertBits(b03_bits, b45_bits, 4u, 2u));\n    \n    b03_bits = extractBits(b03, 4u * (j + 3), 4u);\n    b45_bits = extractBits(b45, b45_offset + (2u * (j + 3)), 2u);\n    let w1_3 = f32(insertBits(b03_bits, b45_bits, 4u, 2u));  \n    \n    b03 = blocks[b03_start + 2];\n    b45 = blocks[b45_start + 1];\n    b45_offset = 0u;\n    \n    b03_bits = extractBits(b03, 4u * j, 4u);\n    b45_bits = extractBits(b45, b45_offset + (j * 2), 2u);\n    let w2_0 = f32(insertBits(b03_bits, b45_bits, 4u, 2u));\n    \n    b03_bits = extractBits(b03, 4u * (j + 1), 4u);\n    b45_bits = extractBits(b45, b45_offset + (2u * (j + 1)), 2u);\n    let w2_1 = f32(insertBits(b03_bits, b45_bits, 4u, 2u));\n    \n    b03_bits = extractBits(b03, 4u * (j + 2), 4u);\n    b45_bits = extractBits(b45, b45_offset + (2u * (j + 2)), 2u);\n    let w2_2 = f32(insertBits(b03_bits, b45_bits, 4u, 2u));\n    \n    b03_bits = extractBits(b03, 4u * (j + 3), 4u);\n    b45_bits = extractBits(b45, b45_offset + (2u * (j + 3)), 2u);\n    let w2_3 = f32(insertBits(b03_bits, b45_bits, 4u, 2u));\n    \n    b03 = blocks[b03_start + 3];\n    b45_offset = 16u;\n    \n    b03_bits = extractBits(b03, 4u * j, 4u);\n    b45_bits = extractBits(b45, b45_offset + (j * 2), 2u);\n    let w3_0 = f32(insertBits(b03_bits, b45_bits, 4u, 2u));\n    \n    b03_bits = extractBits(b03, 4u * (j + 1), 4u);\n    b45_bits = extractBits(b45, b45_offset + (2u * (j + 1)), 2u);\n    let w3_1 = f32(insertBits(b03_bits, b45_bits, 4u, 2u));\n    \n    b03_bits = extractBits(b03, 4u * (j + 2), 4u);\n    b45_bits = extractBits(b45, b45_offset + (2u * (j + 2)), 2u);\n    let w3_2 = f32(insertBits(b03_bits, b45_bits, 4u, 2u));\n    \n    b03_bits = extractBits(b03, 4u * (j + 3), 4u);\n    b45_bits = extractBits(b45, b45_offset + (2u * (j + 3)), 2u);\n    let w3_3 = f32(insertBits(b03_bits, b45_bits, 4u, 2u));\n    \n    b45_offset = 0u;\n    \n    let m = mat4x4(\n      w0_0, w1_0, w2_0, w3_0,\n      w0_1, w1_1, w2_1, w3_1, \n      w0_2, w1_2, w2_2, w3_2,\n      w0_3, w1_3, w2_3, w3_3);\n\n    let x_idx = (j / 4u);\n    let x_vec = x[x_start + x_idx];\n    res[x_idx] = m * x_vec;\n    \n    x_sum += x_vec.x + x_vec.y + x_vec.z + x_vec.w;\n  }\n  let swx = res[0] + res[1];\n  let kappa = alpha * x_sum;\n    \n  let y_start = (args.y_offset + (r * args.total_nbc)) / 4u;\n  y[y_start + bc] += (swx * beta) + vec4(kappa);\n}\n\n").concat(emptyShader);var forwardSingleBitDepth7ShaderSource="\n\nstruct argsStruct {\n  n: u32,\n  nbr: u32,\n  total_nbc: u32,\n  bit_depth_nbc: u32,\n  x_offset: u32,\n  metas_offset: u32,\n  blocks_offset: u32,\n  y_offset: u32,\n};\n\n@group(0) @binding(0) \nvar<uniform> args: argsStruct;\n\n@group(0) @binding(1)\nvar<storage, read> x: array<vec4<f32>>;\n\n@group(0) @binding(2)\nvar<storage, read> metas: array<u32>;\n\n@group(0) @binding(3)\nvar<storage, read> blocks: array<u32>;\n\n@group(0) @binding(4)\nvar<storage, read_write> y: array<vec4<f32>>;\n\n".concat(fromFP510Function,"\n\nconst block_size: u32 = 28u;\n\noverride workgroup_size_x: u32 = 1;\noverride workgroup_size_y: u32 = 1;\noverride workgroup_size_z: u32 = 1;\n\n@compute @workgroup_size(workgroup_size_x, workgroup_size_y, workgroup_size_z)\nfn main(@builtin(global_invocation_id) global_id: vec3<u32>) {\n  if (global_id.x >= (args.nbr * 4) || global_id.y >= args.bit_depth_nbc) {\n    return;\n  }\n  \n  let r = global_id.x * 4u;\n  let c = global_id.y * ").concat(columnsPerBlock,";\n  let br = global_id.x / 4u;  \n  let bc = global_id.y;\n  let br_offset = global_id.x % 4u;\n  \n  let row_metas_start: u32 = args.metas_offset + (br * args.bit_depth_nbc);\n  let row_blocks_start: u32 = args.blocks_offset + (br * args.bit_depth_nbc * block_size);  \n    \n  let alpha = from_fp510(extractBits(metas[row_metas_start + bc], 0, 16u));        \n  let beta = from_fp510(extractBits(metas[row_metas_start + bc], 16u, 16u));\n \n  let x_start = ((args.x_offset + c) / 4u);\n  \n  var b03_start = row_blocks_start + (br_offset * 4u) + (bc * block_size);\n  var b45_start = row_blocks_start + (br_offset * 2u) + (bc * block_size) + 16u;\n  var b6_start = row_blocks_start + br_offset + (bc * block_size) + 24u;\n  \n  var b45_offset = 0u;\n  var b6_offset = 0u;\n  \n  var res: array<vec4<f32>, 2u>;\n  var x_sum: f32 = 0.0;\n  \n  for (var j = 0u; j < ").concat(columnsPerBlock,"; j+=4) {\n  \n    var b03 = blocks[b03_start];\n    var b45 = blocks[b45_start];\n    var b6 = blocks[b6_start];\n    \n    var b03_bits = extractBits(b03, 4u * j, 4u);\n    var b45_bits = extractBits(b45, b45_offset + (j * 2), 2u);\n    var b6_bit = extractBits(b6, b6_offset + j, 1u);\n    let w0_0 = f32(insertBits(insertBits(b03_bits, b45_bits, 4u, 2u), b6_bit, 6u, 1u));\n    \n    b03_bits = extractBits(b03, 4u * (j + 1), 4u);\n    b45_bits = extractBits(b45, b45_offset + (2u * (j + 1)), 2u);\n    b6_bit = extractBits(b6, b6_offset + j + 1, 1u);\n    let w0_1 = f32(insertBits(insertBits(b03_bits, b45_bits, 4u, 2u), b6_bit, 6u, 1u));\n    \n    b03_bits = extractBits(b03, 4u * (j + 2), 4u);\n    b45_bits = extractBits(b45, b45_offset + (2u * (j + 2)), 2u);\n    b6_bit = extractBits(b6, b6_offset + j + 2, 1u);\n    let w0_2 = f32(insertBits(insertBits(b03_bits, b45_bits, 4u, 2u), b6_bit, 6u, 1u));    \n    \n    b03_bits = extractBits(b03, 4u * (j + 3), 4u);\n    b45_bits = extractBits(b45, b45_offset + (2u * (j + 3)), 2u);\n    b6_bit = extractBits(b6, b6_offset + j + 3, 1u);\n    let w0_3 = f32(insertBits(insertBits(b03_bits, b45_bits, 4u, 2u), b6_bit, 6u, 1u));\n    \n    b03 = blocks[b03_start + 1];\n    b45_offset = 16u;\n    b6_offset = 8u;\n    \n    b03_bits = extractBits(b03, 4u * j, 4u);\n    b45_bits = extractBits(b45, b45_offset + (j * 2), 2u);\n    b6_bit = extractBits(b6, b6_offset + j, 1u);\n    let w1_0 = f32(insertBits(insertBits(b03_bits, b45_bits, 4u, 2u), b6_bit, 6u, 1u));\n    \n    b03_bits = extractBits(b03, 4u * (j + 1), 4u);\n    b45_bits = extractBits(b45, b45_offset + (2u * (j + 1)), 2u);\n    b6_bit = extractBits(b6, b6_offset + j + 1, 1u);\n    let w1_1 = f32(insertBits(insertBits(b03_bits, b45_bits, 4u, 2u), b6_bit, 6u, 1u));\n    \n    b03_bits = extractBits(b03, 4u * (j + 2), 4u);\n    b45_bits = extractBits(b45, b45_offset + (2u * (j + 2)), 2u);\n    b6_bit = extractBits(b6, b6_offset + j + 2, 1u);\n    let w1_2 = f32(insertBits(insertBits(b03_bits, b45_bits, 4u, 2u), b6_bit, 6u, 1u));    \n    \n    b03_bits = extractBits(b03, 4u * (j + 3), 4u);\n    b45_bits = extractBits(b45, b45_offset + (2u * (j + 3)), 2u);\n    b6_bit = extractBits(b6, b6_offset + j + 3, 1u);\n    let w1_3 = f32(insertBits(insertBits(b03_bits, b45_bits, 4u, 2u), b6_bit, 6u, 1u));\n    \n    b03 = blocks[b03_start + 2];\n    b45 = blocks[b45_start + 1];\n    b45_offset = 0u;\n    b6_offset = 16u;\n\n    b03_bits = extractBits(b03, 4u * j, 4u);\n    b45_bits = extractBits(b45, b45_offset + (j * 2), 2u);\n    b6_bit = extractBits(b6, b6_offset + j, 1u);\n    let w2_0 = f32(insertBits(insertBits(b03_bits, b45_bits, 4u, 2u), b6_bit, 6u, 1u));\n    \n    b03_bits = extractBits(b03, 4u * (j + 1), 4u);\n    b45_bits = extractBits(b45, b45_offset + (2u * (j + 1)), 2u);\n    b6_bit = extractBits(b6, b6_offset + j + 1, 1u);\n    let w2_1 = f32(insertBits(insertBits(b03_bits, b45_bits, 4u, 2u), b6_bit, 6u, 1u));\n    \n    b03_bits = extractBits(b03, 4u * (j + 2), 4u);\n    b45_bits = extractBits(b45, b45_offset + (2u * (j + 2)), 2u);\n    b6_bit = extractBits(b6, b6_offset + j + 2, 1u);\n    let w2_2 = f32(insertBits(insertBits(b03_bits, b45_bits, 4u, 2u), b6_bit, 6u, 1u));    \n    \n    b03_bits = extractBits(b03, 4u * (j + 3), 4u);\n    b45_bits = extractBits(b45, b45_offset + (2u * (j + 3)), 2u);\n    b6_bit = extractBits(b6, b6_offset + j + 3, 1u);\n    let w2_3 = f32(insertBits(insertBits(b03_bits, b45_bits, 4u, 2u), b6_bit, 6u, 1u));\n    \n    b03 = blocks[b03_start + 3];\n    b45_offset = 16u;\n    b6_offset = 24u;\n    \n    b03_bits = extractBits(b03, 4u * j, 4u);\n    b45_bits = extractBits(b45, b45_offset + (j * 2), 2u);\n    b6_bit = extractBits(b6, b6_offset + j, 1u);\n    let w3_0 = f32(insertBits(insertBits(b03_bits, b45_bits, 4u, 2u), b6_bit, 6u, 1u));\n    \n    b03_bits = extractBits(b03, 4u * (j + 1), 4u);\n    b45_bits = extractBits(b45, b45_offset + (2u * (j + 1)), 2u);\n    b6_bit = extractBits(b6, b6_offset + j + 1, 1u);\n    let w3_1 = f32(insertBits(insertBits(b03_bits, b45_bits, 4u, 2u), b6_bit, 6u, 1u));\n    \n    b03_bits = extractBits(b03, 4u * (j + 2), 4u);\n    b45_bits = extractBits(b45, b45_offset + (2u * (j + 2)), 2u);\n    b6_bit = extractBits(b6, b6_offset + j + 2, 1u);\n    let w3_2 = f32(insertBits(insertBits(b03_bits, b45_bits, 4u, 2u), b6_bit, 6u, 1u));    \n    \n    b03_bits = extractBits(b03, 4u * (j + 3), 4u);\n    b45_bits = extractBits(b45, b45_offset + (2u * (j + 3)), 2u);\n    b6_bit = extractBits(b6, b6_offset + j + 3, 1u);\n    let w3_3 = f32(insertBits(insertBits(b03_bits, b45_bits, 4u, 2u), b6_bit, 6u, 1u));\n    \n    b45_offset = 0u;\n    b6_offset = 0u;\n    \n    let m = mat4x4(\n      w0_0, w1_0, w2_0, w3_0,\n      w0_1, w1_1, w2_1, w3_1, \n      w0_2, w1_2, w2_2, w3_2,\n      w0_3, w1_3, w2_3, w3_3);\n\n    let x_idx = (j / 4u);\n    let x_vec = x[x_start + x_idx];\n    res[x_idx] = m * x_vec;\n    \n    x_sum += x_vec.x + x_vec.y + x_vec.z + x_vec.w;\n  }\n\n  let swx = res[0] + res[1];\n  let kappa = alpha * x_sum;\n    \n  let y_start = (args.y_offset + (r * args.total_nbc)) / 4u;\n  y[y_start + bc] += (swx * beta) + vec4(kappa);\n}\n\n").concat(emptyShader);var forwardSingleBitDepth8ShaderSource="\n\nstruct argsStruct {\n  n: u32,\n  nbr: u32,\n  total_nbc: u32,\n  bit_depth_nbc: u32,\n  x_offset: u32,\n  metas_offset: u32,\n  blocks_offset: u32,\n  y_offset: u32,\n};\n\n@group(0) @binding(0) \nvar<uniform> args: argsStruct;\n\n@group(0) @binding(1)\nvar<storage, read> x: array<vec4<f32>>;\n\n@group(0) @binding(2)\nvar<storage, read> metas: array<u32>;\n\n@group(0) @binding(3)\nvar<storage, read> blocks: array<u32>;\n\n@group(0) @binding(4)\nvar<storage, read_write> y: array<vec4<f32>>;\n\n".concat(fromFP510Function,"\n\nconst block_size: u32 = 32u;\n\noverride workgroup_size_x: u32 = 1;\noverride workgroup_size_y: u32 = 1;\noverride workgroup_size_z: u32 = 1;\n\n@compute @workgroup_size(workgroup_size_x, workgroup_size_y, workgroup_size_z)\nfn main(@builtin(global_invocation_id) global_id: vec3<u32>) {\n  if (global_id.x >= (args.nbr * 4) || global_id.y >= args.bit_depth_nbc) {\n    return;\n  }\n  \n  let r = global_id.x * 4u;\n  let c = global_id.y * ").concat(columnsPerBlock,";\n  let br = global_id.x / 4u;  \n  let bc = global_id.y;\n  let br_offset = global_id.x % 4u;\n  \n  let row_metas_start: u32 = args.metas_offset + (br * args.bit_depth_nbc);\n  let row_blocks_start: u32 = args.blocks_offset + (br * args.bit_depth_nbc * block_size);  \n    \n  let alpha = from_fp510(extractBits(metas[row_metas_start + bc], 0, 16u));        \n  let beta = from_fp510(extractBits(metas[row_metas_start + bc], 16u, 16u));\n \n  let x_start = ((args.x_offset + c) / 4u);\n  \n  var b07_start = row_blocks_start + (br_offset * 8u) + (bc * block_size);    \n\n  var res: array<vec4<f32>, 2u>;\n  var x_sum: f32 = 0.0;\n\n  for (var j = 0u; j < 2; j++) {\n      \n    var b07 = blocks[b07_start + j];\n    \n    let w0_0 = f32(extractBits(b07, 0u, 8u));    \n    let w0_1 = f32(extractBits(b07, 8u, 8u));    \n    let w0_2 = f32(extractBits(b07, 16u, 8u));\n    let w0_3 = f32(extractBits(b07, 24u, 8u));\n    \n    b07 = blocks[b07_start + 2 + j];\n    \n    let w1_0 = f32(extractBits(b07, 0u, 8u));    \n    let w1_1 = f32(extractBits(b07, 8u, 8u));    \n    let w1_2 = f32(extractBits(b07, 16u, 8u));\n    let w1_3 = f32(extractBits(b07, 24u, 8u));\n    \n    b07 = blocks[b07_start + 4 + j];\n    \n    let w2_0 = f32(extractBits(b07, 0u, 8u));    \n    let w2_1 = f32(extractBits(b07, 8u, 8u));    \n    let w2_2 = f32(extractBits(b07, 16u, 8u));\n    let w2_3 = f32(extractBits(b07, 24u, 8u));\n    \n    b07 = blocks[b07_start + 6 + j];\n    \n    let w3_0 = f32(extractBits(b07, 0u, 8u));    \n    let w3_1 = f32(extractBits(b07, 8u, 8u));    \n    let w3_2 = f32(extractBits(b07, 16u, 8u));\n    let w3_3 = f32(extractBits(b07, 24u, 8u));\n    \n    let m = mat4x4(\n      w0_0, w1_0, w2_0, w3_0,\n      w0_1, w1_1, w2_1, w3_1, \n      w0_2, w1_2, w2_2, w3_2,\n      w0_3, w1_3, w2_3, w3_3);\n\n    let x_vec = x[x_start + j];\n    res[j] = m * x_vec;\n    \n    x_sum += x_vec.x + x_vec.y + x_vec.z + x_vec.w;\n  }\n  let swx = res[0] + res[1];\n  let kappa = alpha * x_sum;\n    \n  let y_start = (args.y_offset + (r * args.total_nbc)) / 4u;\n  y[y_start + bc] += (swx * beta) + vec4(kappa);\n}\n\n").concat(emptyShader);var forwardSingleShaderSources={1:forwardSingleBitDepth1ShaderSource,2:forwardSingleBitDepth2ShaderSource,3:forwardSingleBitDepth3ShaderSource,4:forwardSingleBitDepth4ShaderSource,5:forwardSingleBitDepth5ShaderSource,6:forwardSingleBitDepth6ShaderSource,7:forwardSingleBitDepth7ShaderSource,8:forwardSingleBitDepth8ShaderSource};var forwardSingleShaderNames={1:"pv_picollm_weight_block_mixed_16x8_forward_single_bit_depth_1_shader",2:"pv_picollm_weight_block_mixed_16x8_forward_single_bit_depth_2_shader",3:"pv_picollm_weight_block_mixed_16x8_forward_single_bit_depth_3_shader",4:"pv_picollm_weight_block_mixed_16x8_forward_single_bit_depth_4_shader",5:"pv_picollm_weight_block_mixed_16x8_forward_single_bit_depth_5_shader",6:"pv_picollm_weight_block_mixed_16x8_forward_single_bit_depth_6_shader",7:"pv_picollm_weight_block_mixed_16x8_forward_single_bit_depth_7_shader",8:"pv_picollm_weight_block_mixed_16x8_forward_single_bit_depth_8_shader"};var forwardShaderSources={1:forwardMultipleShaderSources(1),2:forwardMultipleShaderSources(2),3:forwardMultipleShaderSources(3),4:forwardMultipleShaderSources(4),5:forwardMultipleShaderSources(5),6:forwardMultipleShaderSources(6),7:forwardMultipleShaderSources(7),8:forwardMultipleShaderSources(8)};var forwardShaderNames={1:"pv_picollm_weight_block_mixed_16x8_forward_multiple_bit_depth_1_shader",2:"pv_picollm_weight_block_mixed_16x8_forward_multiple_bit_depth_2_shader",3:"pv_picollm_weight_block_mixed_16x8_forward_multiple_bit_depth_3_shader",4:"pv_picollm_weight_block_mixed_16x8_forward_multiple_bit_depth_4_shader",5:"pv_picollm_weight_block_mixed_16x8_forward_multiple_bit_depth_5_shader",6:"pv_picollm_weight_block_mixed_16x8_forward_multiple_bit_depth_6_shader",7:"pv_picollm_weight_block_mixed_16x8_forward_multiple_bit_depth_7_shader",8:"pv_picollm_weight_block_mixed_16x8_forward_multiple_bit_depth_8_shader"};var forwardShuffleXShaderName="pv_picollm_weight_block_mixed_16x8_forward_shuffle_x_shader";var forwardShuffleYShaderName="pv_picollm_weight_block_mixed_16x8_forward_shuffle_y_shader";var addBiasShaderName="pv_picollm_weight_block_mixed_16x8_add_bias_shader";var forwardSingleReduceYShaderName="pv_picollm_weight_block_mixed_16x8_forward_single_reduce_y_shader";var _weightBlockMixed16x;var loadPreprocessBlocksShader=function loadPreprocessBlocksShader(device,bitDepth){var bindGroupLayout=device.createBindGroupLayout({label:"weight preprocess blocks ".concat(bitDepth," bind group layout"),entries:[{binding:0,visibility:GPUShaderStage.COMPUTE,buffer:{type:"uniform"}},{binding:1,visibility:GPUShaderStage.COMPUTE,buffer:{type:"storage"}}]});var pipelineLayout=device.createPipelineLayout({label:"weight preprocess blocks ".concat(bitDepth," pipeline layout"),bindGroupLayouts:[bindGroupLayout]});var shaderModule=device.createShaderModule({label:"weight preprocess blocks ".concat(bitDepth," shader module"),code:preprocessShaderSources[bitDepth]});var computePipeline=device.createComputePipeline({label:"weight preprocess blocks ".concat(bitDepth," pipeline"),layout:pipelineLayout,compute:{module:shaderModule,entryPoint:shaderEntryPoint,constants:{workgroup_size_x:preprocessDim,workgroup_size_y:preprocessDim}}});return{computePipeline:computePipeline}};var loadForwardShuffleXShader=function loadForwardShuffleXShader(device){var bindGroupLayout=device.createBindGroupLayout({label:"weight shuffle x bind group layout",entries:[{binding:0,visibility:GPUShaderStage.COMPUTE,buffer:{type:"uniform"}},{binding:1,visibility:GPUShaderStage.COMPUTE,buffer:{type:"read-only-storage"}},{binding:2,visibility:GPUShaderStage.COMPUTE,buffer:{type:"read-only-storage"}},{binding:3,visibility:GPUShaderStage.COMPUTE,buffer:{type:"storage"}}]});var pipelineLayout=device.createPipelineLayout({label:"weight shuffle x pipeline layout",bindGroupLayouts:[bindGroupLayout]});var shaderModule=device.createShaderModule({label:"weight shuffle x shader module",code:forwardShuffleXShaderSource});var computePipeline=device.createComputePipeline({label:"weight shuffle x pipeline",layout:pipelineLayout,compute:{module:shaderModule,entryPoint:shaderEntryPoint,constants:{workgroup_size_y:PV_PICOLLM_WEBGPU_DEFAULT_WORKGROUP_SIZE}}});return{computePipeline:computePipeline}};var loadForwardSingleReduceYShader=function loadForwardSingleReduceYShader(device){var bindGroupLayout=device.createBindGroupLayout({label:"weight single reduce y bind group layout",entries:[{binding:0,visibility:GPUShaderStage.COMPUTE,buffer:{type:"uniform"}},{binding:1,visibility:GPUShaderStage.COMPUTE,buffer:{type:"read-only-storage"}},{binding:2,visibility:GPUShaderStage.COMPUTE,buffer:{type:"storage"}}]});var pipelineLayout=device.createPipelineLayout({label:"weight single reduce y pipeline layout",bindGroupLayouts:[bindGroupLayout]});var shaderModule=device.createShaderModule({label:"weight single reduce y shader module",code:forwardSingleReduceYShaderSource});var computePipeline=device.createComputePipeline({label:"weight single reduce y pipeline",layout:pipelineLayout,compute:{module:shaderModule,entryPoint:shaderEntryPoint,constants:{workgroup_size_x:PV_PICOLLM_WEBGPU_DEFAULT_WORKGROUP_SIZE}}});return{computePipeline:computePipeline}};var loadForwardShuffleYShader=function loadForwardShuffleYShader(device){var bindGroupLayout=device.createBindGroupLayout({label:"weight shuffle y bind group layout",entries:[{binding:0,visibility:GPUShaderStage.COMPUTE,buffer:{type:"uniform"}},{binding:1,visibility:GPUShaderStage.COMPUTE,buffer:{type:"read-only-storage"}},{binding:2,visibility:GPUShaderStage.COMPUTE,buffer:{type:"storage"}}]});var pipelineLayout=device.createPipelineLayout({label:"weight shuffle y pipeline layout",bindGroupLayouts:[bindGroupLayout]});var shaderModule=device.createShaderModule({label:"weight shuffle y shader module",code:forwardShuffleYShaderSource});var computePipeline=device.createComputePipeline({label:"weight shuffle y pipeline",layout:pipelineLayout,compute:{module:shaderModule,entryPoint:shaderEntryPoint}});return{computePipeline:computePipeline}};var loadForwardSingleShader=function loadForwardSingleShader(device,bitDepth){var entries=[{binding:0,visibility:GPUShaderStage.COMPUTE,buffer:{type:"uniform"}},{binding:1,visibility:GPUShaderStage.COMPUTE,buffer:{type:"read-only-storage"}},{binding:2,visibility:GPUShaderStage.COMPUTE,buffer:{type:"read-only-storage"}},{binding:3,visibility:GPUShaderStage.COMPUTE,buffer:{type:"read-only-storage"}},{binding:4,visibility:GPUShaderStage.COMPUTE,buffer:{type:"storage"}}];var bindGroupLayout=device.createBindGroupLayout({label:"weight forward single ".concat(bitDepth," bind group layout"),entries:entries});var pipelineLayout=device.createPipelineLayout({label:"weight forward single ".concat(bitDepth," pipeline layout"),bindGroupLayouts:[bindGroupLayout]});var shaderModule=device.createShaderModule({label:"weight forward single ".concat(bitDepth," shader module"),code:forwardSingleShaderSources[bitDepth]});var computePipeline=device.createComputePipeline({label:"weight forward single ".concat(bitDepth," pipeline"),layout:pipelineLayout,compute:{module:shaderModule,entryPoint:shaderEntryPoint,constants:{workgroup_size_x:weightBlockSize,workgroup_size_y:1}}});return{computePipeline:computePipeline}};var loadForwardShader=function loadForwardShader(device,bitDepth){var entries=[{binding:0,visibility:GPUShaderStage.COMPUTE,buffer:{type:"uniform"}},{binding:1,visibility:GPUShaderStage.COMPUTE,buffer:{type:"read-only-storage"}},{binding:2,visibility:GPUShaderStage.COMPUTE,buffer:{type:"read-only-storage"}},{binding:3,visibility:GPUShaderStage.COMPUTE,buffer:{type:"read-only-storage"}},{binding:4,visibility:GPUShaderStage.COMPUTE,buffer:{type:"storage"}}];var bindGroupLayout=device.createBindGroupLayout({label:"weight forward multi ".concat(bitDepth," bind group layout"),entries:entries});var pipelineLayout=device.createPipelineLayout({label:"weight forward multi ".concat(bitDepth," pipeline layout"),bindGroupLayouts:[bindGroupLayout]});var shaderModule=device.createShaderModule({label:"weight forward multi ".concat(bitDepth," shader module"),code:forwardShaderSources[bitDepth]});var computePipeline=device.createComputePipeline({label:"weight forward multi ".concat(bitDepth," pipeline"),layout:pipelineLayout,compute:{module:shaderModule,entryPoint:shaderEntryPoint,constants:{workgroup_size_x:TC}}});return{computePipeline:computePipeline}};var loadAddBiasShader=function loadAddBiasShader(device){var bindGroupLayout=device.createBindGroupLayout({label:"weight add bias bind group layout",entries:[{binding:0,visibility:GPUShaderStage.COMPUTE,buffer:{type:"uniform"}},{binding:1,visibility:GPUShaderStage.COMPUTE,buffer:{type:"read-only-storage"}},{binding:2,visibility:GPUShaderStage.COMPUTE,buffer:{type:"storage"}}]});var pipelineLayout=device.createPipelineLayout({label:"weight add bias pipeline layout",bindGroupLayouts:[bindGroupLayout]});var shaderModule=device.createShaderModule({label:"weight add bias shader module",code:addBiasShaderSource});var computePipeline=device.createComputePipeline({label:"weight add bias pipeline",layout:pipelineLayout,compute:{module:shaderModule,entryPoint:shaderEntryPoint}});return{computePipeline:computePipeline}};var weightBlockMixed16x8Shaders=(_weightBlockMixed16x={},_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_weightBlockMixed16x,preprocessShaderNames[3],function(device){return loadPreprocessBlocksShader(device,3)}),preprocessShaderNames[5],function(device){return loadPreprocessBlocksShader(device,5)}),preprocessShaderNames[6],function(device){return loadPreprocessBlocksShader(device,6)}),preprocessShaderNames[7],function(device){return loadPreprocessBlocksShader(device,7)}),forwardShuffleXShaderName,loadForwardShuffleXShader),forwardShuffleYShaderName,loadForwardShuffleYShader),forwardSingleReduceYShaderName,loadForwardSingleReduceYShader),forwardSingleShaderNames[1],function(device){return loadForwardSingleShader(device,1)}),forwardSingleShaderNames[2],function(device){return loadForwardSingleShader(device,2)}),forwardSingleShaderNames[3],function(device){return loadForwardSingleShader(device,3)}),_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_weightBlockMixed16x,forwardSingleShaderNames[4],function(device){return loadForwardSingleShader(device,4)}),forwardSingleShaderNames[5],function(device){return loadForwardSingleShader(device,5)}),forwardSingleShaderNames[6],function(device){return loadForwardSingleShader(device,6)}),forwardSingleShaderNames[7],function(device){return loadForwardSingleShader(device,7)}),forwardSingleShaderNames[8],function(device){return loadForwardSingleShader(device,8)}),forwardShaderNames[1],function(device){return loadForwardShader(device,1)}),forwardShaderNames[2],function(device){return loadForwardShader(device,2)}),forwardShaderNames[3],function(device){return loadForwardShader(device,3)}),forwardShaderNames[4],function(device){return loadForwardShader(device,4)}),forwardShaderNames[5],function(device){return loadForwardShader(device,5)}),_defineProperty(_defineProperty(_defineProperty(_defineProperty(_weightBlockMixed16x,forwardShaderNames[6],function(device){return loadForwardShader(device,6)}),forwardShaderNames[7],function(device){return loadForwardShader(device,7)}),forwardShaderNames[8],function(device){return loadForwardShader(device,8)}),addBiasShaderName,loadAddBiasShader));function ownKeys$1(e,r){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);r&&(o=o.filter(function(r){return Object.getOwnPropertyDescriptor(e,r).enumerable})),t.push.apply(t,o)}return t}function _objectSpread$1(e){for(var r=1;r<arguments.length;r++){var t=null!=arguments[r]?arguments[r]:{};r%2?ownKeys$1(Object(t),!0).forEach(function(r){_defineProperty(e,r,t[r])}):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):ownKeys$1(Object(t)).forEach(function(r){Object.defineProperty(e,r,Object.getOwnPropertyDescriptor(t,r))})}return e}var shaders=_objectSpread$1(_objectSpread$1(_objectSpread$1(_objectSpread$1(_objectSpread$1(_objectSpread$1(_objectSpread$1(_objectSpread$1(_objectSpread$1({},attentionShaders),feedForwardShaders),gateForwardShader),moeTransformerForwardShaders),normForwardShader),normLayerForwardShader),transformerForwardShaders),weightFloatForwardShader),weightBlockMixed16x8Shaders);var xpuCpuFunctions=function xpuCpuFunctions(){function setInt(address,value){Module.HEAP32[address/Int32Array.BYTES_PER_ELEMENT]=value}return{pv_xpu_device_info_wasm:function pv_xpu_device_info_wasm(browserNameAddressAddress,browserVersionAddressAddress,osNameAddressAddress,numCoresAddress,statusAddress){browserNameAddressAddress=unsignedAddress(browserNameAddressAddress);browserVersionAddressAddress=unsignedAddress(browserVersionAddressAddress);osNameAddressAddress=unsignedAddress(osNameAddressAddress);numCoresAddress=unsignedAddress(numCoresAddress);statusAddress=unsignedAddress(statusAddress);var uaParser=Bowser.getParser(navigator.userAgent);var browserName=uaParser.getBrowserName();var browserNameAddress=Module._malloc((browserName.length+1)*Uint8Array.BYTES_PER_ELEMENT);if(browserNameAddress===0){setInt(statusAddress,-1);return}setInt(browserNameAddressAddress,browserNameAddress);for(var i=0;i<browserName.length;i++){Module.HEAPU8[browserNameAddress+i]=browserName.charCodeAt(i)}Module.HEAPU8[browserNameAddress+browserName.length]=0;var browserVersion=uaParser.getBrowserVersion();var browserVersionAddress=Module._malloc((browserVersion.length+1)*Uint8Array.BYTES_PER_ELEMENT);if(browserVersionAddress===0){setInt(statusAddress,-1);return}setInt(browserVersionAddressAddress,browserVersionAddress);for(var _i=0;_i<browserVersion.length;_i++){Module.HEAPU8[browserVersionAddress+_i]=browserVersion.charCodeAt(_i)}Module.HEAPU8[browserVersionAddress+browserVersion.length]=0;var osName=uaParser.getOSName();var osNameAddress=Module._malloc((osName.length+1)*Uint8Array.BYTES_PER_ELEMENT);if(osNameAddress===0){setInt(statusAddress,-1);return}setInt(osNameAddressAddress,osNameAddress);for(var _i2=0;_i2<osName.length;_i2++){Module.HEAPU8[osNameAddress+_i2]=osName.charCodeAt(_i2)}Module.HEAPU8[osNameAddress+osName.length]=0;var numCores=self.navigator.hardwareConcurrency;setInt(numCoresAddress,numCores?numCores:1);setInt(statusAddress,0)},pv_xpu_get_max_workers_wasm:function pv_xpu_get_max_workers_wasm(maxWorkersAddress){maxWorkersAddress=unsignedAddress(maxWorkersAddress);var maxWorkers=self.navigator.hardwareConcurrency;setInt(maxWorkersAddress,maxWorkers?maxWorkers:1)}}};function ownKeys(e,r){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);r&&(o=o.filter(function(r){return Object.getOwnPropertyDescriptor(e,r).enumerable})),t.push.apply(t,o)}return t}function _objectSpread(e){for(var r=1;r<arguments.length;r++){var t=null!=arguments[r]?arguments[r]:{};r%2?ownKeys(Object(t),!0).forEach(function(r){_defineProperty(e,r,t[r])}):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):ownKeys(Object(t)).forEach(function(r){Object.defineProperty(e,r,Object.getOwnPropertyDescriptor(t,r))})}return e}function _createForOfIteratorHelper(r,e){var t="undefined"!=typeof Symbol&&r[Symbol.iterator]||r["@@iterator"];if(!t){if(Array.isArray(r)||(t=_unsupportedIterableToArray(r))||e&&r&&"number"==typeof r.length){t&&(r=t);var _n=0,F=function F(){};return{s:F,n:function n(){return _n>=r.length?{done:!0}:{done:!1,value:r[_n++]}},e:function e(r){throw r},f:F}}throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}var o,a=!0,u=!1;return{s:function s(){t=t.call(r)},n:function n(){var r=t.next();return a=r.done,r},e:function e(r){u=!0,o=r},f:function f(){try{a||null==t["return"]||t["return"]()}finally{if(u)throw o}}}}function _unsupportedIterableToArray(r,a){if(r){if("string"==typeof r)return _arrayLikeToArray(r,a);var t={}.toString.call(r).slice(8,-1);return"Object"===t&&r.constructor&&(t=r.constructor.name),"Map"===t||"Set"===t?Array.from(r):"Arguments"===t||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t)?_arrayLikeToArray(r,a):void 0}}function _arrayLikeToArray(r,a){(null==a||a>r.length)&&(a=r.length);for(var e=0,n=Array(a);e<a;e++)n[e]=r[e];return n}function setInt(address,value){Module.HEAP32[address/Int32Array.BYTES_PER_ELEMENT]=value}function arrayBufferToStringAtIndex(arrayBuffer,indexStart){var indexEnd=indexStart;while(arrayBuffer[indexEnd]!==0){indexEnd++}var utf8decoder=new TextDecoder("utf-8");var tempBuffer=new Uint8Array(arrayBuffer.slice(indexStart,indexEnd));return utf8decoder.decode(tempBuffer)}function stringHeaderToObject(stringHeader){var objectHeader={};var _iterator=_createForOfIteratorHelper(stringHeader.split("\r\n")),_step;try{for(_iterator.s();!(_step=_iterator.n()).done;){var property=_step.value;var keyValuePair=property.split(": ");if(keyValuePair[0]!==""){objectHeader[keyValuePair[0]]=keyValuePair[1]}}}catch(err){_iterator.e(err)}finally{_iterator.f()}return objectHeader}function fetchWithTimeout(_x){return _fetchWithTimeout.apply(this,arguments)}function _fetchWithTimeout(){_fetchWithTimeout=_asyncToGenerator(_regeneratorRuntime.mark(function _callee(uri){var options,time,controller,config,timeout,response,_args=arguments;return _regeneratorRuntime.wrap(function _callee$(_context){while(1)switch(_context.prev=_context.next){case 0:options=_args.length>1&&_args[1]!==undefined?_args[1]:{};time=_args.length>2&&_args[2]!==undefined?_args[2]:5e3;controller=new AbortController;config=_objectSpread(_objectSpread({},options),{},{signal:controller.signal});timeout=setTimeout(function(){controller.abort()},time);_context.next=7;return fetch(uri,config);case 7:response=_context.sent;clearTimeout(timeout);return _context.abrupt("return",response);case 10:case"end":return _context.stop()}},_callee)}));return _fetchWithTimeout.apply(this,arguments)}function open(_x2,_x3){return _open.apply(this,arguments)}function _open(){_open=_asyncToGenerator(_regeneratorRuntime.mark(function _callee2(path,mode){var error;return _regeneratorRuntime.wrap(function _callee2$(_context2){while(1)switch(_context2.prev=_context2.next){case 0:_context2.prev=0;_context2.next=3;return PvFileIDB.open(path,mode);case 3:return _context2.abrupt("return",_context2.sent);case 6:_context2.prev=6;_context2.t0=_context2["catch"](0);if(_context2.t0.name==="IndexedDBNotSupported"){console.warn("IndexedDB is not supported. Fallback to in-memory storage.")}else if(_context2.t0.name!=="FileNotExists"){console.warn("Unable to access IndexedDB (".concat(_context2.t0.toString(),"). Fallback to in-memory storage."))}if(!(typeof WorkerGlobalScope!=="undefined"&&self instanceof WorkerGlobalScope)){_context2.next=16;break}if(!(_context2.t0.name==="FileNotExists")){_context2.next=12;break}throw _context2.t0;case 12:console.error("In-memory storage cannot be used inside a worker.");error=new Error("Failed to start PvFile: ".concat(_context2.t0.toString()));error.name="PvFileNotSupported";throw error;case 16:return _context2.abrupt("return",PvFileMem.open(path,mode));case 17:case"end":return _context2.stop()}},_callee2,null,[[0,6]])}));return _open.apply(this,arguments)}var moduleOverrides=Object.assign({},Module);var arguments_=[];var thisProgram="./this.program";var quit_=(status,toThrow)=>{throw toThrow};var scriptDirectory="";function locateFile(path){if(Module["locateFile"]){return Module["locateFile"](path,scriptDirectory)}return scriptDirectory+path}var readAsync,readBinary;if(ENVIRONMENT_IS_WEB||ENVIRONMENT_IS_WORKER){if(ENVIRONMENT_IS_WORKER){scriptDirectory=self.location.href}else if(typeof document!="undefined"&&document.currentScript){scriptDirectory=document.currentScript.src}if(_scriptName){scriptDirectory=_scriptName}if(scriptDirectory.startsWith("blob:")){scriptDirectory=""}else{scriptDirectory=scriptDirectory.substr(0,scriptDirectory.replace(/[?#].*/,"").lastIndexOf("/")+1)}{if(ENVIRONMENT_IS_WORKER){readBinary=url=>{var xhr=new XMLHttpRequest;xhr.open("GET",url,false);xhr.responseType="arraybuffer";xhr.send(null);return new Uint8Array(xhr.response)}}readAsync=url=>{if(isFileURI(url)){return new Promise((reject,resolve)=>{var xhr=new XMLHttpRequest;xhr.open("GET",url,true);xhr.responseType="arraybuffer";xhr.onload=()=>{if(xhr.status==200||xhr.status==0&&xhr.response){resolve(xhr.response)}reject(xhr.status)};xhr.onerror=reject;xhr.send(null)})}return fetch(url,{credentials:"same-origin"}).then(response=>{if(response.ok){return response.arrayBuffer()}return Promise.reject(new Error(response.status+" : "+response.url))})}}}else{}var out=Module["print"]||console.log.bind(console);var err=Module["printErr"]||console.error.bind(console);Object.assign(Module,moduleOverrides);moduleOverrides=null;if(Module["arguments"])arguments_=Module["arguments"];if(Module["thisProgram"])thisProgram=Module["thisProgram"];if(Module["quit"])quit_=Module["quit"];var wasmBinary;if(Module["wasmBinary"])wasmBinary=Module["wasmBinary"];var wasmMemory;var ABORT=false;var EXITSTATUS;var HEAP8,HEAPU8,HEAP16,HEAPU16,HEAP32,HEAPU32,HEAPF32,HEAP64,HEAPU64,HEAPF64;function updateMemoryViews(){var b=wasmMemory.buffer;Module["HEAP8"]=HEAP8=new Int8Array(b);Module["HEAP16"]=HEAP16=new Int16Array(b);Module["HEAPU8"]=HEAPU8=new Uint8Array(b);Module["HEAPU16"]=HEAPU16=new Uint16Array(b);Module["HEAP32"]=HEAP32=new Int32Array(b);Module["HEAPU32"]=HEAPU32=new Uint32Array(b);Module["HEAPF32"]=HEAPF32=new Float32Array(b);Module["HEAPF64"]=HEAPF64=new Float64Array(b);Module["HEAP64"]=HEAP64=new BigInt64Array(b);Module["HEAPU64"]=HEAPU64=new BigUint64Array(b)}var __ATPRERUN__=[];var __ATINIT__=[];var __ATPOSTRUN__=[];var runtimeInitialized=false;function preRun(){if(Module["preRun"]){if(typeof Module["preRun"]=="function")Module["preRun"]=[Module["preRun"]];while(Module["preRun"].length){addOnPreRun(Module["preRun"].shift())}}callRuntimeCallbacks(__ATPRERUN__)}function initRuntime(){runtimeInitialized=true;callRuntimeCallbacks(__ATINIT__)}function postRun(){if(Module["postRun"]){if(typeof Module["postRun"]=="function")Module["postRun"]=[Module["postRun"]];while(Module["postRun"].length){addOnPostRun(Module["postRun"].shift())}}callRuntimeCallbacks(__ATPOSTRUN__)}function addOnPreRun(cb){__ATPRERUN__.unshift(cb)}function addOnInit(cb){__ATINIT__.unshift(cb)}function addOnPostRun(cb){__ATPOSTRUN__.unshift(cb)}var runDependencies=0;var runDependencyWatcher=null;var dependenciesFulfilled=null;function addRunDependency(id){runDependencies++;Module["monitorRunDependencies"]?.(runDependencies)}function removeRunDependency(id){runDependencies--;Module["monitorRunDependencies"]?.(runDependencies);if(runDependencies==0){if(runDependencyWatcher!==null){clearInterval(runDependencyWatcher);runDependencyWatcher=null}if(dependenciesFulfilled){var callback=dependenciesFulfilled;dependenciesFulfilled=null;callback()}}}function abort(what){Module["onAbort"]?.(what);what="Aborted("+what+")";err(what);ABORT=true;EXITSTATUS=1;what+=". Build with -sASSERTIONS for more info.";var e=new WebAssembly.RuntimeError(what);readyPromiseReject(e);throw e}var dataURIPrefix="data:application/octet-stream;base64,";var isDataURI=filename=>filename.startsWith(dataURIPrefix);var isFileURI=filename=>filename.startsWith("file://");function findWasmBinary(){var f="pv_porcupine_simd.wasm";if(!isDataURI(f)){return locateFile(f)}return f}var wasmBinaryFile;function getBinarySync(file){if(file==wasmBinaryFile&&wasmBinary){return new Uint8Array(wasmBinary)}if(readBinary){return readBinary(file)}throw"both async and sync fetching of the wasm failed"}function getBinaryPromise(binaryFile){if(!wasmBinary){return readAsync(binaryFile).then(response=>new Uint8Array(response),()=>getBinarySync(binaryFile))}return Promise.resolve().then(()=>getBinarySync(binaryFile))}function instantiateArrayBuffer(binaryFile,imports,receiver){return getBinaryPromise(binaryFile).then(binary=>WebAssembly.instantiate(binary,imports)).then(receiver,reason=>{err(`failed to asynchronously prepare wasm: ${reason}`);abort(reason)})}function instantiateAsync(binary,binaryFile,imports,callback){if(!binary&&typeof WebAssembly.instantiateStreaming=="function"&&!isDataURI(binaryFile)&&!isFileURI(binaryFile)&&typeof fetch=="function"){return fetch(binaryFile,{credentials:"same-origin"}).then(response=>{var result=WebAssembly.instantiateStreaming(response,imports);return result.then(callback,function(reason){err(`wasm streaming compile failed: ${reason}`);err("falling back to ArrayBuffer instantiation");return instantiateArrayBuffer(binaryFile,imports,callback)})})}return instantiateArrayBuffer(binaryFile,imports,callback)}function getWasmImports(){return{a:wasmImports}}function createWasm(){var info=getWasmImports();function receiveInstance(instance,module){wasmExports=instance.exports;wasmExports=Asyncify.instrumentWasmExports(wasmExports);wasmMemory=wasmExports["n"];updateMemoryViews();wasmTable=wasmExports["p"];addOnInit(wasmExports["o"]);removeRunDependency("wasm-instantiate");return wasmExports}addRunDependency("wasm-instantiate");function receiveInstantiationResult(result){receiveInstance(result["instance"])}if(Module["instantiateWasm"]){try{return Module["instantiateWasm"](info,receiveInstance)}catch(e){err(`Module.instantiateWasm callback failed with error: ${e}`);readyPromiseReject(e)}}if(!wasmBinaryFile)wasmBinaryFile=findWasmBinary();instantiateAsync(wasmBinary,wasmBinaryFile,info,receiveInstantiationResult).catch(readyPromiseReject);return{}}function ExitStatus(status){this.name="ExitStatus";this.message=`Program terminated with exit(${status})`;this.status=status}var callRuntimeCallbacks=callbacks=>{while(callbacks.length>0){callbacks.shift()(Module)}};var noExitRuntime=Module["noExitRuntime"]||true;var stackRestore=val=>__emscripten_stack_restore(val);var stackSave=()=>_emscripten_stack_get_current();var getHeapMax=()=>2147483648;var growMemory=size=>{var b=wasmMemory.buffer;var pages=(size-b.byteLength+65535)/65536;try{wasmMemory.grow(pages);updateMemoryViews();return 1}catch(e){}};var _emscripten_resize_heap=requestedSize=>{var oldSize=HEAPU8.length;requestedSize>>>=0;var maxHeapSize=getHeapMax();if(requestedSize>maxHeapSize){return false}var alignUp=(x,multiple)=>x+(multiple-x%multiple)%multiple;for(var cutDown=1;cutDown<=4;cutDown*=2){var overGrownHeapSize=oldSize*(1+.2/cutDown);overGrownHeapSize=Math.min(overGrownHeapSize,requestedSize+100663296);var newSize=Math.min(maxHeapSize,alignUp(Math.max(requestedSize,overGrownHeapSize),65536));var replacement=growMemory(newSize);if(replacement){return true}}return false};function _pv_console_log_wasm(index){console.log(arrayBufferToStringAtIndex(Module.HEAPU8,index))}var _pv_file_close_wasm=async function(fileAddress,statusAddress){statusAddress=unsignedAddress(statusAddress);return Asyncify.handleAsync(async()=>{try{const file=await PvFile.getPtr(fileAddress);await file.close();setInt(statusAddress,0)}catch(e){console.error("pvFileCloseWasm",e);setInt(statusAddress,-1)}})};_pv_file_close_wasm.isAsync=true;var _pv_file_open_wasm=async function(fileAddress,pathAddress,modeAddress,statusAddress){pathAddress=unsignedAddress(pathAddress);modeAddress=unsignedAddress(modeAddress);statusAddress=unsignedAddress(statusAddress);return Asyncify.handleAsync(async()=>{const path=arrayBufferToStringAtIndex(Module.HEAPU8,pathAddress);const mode=arrayBufferToStringAtIndex(Module.HEAPU8,modeAddress);try{const file=await open(path,mode);PvFile.setPtr(fileAddress,file);setInt(statusAddress,0)}catch(e){if(e.name!=="FileNotExists"){console.error("pvFileOpenWasm",e)}setInt(statusAddress,-1)}})};_pv_file_open_wasm.isAsync=true;var _pv_file_read_wasm=async function(fileAddress,contentAddress,size,count,numReadAddress){contentAddress=unsignedAddress(contentAddress);numReadAddress=unsignedAddress(numReadAddress);return Asyncify.handleAsync(async()=>{try{const file=PvFile.getPtr(fileAddress);const content=await file.read(size,count);Module.HEAPU8.set(content,contentAddress);setInt(numReadAddress,content.length/size)}catch(e){console.error("pvFileReadWasm",e);setInt(numReadAddress,-1)}})};_pv_file_read_wasm.isAsync=true;function _pv_file_seek_wasm(fileAddress,offset,whence,statusAddress){statusAddress=unsignedAddress(statusAddress);try{const file=PvFile.getPtr(fileAddress);file.seek(offset,whence);setInt(statusAddress,0)}catch(e){console.error("pvFileSeekWasm",e);setInt(statusAddress,-1)}}function _pv_file_tell_wasm(fileAddress,offsetAddress){offsetAddress=unsignedAddress(offsetAddress);try{const file=PvFile.getPtr(fileAddress);setInt(offsetAddress,file.tell())}catch(e){console.error("pvFileTellWasm",e);setInt(offsetAddress,-1)}}var _pv_file_write_wasm=function(fileAddress,contentAddress,size,count,numWriteAddress){contentAddress=unsignedAddress(contentAddress);numWriteAddress=unsignedAddress(numWriteAddress);return Asyncify.handleAsync(async()=>{try{const file=PvFile.getPtr(fileAddress);const content=new Uint8Array(size*count);content.set(Module.HEAPU8.slice(contentAddress,contentAddress+size*count),0);await file.write(content);setInt(numWriteAddress,content.length/size)}catch(e){console.error("pvFileWriteWasm",e);setInt(numWriteAddress,-1)}})};function _pv_get_browser_info(browserInfoAddressAddress){browserInfoAddressAddress=unsignedAddress(browserInfoAddressAddress);const userAgent=navigator.userAgent!==undefined?navigator.userAgent:"unknown";const browserInfoAddress=Module._malloc((userAgent.length+1)*Uint8Array.BYTES_PER_ELEMENT);if(browserInfoAddress===0){console.error("pvMallocError","pvGetBrowserInfo: cannot allocate memory for browser info");setInt(browserInfoAddressAddress,0);return}setInt(browserInfoAddressAddress,browserInfoAddress);for(let i=0;i<userAgent.length;i++){Module.HEAPU8[browserInfoAddress+i]=userAgent.charCodeAt(i)}Module.HEAPU8[browserInfoAddress+userAgent.length]=0}function _pv_get_origin_info(originInfoAddressAddress){originInfoAddressAddress=unsignedAddress(originInfoAddressAddress);const origin=self.origin??self.location.origin;const hostname=new URL(origin).hostname;const originInfoAddress=Module._malloc((hostname.length+1)*Uint8Array.BYTES_PER_ELEMENT);if(originInfoAddress===0){console.error("pvMallocError","pvGetOriginInfo: cannot allocate memory for origin info");setInt(originInfoAddressAddress,0);return}setInt(originInfoAddressAddress,originInfoAddress);for(let i=0;i<hostname.length;i++){Module.HEAPU8[originInfoAddress+i]=hostname.charCodeAt(i)}Module.HEAPU8[originInfoAddress+hostname.length]=0}var _pv_https_request_wasm=async function(httpMethodAddress,serverNameAddress,endpointAddress,headerAddress,bodyAddress,timeoutMs,responseAddressAddress,responseSizeAddress,responseCodeAddress){httpMethodAddress=unsignedAddress(httpMethodAddress);serverNameAddress=unsignedAddress(serverNameAddress);endpointAddress=unsignedAddress(endpointAddress);headerAddress=unsignedAddress(headerAddress);bodyAddress=unsignedAddress(bodyAddress);responseAddressAddress=unsignedAddress(responseAddressAddress);responseSizeAddress=unsignedAddress(responseSizeAddress);responseCodeAddress=unsignedAddress(responseCodeAddress);return Asyncify.handleAsync(async()=>{const httpMethod=arrayBufferToStringAtIndex(Module.HEAPU8,httpMethodAddress);const serverName=arrayBufferToStringAtIndex(Module.HEAPU8,serverNameAddress);const endpoint=arrayBufferToStringAtIndex(Module.HEAPU8,endpointAddress);const header=arrayBufferToStringAtIndex(Module.HEAPU8,headerAddress);const body=arrayBufferToStringAtIndex(Module.HEAPU8,bodyAddress);const headerObject=stringHeaderToObject(header);const options={method:httpMethod};if(body.length>0){options.body=body}if(Object.keys(headerObject).length>0){options.headers=headerObject}let response;let responseText;let statusCode;try{response=await fetchWithTimeout("https://"+serverName+endpoint,options,timeoutMs);statusCode=response.status}catch(error){console.error("pvHttpsRequestWasm",`Failed to fetch: ${error}`);return}try{responseText=await response.text()}catch(error){console.error("pvHttpsRequestWasm",`Failed to get response text: ${error}`);return}const responseAddress=Module._malloc((responseText.length+1)*Int8Array.BYTES_PER_ELEMENT);if(responseAddress===0){console.error("pvMallocError","pvHttpsRequestWasm: cannot allocate memory for response");setInt(responseAddressAddress,0);return}setInt(responseSizeAddress,responseText.length+1);setInt(responseAddressAddress,responseAddress);for(let i=0;i<responseText.length;i++){Module.HEAPU8[responseAddress+i]=responseText.charCodeAt(i)}Module.HEAPU8[responseAddress+responseText.length]=0;setInt(responseCodeAddress,statusCode)})};_pv_https_request_wasm.isAsync=true;function _pv_time_wasm(){return Date.now()/1e3}function xpu_cpu_support(){const functions=xpuCpuFunctions();if(typeof _pv_xpu_device_info_wasm!=="undefined")_pv_xpu_device_info_wasm=functions.pv_xpu_device_info_wasm;if(typeof _pv_xpu_get_max_workers_wasm!=="undefined")_pv_xpu_get_max_workers_wasm=functions.pv_xpu_get_max_workers_wasm}function _pv_xpu_get_max_workers_wasm(){}var runAndAbortIfError=func=>{try{return func()}catch(e){abort(e)}};var handleException=e=>{if(e instanceof ExitStatus||e=="unwind"){return EXITSTATUS}quit_(1,e)};var runtimeKeepaliveCounter=0;var keepRuntimeAlive=()=>noExitRuntime||runtimeKeepaliveCounter>0;var _proc_exit=code=>{EXITSTATUS=code;if(!keepRuntimeAlive()){Module["onExit"]?.(code);ABORT=true}quit_(code,new ExitStatus(code))};var exitJS=(status,implicit)=>{EXITSTATUS=status;_proc_exit(status)};var _exit=exitJS;var maybeExit=()=>{if(!keepRuntimeAlive()){try{_exit(EXITSTATUS)}catch(e){handleException(e)}}};var callUserCallback=func=>{if(ABORT){return}try{func();maybeExit()}catch(e){handleException(e)}};var sigToWasmTypes=sig=>{var typeNames={i:"i32",j:"i64",f:"f32",d:"f64",e:"externref",p:"i32"};var type={parameters:[],results:sig[0]=="v"?[]:[typeNames[sig[0]]]};for(var i=1;i<sig.length;++i){type.parameters.push(typeNames[sig[i]])}return type};var runtimeKeepalivePush=()=>{runtimeKeepaliveCounter+=1};var runtimeKeepalivePop=()=>{runtimeKeepaliveCounter-=1};var Asyncify={instrumentWasmImports(imports){var importPattern=/^(pv_https_request_wasm|pv_file_open_wasm|pv_file_close_wasm|pv_file_read_wasm|pv_file_write_wasm|pv_file_remove_wasm|pv_sleep_wasm|pv_xpu_webgpu_device_init_wasm|pv_xpu_webgpu_device_info_wasm|pv_xpu_webgpu_device_mem_copy_from_xpu_wasm|pv_xpu_webgpu_device_wait_wasm|pv_xpu_webgpu_timer_stop_wasm|invoke_.*|__asyncjs__.*)$/;for(let[x,original]of Object.entries(imports)){if(typeof original=="function"){let isAsyncifyImport=original.isAsync||importPattern.test(x)}}},instrumentWasmExports(exports){var ret={};for(let[x,original]of Object.entries(exports)){if(typeof original=="function"){ret[x]=(...args)=>{Asyncify.exportCallStack.push(x);try{return original(...args)}finally{if(!ABORT){var y=Asyncify.exportCallStack.pop();Asyncify.maybeStopUnwind()}}}}else{ret[x]=original}}return ret},State:{Normal:0,Unwinding:1,Rewinding:2,Disabled:3},state:0,StackSize:4096,currData:null,handleSleepReturnValue:0,exportCallStack:[],callStackNameToId:{},callStackIdToName:{},callStackId:0,asyncPromiseHandlers:null,sleepCallbacks:[],getCallStackId(funcName){var id=Asyncify.callStackNameToId[funcName];if(id===undefined){id=Asyncify.callStackId++;Asyncify.callStackNameToId[funcName]=id;Asyncify.callStackIdToName[id]=funcName}return id},maybeStopUnwind(){if(Asyncify.currData&&Asyncify.state===Asyncify.State.Unwinding&&Asyncify.exportCallStack.length===0){Asyncify.state=Asyncify.State.Normal;runAndAbortIfError(_asyncify_stop_unwind);if(typeof Fibers!="undefined"){Fibers.trampoline()}}},whenDone(){return new Promise((resolve,reject)=>{Asyncify.asyncPromiseHandlers={resolve:resolve,reject:reject}})},allocateData(){var ptr=_malloc(12+Asyncify.StackSize);Asyncify.setDataHeader(ptr,ptr+12,Asyncify.StackSize);Asyncify.setDataRewindFunc(ptr);return ptr},setDataHeader(ptr,stack,stackSize){HEAPU32[ptr>>2]=stack;HEAPU32[ptr+4>>2]=stack+stackSize},setDataRewindFunc(ptr){var bottomOfCallStack=Asyncify.exportCallStack[0];var rewindId=Asyncify.getCallStackId(bottomOfCallStack);HEAP32[ptr+8>>2]=rewindId},getDataRewindFuncName(ptr){var id=HEAP32[ptr+8>>2];var name=Asyncify.callStackIdToName[id];return name},getDataRewindFunc(name){var func=wasmExports[name];return func},doRewind(ptr){var name=Asyncify.getDataRewindFuncName(ptr);var func=Asyncify.getDataRewindFunc(name);return func()},handleSleep(startAsync){if(ABORT)return;if(Asyncify.state===Asyncify.State.Normal){var reachedCallback=false;var reachedAfterCallback=false;startAsync((handleSleepReturnValue=0)=>{if(ABORT)return;Asyncify.handleSleepReturnValue=handleSleepReturnValue;reachedCallback=true;if(!reachedAfterCallback){return}Asyncify.state=Asyncify.State.Rewinding;runAndAbortIfError(()=>_asyncify_start_rewind(Asyncify.currData));if(typeof Browser!="undefined"&&Browser.mainLoop.func){Browser.mainLoop.resume()}var asyncWasmReturnValue,isError=false;try{asyncWasmReturnValue=Asyncify.doRewind(Asyncify.currData)}catch(err){asyncWasmReturnValue=err;isError=true}var handled=false;if(!Asyncify.currData){var asyncPromiseHandlers=Asyncify.asyncPromiseHandlers;if(asyncPromiseHandlers){Asyncify.asyncPromiseHandlers=null;(isError?asyncPromiseHandlers.reject:asyncPromiseHandlers.resolve)(asyncWasmReturnValue);handled=true}}if(isError&&!handled){throw asyncWasmReturnValue}});reachedAfterCallback=true;if(!reachedCallback){Asyncify.state=Asyncify.State.Unwinding;Asyncify.currData=Asyncify.allocateData();if(typeof Browser!="undefined"&&Browser.mainLoop.func){Browser.mainLoop.pause()}runAndAbortIfError(()=>_asyncify_start_unwind(Asyncify.currData))}}else if(Asyncify.state===Asyncify.State.Rewinding){Asyncify.state=Asyncify.State.Normal;runAndAbortIfError(_asyncify_stop_rewind);_free(Asyncify.currData);Asyncify.currData=null;Asyncify.sleepCallbacks.forEach(callUserCallback)}else{abort(`invalid state: ${Asyncify.state}`)}return Asyncify.handleSleepReturnValue},handleAsync(startAsync){return Asyncify.handleSleep(wakeUp=>{startAsync().then(wakeUp)})}};var uleb128Encode=(n,target)=>{if(n<128){target.push(n)}else{target.push(n%128|128,n>>7)}};var generateFuncType=(sig,target)=>{var sigRet=sig.slice(0,1);var sigParam=sig.slice(1);var typeCodes={i:127,p:127,j:126,f:125,d:124,e:111};target.push(96);uleb128Encode(sigParam.length,target);for(var i=0;i<sigParam.length;++i){target.push(typeCodes[sigParam[i]])}if(sigRet=="v"){target.push(0)}else{target.push(1,typeCodes[sigRet])}};var convertJsFunctionToWasm=(func,sig)=>{if(typeof WebAssembly.Function=="function"){return new WebAssembly.Function(sigToWasmTypes(sig),func)}var typeSectionBody=[1];generateFuncType(sig,typeSectionBody);var bytes=[0,97,115,109,1,0,0,0,1];uleb128Encode(typeSectionBody.length,bytes);bytes.push(...typeSectionBody);bytes.push(2,7,1,1,101,1,102,0,0,7,5,1,1,102,0,0);var module=new WebAssembly.Module(new Uint8Array(bytes));var instance=new WebAssembly.Instance(module,{e:{f:func}});var wrappedFunc=instance.exports["f"];return wrappedFunc};var wasmTableMirror=[];var wasmTable;var getWasmTableEntry=funcPtr=>{var func=wasmTableMirror[funcPtr];if(!func){if(funcPtr>=wasmTableMirror.length)wasmTableMirror.length=funcPtr+1;wasmTableMirror[funcPtr]=func=wasmTable.get(funcPtr)}return func};var updateTableMap=(offset,count)=>{if(functionsInTableMap){for(var i=offset;i<offset+count;i++){var item=getWasmTableEntry(i);if(item){functionsInTableMap.set(item,i)}}}};var functionsInTableMap;var getFunctionAddress=func=>{if(!functionsInTableMap){functionsInTableMap=new WeakMap;updateTableMap(0,wasmTable.length)}return functionsInTableMap.get(func)||0};var freeTableIndexes=[];var getEmptyTableSlot=()=>{if(freeTableIndexes.length){return freeTableIndexes.pop()}try{wasmTable.grow(1)}catch(err){if(!(err instanceof RangeError)){throw err}throw"Unable to grow wasm table. Set ALLOW_TABLE_GROWTH."}return wasmTable.length-1};var setWasmTableEntry=(idx,func)=>{wasmTable.set(idx,func);wasmTableMirror[idx]=wasmTable.get(idx)};var addFunction=(func,sig)=>{var rtn=getFunctionAddress(func);if(rtn){return rtn}var ret=getEmptyTableSlot();try{setWasmTableEntry(ret,func)}catch(err){if(!(err instanceof TypeError)){throw err}var wrapped=convertJsFunctionToWasm(func,sig);setWasmTableEntry(ret,wrapped)}functionsInTableMap.set(func,ret);return ret};var getCFunc=ident=>{var func=Module["_"+ident];return func};var writeArrayToMemory=(array,buffer)=>{HEAP8.set(array,buffer)};var lengthBytesUTF8=str=>{var len=0;for(var i=0;i<str.length;++i){var c=str.charCodeAt(i);if(c<=127){len++}else if(c<=2047){len+=2}else if(c>=55296&&c<=57343){len+=4;++i}else{len+=3}}return len};var stringToUTF8Array=(str,heap,outIdx,maxBytesToWrite)=>{if(!(maxBytesToWrite>0))return 0;var startIdx=outIdx;var endIdx=outIdx+maxBytesToWrite-1;for(var i=0;i<str.length;++i){var u=str.charCodeAt(i);if(u>=55296&&u<=57343){var u1=str.charCodeAt(++i);u=65536+((u&1023)<<10)|u1&1023}if(u<=127){if(outIdx>=endIdx)break;heap[outIdx++]=u}else if(u<=2047){if(outIdx+1>=endIdx)break;heap[outIdx++]=192|u>>6;heap[outIdx++]=128|u&63}else if(u<=65535){if(outIdx+2>=endIdx)break;heap[outIdx++]=224|u>>12;heap[outIdx++]=128|u>>6&63;heap[outIdx++]=128|u&63}else{if(outIdx+3>=endIdx)break;heap[outIdx++]=240|u>>18;heap[outIdx++]=128|u>>12&63;heap[outIdx++]=128|u>>6&63;heap[outIdx++]=128|u&63}}heap[outIdx]=0;return outIdx-startIdx};var stringToUTF8=(str,outPtr,maxBytesToWrite)=>stringToUTF8Array(str,HEAPU8,outPtr,maxBytesToWrite);var stackAlloc=sz=>__emscripten_stack_alloc(sz);var stringToUTF8OnStack=str=>{var size=lengthBytesUTF8(str)+1;var ret=stackAlloc(size);stringToUTF8(str,ret,size);return ret};var UTF8Decoder=typeof TextDecoder!="undefined"?new TextDecoder:undefined;var UTF8ArrayToString=(heapOrArray,idx,maxBytesToRead)=>{var endIdx=idx+maxBytesToRead;var endPtr=idx;while(heapOrArray[endPtr]&&!(endPtr>=endIdx))++endPtr;if(endPtr-idx>16&&heapOrArray.buffer&&UTF8Decoder){return UTF8Decoder.decode(heapOrArray.subarray(idx,endPtr))}var str="";while(idx<endPtr){var u0=heapOrArray[idx++];if(!(u0&128)){str+=String.fromCharCode(u0);continue}var u1=heapOrArray[idx++]&63;if((u0&224)==192){str+=String.fromCharCode((u0&31)<<6|u1);continue}var u2=heapOrArray[idx++]&63;if((u0&240)==224){u0=(u0&15)<<12|u1<<6|u2}else{u0=(u0&7)<<18|u1<<12|u2<<6|heapOrArray[idx++]&63}if(u0<65536){str+=String.fromCharCode(u0)}else{var ch=u0-65536;str+=String.fromCharCode(55296|ch>>10,56320|ch&1023)}}return str};var UTF8ToString=(ptr,maxBytesToRead)=>ptr?UTF8ArrayToString(HEAPU8,ptr,maxBytesToRead):"";var ccall=(ident,returnType,argTypes,args,opts)=>{var toC={string:str=>{var ret=0;if(str!==null&&str!==undefined&&str!==0){ret=stringToUTF8OnStack(str)}return ret},array:arr=>{var ret=stackAlloc(arr.length);writeArrayToMemory(arr,ret);return ret}};function convertReturnValue(ret){if(returnType==="string"){return UTF8ToString(ret)}if(returnType==="boolean")return Boolean(ret);return ret}var func=getCFunc(ident);var cArgs=[];var stack=0;if(args){for(var i=0;i<args.length;i++){var converter=toC[argTypes[i]];if(converter){if(stack===0)stack=stackSave();cArgs[i]=converter(args[i])}else{cArgs[i]=args[i]}}}var previousAsync=Asyncify.currData;var ret=func(...cArgs);function onDone(ret){runtimeKeepalivePop();if(stack!==0)stackRestore(stack);return convertReturnValue(ret)}var asyncMode=opts?.async;runtimeKeepalivePush();if(Asyncify.currData!=previousAsync){return Asyncify.whenDone().then(onDone)}ret=onDone(ret);if(asyncMode)return Promise.resolve(ret);return ret};Module["ccall"]=ccall;var cwrap=(ident,returnType,argTypes,opts)=>{var numericArgs=!argTypes||argTypes.every(type=>type==="number"||type==="boolean");var numericRet=returnType!=="string";if(numericRet&&numericArgs&&!opts){return getCFunc(ident)}return(...args)=>ccall(ident,returnType,argTypes,args,opts)};Module["cwrap"]=cwrap;xpu_cpu_support();var wasmImports={e:_emscripten_resize_heap,a:_pv_console_log_wasm,c:_pv_file_close_wasm,d:_pv_file_open_wasm,b:_pv_file_read_wasm,k:_pv_file_seek_wasm,j:_pv_file_tell_wasm,i:_pv_file_write_wasm,h:_pv_get_browser_info,l:_pv_get_origin_info,f:_pv_https_request_wasm,m:_pv_time_wasm,g:_pv_xpu_get_max_workers_wasm};var wasmExports=createWasm();var ___wasm_call_ctors=()=>(___wasm_call_ctors=wasmExports["o"])();var _pv_status_to_string=Module["_pv_status_to_string"]=a0=>(_pv_status_to_string=Module["_pv_status_to_string"]=wasmExports["q"])(a0);var _pv_porcupine_delete=Module["_pv_porcupine_delete"]=a0=>(_pv_porcupine_delete=Module["_pv_porcupine_delete"]=wasmExports["r"])(a0);var _pv_porcupine_version=Module["_pv_porcupine_version"]=()=>(_pv_porcupine_version=Module["_pv_porcupine_version"]=wasmExports["s"])();var _pv_porcupine_init=Module["_pv_porcupine_init"]=(a0,a1,a2,a3,a4,a5,a6)=>(_pv_porcupine_init=Module["_pv_porcupine_init"]=wasmExports["t"])(a0,a1,a2,a3,a4,a5,a6);var _pv_porcupine_process=Module["_pv_porcupine_process"]=(a0,a1,a2)=>(_pv_porcupine_process=Module["_pv_porcupine_process"]=wasmExports["u"])(a0,a1,a2);var _pv_porcupine_frame_length=Module["_pv_porcupine_frame_length"]=()=>(_pv_porcupine_frame_length=Module["_pv_porcupine_frame_length"]=wasmExports["v"])();var _pv_porcupine_list_hardware_devices=Module["_pv_porcupine_list_hardware_devices"]=(a0,a1)=>(_pv_porcupine_list_hardware_devices=Module["_pv_porcupine_list_hardware_devices"]=wasmExports["w"])(a0,a1);var _pv_porcupine_free_hardware_devices=Module["_pv_porcupine_free_hardware_devices"]=(a0,a1)=>(_pv_porcupine_free_hardware_devices=Module["_pv_porcupine_free_hardware_devices"]=wasmExports["x"])(a0,a1);var _free=a0=>(_free=wasmExports["y"])(a0);var _malloc=Module["_malloc"]=a0=>(_malloc=Module["_malloc"]=wasmExports["z"])(a0);var _pv_log_enable=Module["_pv_log_enable"]=()=>(_pv_log_enable=Module["_pv_log_enable"]=wasmExports["A"])();var _pv_log_disable=Module["_pv_log_disable"]=()=>(_pv_log_disable=Module["_pv_log_disable"]=wasmExports["B"])();var _pv_set_home_dir=Module["_pv_set_home_dir"]=a0=>(_pv_set_home_dir=Module["_pv_set_home_dir"]=wasmExports["C"])(a0);var _aligned_alloc=Module["_aligned_alloc"]=(a0,a1)=>(_aligned_alloc=Module["_aligned_alloc"]=wasmExports["D"])(a0,a1);var _pv_get_sdk=Module["_pv_get_sdk"]=()=>(_pv_get_sdk=Module["_pv_get_sdk"]=wasmExports["E"])();var _pv_sample_rate=Module["_pv_sample_rate"]=()=>(_pv_sample_rate=Module["_pv_sample_rate"]=wasmExports["F"])();var _pv_set_sdk=Module["_pv_set_sdk"]=a0=>(_pv_set_sdk=Module["_pv_set_sdk"]=wasmExports["G"])(a0);var _pv_free=Module["_pv_free"]=a0=>(_pv_free=Module["_pv_free"]=wasmExports["H"])(a0);var _pv_get_error_stack=Module["_pv_get_error_stack"]=(a0,a1)=>(_pv_get_error_stack=Module["_pv_get_error_stack"]=wasmExports["I"])(a0,a1);var _pv_free_error_stack=Module["_pv_free_error_stack"]=a0=>(_pv_free_error_stack=Module["_pv_free_error_stack"]=wasmExports["J"])(a0);var __emscripten_memcpy_bulkmem=Module["__emscripten_memcpy_bulkmem"]=(a0,a1,a2)=>(__emscripten_memcpy_bulkmem=Module["__emscripten_memcpy_bulkmem"]=wasmExports["K"])(a0,a1,a2);var __emscripten_memset_bulkmem=Module["__emscripten_memset_bulkmem"]=(a0,a1,a2)=>(__emscripten_memset_bulkmem=Module["__emscripten_memset_bulkmem"]=wasmExports["L"])(a0,a1,a2);var __emscripten_stack_restore=a0=>(__emscripten_stack_restore=wasmExports["M"])(a0);var __emscripten_stack_alloc=a0=>(__emscripten_stack_alloc=wasmExports["N"])(a0);var _emscripten_stack_get_current=()=>(_emscripten_stack_get_current=wasmExports["O"])();var _asyncify_start_unwind=a0=>(_asyncify_start_unwind=wasmExports["P"])(a0);var _asyncify_stop_unwind=()=>(_asyncify_stop_unwind=wasmExports["Q"])();var _asyncify_start_rewind=a0=>(_asyncify_start_rewind=wasmExports["R"])(a0);var _asyncify_stop_rewind=()=>(_asyncify_stop_rewind=wasmExports["S"])();Module["addFunction"]=addFunction;var calledRun;dependenciesFulfilled=function runCaller(){if(!calledRun)run();if(!calledRun)dependenciesFulfilled=runCaller};function run(){if(runDependencies>0){return}preRun();if(runDependencies>0){return}function doRun(){if(calledRun)return;calledRun=true;Module["calledRun"]=true;if(ABORT)return;initRuntime();readyPromiseResolve(Module);Module["onRuntimeInitialized"]?.();postRun()}if(Module["setStatus"]){Module["setStatus"]("Running...");setTimeout(function(){setTimeout(function(){Module["setStatus"]("")},1);doRun()},1)}else{doRun()}}if(Module["preInit"]){if(typeof Module["preInit"]=="function")Module["preInit"]=[Module["preInit"]];while(Module["preInit"].length>0){Module["preInit"].pop()()}}run();moduleRtn=readyPromise;


  return moduleRtn;
}
);
})();
export default pv_porcupine_simd;
