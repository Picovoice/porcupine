<!DOCTYPE html>
<html lang="en">

<head>
  <title>unit test - PorcupineWeb</title>
  <script src="../dist/iife/index.js"></script>
  <script src="./porcupine_params.js"></script>
  <script type="application/javascript">

    let pcm = null;

    const customKeyword64 = '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';

    function convertAudioBuffer(audioBuffer) {
      const f32PCM = audioBuffer.getChannelData(0);
      const i16PCM = new Int16Array(f32PCM.length);

      const INT16_MAX = 32767;
      const INT16_MIN = -32768;
      i16PCM.set(
        f32PCM.map((f) => {
          let i = Math.trunc(f * INT16_MAX);
          if (f > INT16_MAX) i = INT16_MAX;
          if (f < INT16_MIN) i = INT16_MIN;
          return i;
        })
      );
      return i16PCM;
    }

    var audioContext;

    window.onload = function () {
      audioContext = new (window.AudioContext || window.webKitAudioContext)(
        {sampleRate: 16000}
      );

      function readAudioFile(selectedFile, callback) {
        let reader = new FileReader();
        reader.onload = function (ev) {
          let wavBytes = reader.result;
          audioContext.decodeAudioData(wavBytes, callback);
        };
        reader.readAsArrayBuffer(selectedFile);
      }

      const fileSelector = document.getElementById("audioFile");
      fileSelector.addEventListener("change", (event) => {
        document.getElementById("audioLoaded").style.display = "none";

        writeMessage("Loading audio file...");
        const fileList = event.target.files;
        readAudioFile(fileList[0], (audioBuffer) => {
          pcm = convertAudioBuffer(audioBuffer);
          document.getElementById("audioLoaded").style.display = "block";
          writeMessage("Loading audio file... done!");
        });
      });
    }

    async function loadAudioFile(filepath) {
      return fetch(filepath)
        .then(data => data.arrayBuffer())
        .then(arrayBuffer => audioContext.decodeAudioData(arrayBuffer))
        .then(audioBuffer => convertAudioBuffer(audioBuffer))
    }

    function writeMessage(message) {
      console.log(message);
      let p = document.createElement("p");
      let text = document.createTextNode(message);
      p.appendChild(text);
      document.body.appendChild(p);
    }

    async function loadTestData() {
      return fetch('test_data.json').then((response) => response.json())
    }

    function assertEquals(expected, actual, failureMessage) {
      if (expected !== actual) {
        throw new Error(failureMessage);
      }
    }

    let workerCbCount = 0;
    let detections = new Map();

    function porcupineKeywordCallback(keyword) {
      workerCbCount++;
      detections.set(keyword.index, (detections.get(keyword.index) ?? 0) + 1);
    }

    async function porcupineDetectionCounts(engineInstance, pcm) {
      workerCbCount = 0;
      detections = new Map();

      let totalCount = 1;
      let frameLength = engineInstance.frameLength;
      for (let i = 0; i < (pcm.byteLength / pcm.BYTES_PER_ELEMENT); i += frameLength) {
        engineInstance.process(pcm.slice(i, i + frameLength));
        totalCount += 1;
      }

      return new Promise(resolve => {
        const interval = setInterval(() => {
          resolve(workerCbCount);
        }, 1000);
      });
    }

    async function startTest() {
      document.getElementById("testComplete").style.display = "none";
      let is_failed = undefined

      writeMessage("Starting test...");

      const accessKey = document.getElementById("accessKey").value;

      if (!pcm) {
        writeMessage("Audio file not provided...");
        return
      }

      try {
        writeMessage("Checking Porcupine 'fromPublicDirectory'");
        let handle = await PorcupineWeb.Porcupine.create(
          accessKey,
          PorcupineWeb.BuiltInKeyword.Porcupine,
          porcupineKeywordCallback,
          {
            publicPath: "porcupine_params.pv",
            forceWrite: true,
          });
        await porcupineDetectionCounts(handle, pcm);
        assertEquals(2, detections.get(0), 'Failed to detect the keyword');
        handle.release()
        writeMessage("Checking Porcupine 'fromPublicDirectory'... done!");

        writeMessage("Checking Porcupine 'fromPublicDirectory' with custom keyword");
        handle = await PorcupineWeb.Porcupine.create(
          accessKey,
          {
            label: "custom",
            sensitivity: 0.7,
            base64: customKeyword64,
            customWritePath: "custom_path.ppn",
            forceWrite: true,
            version: 2,
          },
          porcupineKeywordCallback,
          {
            publicPath: "porcupine_params.pv",
            forceWrite: true,
          });
        await porcupineDetectionCounts(handle, pcm);
        assertEquals(2, detections.get(0), 'Failed to detect the keyword');
        handle.release()
        writeMessage("Checking Porcupine 'fromPublicDirectory'... done!");

        writeMessage("Checking Porcupine 'fromBase64'");
        handle = await PorcupineWeb.Porcupine.create(
          accessKey,
          PorcupineWeb.BuiltInKeyword.Porcupine,
          porcupineKeywordCallback,
          {
            base64: modelParams,
            forceWrite: true,
          });
        await porcupineDetectionCounts(handle, pcm);
        assertEquals(2, detections.get(0), 'Failed to detect the keyword');
        handle.release()
        writeMessage("Checking Porcupine 'fromBase64'... done!");

        writeMessage("Checking PorcupineWorker 'fromPublicDirectory'");
        handle = await PorcupineWeb.PorcupineWorker.create(
          accessKey,
          PorcupineWeb.BuiltInKeyword.Porcupine,
          porcupineKeywordCallback,
          {
            publicPath: "porcupine_params.pv",
            forceWrite: true,
          });
        await porcupineDetectionCounts(handle, pcm);
        assertEquals(2, detections.get(0), 'Failed to detect the keyword');
        handle.release()
        writeMessage("Checking PorcupineWorker 'fromPublicDirectory'... done!");

        writeMessage("Checking PorcupineWorker 'fromPublicDirectory' with custom keyword");
        handle = await PorcupineWeb.PorcupineWorker.create(
          accessKey,
          {
            label: "custom2",
            sensitivity: 0.6,
            base64: customKeyword64,
            customWritePath: "custom2_path.ppn",
            forceWrite: true,
            version: 2,
          },
          porcupineKeywordCallback,
          {
            publicPath: "porcupine_params.pv",
            forceWrite: true,
          });
        await porcupineDetectionCounts(handle, pcm);
        assertEquals(2, detections.get(0), 'Failed to detect the keyword');
        handle.release()
        writeMessage("Checking PorcupineWorker 'fromPublicDirectory'... done!");

        writeMessage("Checking PorcupineWorker 'fromBase64'");
        handle = await PorcupineWeb.PorcupineWorker.create(
          accessKey,
          PorcupineWeb.BuiltInKeyword.Porcupine,
          porcupineKeywordCallback,
          {
            base64: modelParams,
            forceWrite: true,
          });
        await porcupineDetectionCounts(handle, pcm);
        assertEquals(2, detections.get(0), 'Failed to detect the keyword');
        handle.release()
        writeMessage("Checking PorcupineWorker 'fromBase64'... done!");

        writeMessage("Checking invalid public path");
        is_failed = false
        try {
          await PorcupineWeb.Porcupine.create(
            accessKey,
            PorcupineWeb.BuiltInKeyword.Porcupine,
            porcupineKeywordCallback,
            {
              publicPath: "invalid",
              forceWrite: true,
            });
        } catch (e) {
          is_failed = true;
        }
        assertEquals(true, is_failed, 'Failed to handle invalid path');
        is_failed = false
        try {
          await PorcupineWeb.Porcupine.create(
            accessKey,
            PorcupineWeb.BuiltInKeyword.Porcupine,
            porcupineKeywordCallback,
            {
              publicPath: "invalid",
              forceWrite: true,
            });
        } catch (e) {
          is_failed = true;
        }
        assertEquals(true, is_failed, 'Failed to handle invalid path');
        writeMessage("Checking invalid public path... done!");

        writeMessage("Checking invalid base64 string");
        is_failed = false
        try {
          await PorcupineWeb.Porcupine.create(
            accessKey,
            PorcupineWeb.BuiltInKeyword.Porcupine,
            porcupineKeywordCallback,
            {
              base64: "invalid",
              forceWrite: true,
            });
        } catch (e) {
          is_failed = true;
        }
        assertEquals(true, is_failed, 'Failed to handle invalid base64 string');

        is_failed = false
        try {
          await PorcupineWeb.PorcupineWorker.create(
            accessKey,
            porcupineKeywordCallback,
            {
              base64: "invalid",
              forceWrite: true,
            });
        } catch (e) {
          is_failed = true;
        }
        assertEquals(true, is_failed, 'Failed to handle invalid base64 string');
        writeMessage("Checking invalid base64 string... done!");

        writeMessage("Checking invalid access key");
        is_failed = false
        try {
          await PorcupineWeb.Porcupine.create(
            "invalid",
            PorcupineWeb.BuiltInKeyword.Porcupine,
            {
              publicPath: "porcupine_params.pv",
              forceWrite: true,
            });
        } catch (e) {
          is_failed = true;
        }
        assertEquals(true, is_failed, 'Failed to handle invalid access key');

        is_failed = false
        try {
          await PorcupineWeb.PorcupineWorker.create(
            "invalid",
            PorcupineWeb.BuiltInKeyword.Porcupine,
            porcupineKeywordCallback,
            {
              publicPath: "porcupine_params.pv",
              forceWrite: true,
            });
        } catch (e) {
          is_failed = true;
        }
        assertEquals(true, is_failed, 'Failed to handle invalid access key');
        writeMessage("Checking invalid access key... done!");

        writeMessage("Checking builtin keyword 'Grasshopper'...");
        handle = await PorcupineWeb.Porcupine.create(
          accessKey,
          PorcupineWeb.BuiltInKeyword.Grasshopper,
          porcupineKeywordCallback,
          {
            publicPath: "porcupine_params.pv",
            forceWrite: true,
          });
        await porcupineDetectionCounts(handle, pcm);
        assertEquals(1, detections.get(0), 'Failed to create an instance with a builtin keyword');
        handle.release()
        writeMessage("Checking builtin keyword 'Grasshopper'... done!");

        writeMessage("Checking single keyword multiple detection...");
        handle = await PorcupineWeb.Porcupine.create(
          accessKey,
          PorcupineWeb.BuiltInKeyword.Porcupine,
          porcupineKeywordCallback,
          {
            publicPath: "porcupine_params.pv",
            forceWrite: true,
          });
        await porcupineDetectionCounts(handle, pcm);
        assertEquals(2, detections.get(0), 'Failed to detect a single keyword multiple times');
        handle.release()
        writeMessage("Checking single keyword multiple detection... done!");

        writeMessage("Checking multiple keyword multiple detection...");
        handle = await PorcupineWeb.Porcupine.create(
          accessKey,
          [PorcupineWeb.BuiltInKeyword.Americano, PorcupineWeb.BuiltInKeyword.Bumblebee],
          porcupineKeywordCallback,
          {
            publicPath: "porcupine_params.pv",
            forceWrite: true,
          });
        await porcupineDetectionCounts(handle, pcm);
        assertEquals(1, detections.get(0), 'Failed to detect multiple keywords');
        assertEquals(1, detections.get(1), 'Failed to detect multiple keywords');
        handle.release()
        writeMessage("Checking multiple keyword multiple detection... done!");

        writeMessage("Checking invalid builtin keyword type...");
        is_failed = false;
        try {
          handle = await PorcupineWeb.Porcupine.create(
            accessKey,
            'octopus',
            porcupineKeywordCallback,
            {
              publicPath: "porcupine_params.pv",
              forceWrite: true,
            });
        } catch (error) {
          is_failed = true;
        }
        assertEquals(true, is_failed, 'Failed to handle invalid built-in keyword')
        writeMessage("Checking invalid builtin keyword type... done!");

        writeMessage("Checking UTF-8 paths...");
        handle = await PorcupineWeb.Porcupine.create(
          accessKey,
          {
            label: "ヤマアラシ",
            sensitivity: 0.7,
            base64: customKeyword64,
            customWritePath: "ヤマアラシ.ppn",
            forceWrite: true,
            version: 2,
          },
          porcupineKeywordCallback,
          {
            customWritePath: "ヤマアラシ_params.pv",
            publicPath: "porcupine_params.pv",
            forceWrite: true,
          });
        handle.release()
        writeMessage("Checking UTF-8 paths... done!");

        writeMessage("Checking basic parameter validation...");
        is_failed = false;
        try {
          handle = await PorcupineWeb.Porcupine.create(
            accessKey,
            {
              builtin: PorcupineWeb.BuiltInKeyword.Picovoice,
              sensitivity: 4.2
            },
            porcupineKeywordCallback,
            {
              publicPath: "porcupine_params.pv",
              forceWrite: true,
            });
        } catch (error) {
          is_failed = true;
        }
        assertEquals(true, is_failed, 'Failed to handle invalid sensitivity value')

        is_failed = false;
        try {
          handle = await PorcupineWeb.Porcupine.create(
            accessKey,
            {
              builtin: PorcupineWeb.BuiltInKeyword.Picovoice,
              sensitivity: 'high'
            },
            porcupineKeywordCallback,
            {
              publicPath: "porcupine_params.pv",
              forceWrite: true,
            });
        } catch (error) {
          is_failed = true;
        }
        assertEquals(true, is_failed, 'Failed to handle incorrect sensitivity type')
        writeMessage("Checking basic parameter validation... done!");

        const testData = await loadTestData()
        for (const testInfo of testData.tests.singleKeyword) {
          writeMessage(`Testing singleKeyword for ${testInfo.language}...`);
          let handle = await PorcupineWeb.Porcupine.create(
            accessKey,
            {
              label: testInfo.wakeword,
              publicPath: `keywords/${testInfo.wakeword}_wasm.ppn`,
              forceWrite: true,
            },
            porcupineKeywordCallback,
            {
              publicPath: testInfo.language === 'en' ? "porcupine_params.pv" : `porcupine_params_${testInfo.language}.pv`,
              forceWrite: true,
            });
          const testPcm = await loadAudioFile(`audio_samples/${testInfo.wakeword.replaceAll(' ', '_')}.wav`)
          await porcupineDetectionCounts(handle, testPcm);
          assertEquals(1, detections.get(0), 'Failed to detect the keyword');
          handle.release()
          writeMessage(`Testing singleKeyword for ${testInfo.language}... done!`);
        }

        writeMessage("Test passed!")

      } catch (error) {
        writeMessage(error);
        writeMessage("Test failed!")
      } finally {
        document.getElementById("testComplete").style.display = "block";
      }
    }

    const numIterations = 15;

    async function performanceTest() {
      document.getElementById("testComplete").style.display = "none";

      const accessKey = document.getElementById("accessKey").value;
      let handle = null;

      try {
        writeMessage("Starting init performance test!");
        let start = Date.now();
        for (let i = 0; i < numIterations; i++) {
          handle = await PorcupineWeb.PorcupineWorker.create(
            accessKey,
            PorcupineWeb.BuiltInKeyword.Porcupine,
            porcupineKeywordCallback,
            {
              publicPath: "porcupine_params.pv",
              forceWrite: true,
            });
          handle.terminate();
        }
        let end = Date.now();
        writeMessage(`Init Performance: ${((end - start) / 1000) / numIterations}`);

        handle = await PorcupineWeb.PorcupineWorker.create(
          accessKey,
          PorcupineWeb.BuiltInKeyword.Porcupine,
          porcupineKeywordCallback,
          {
            publicPath: "porcupine_params.pv",
            forceWrite: true,
          });
        writeMessage("Starting process performance test!");
        start = Date.now();
        for (let i = 0; i < numIterations; i++) {
          await porcupineDetectionCounts(handle, pcm);
        }
        end = Date.now();
        writeMessage(`Process Performance: ${((end - start) / 1000) / numIterations}`);
        handle.release();
      } catch (e) {
        console.log(e)
        writeMessage("Test failed!")
      } finally {
        document.getElementById("testComplete").style.display = "block";
      }
    }
  </script>
</head>

<body>
<h1>Porcupine web binding test</h1>
<p>After entering the AccessKey and audio file, click the "Test Porcupine" button. For the result, refer to the
  browser console.</p>

<p>
  <label for="accessKey">AccessKey string obtained from
    <a href="https://picovoice.ai/console/">Picovoice Console</a>:</label>
  <input type="text" id="accessKey" name="accessKey"/>
</p>

<p>
  <label for="audioFile">Select audio file located on
    {PROJECT_ROOT}/resources/audio_samples/multiple_keywords.wav:</label>
  <input type="file" id="audioFile" name="audioFile" accept="audio/*"/>
</p>

<input type="button" id="submit" value="Test Porcupine" onclick="startTest()"/>
<input type="button" id="perfTest" value="Test Porcupine Performance" onclick="performanceTest()"/>

<br>

<h4 id="audioLoaded" style="display: none;">Audio file loaded!</h4>
<h4 id="testComplete" style="display: none;">Test Complete!</h4>
<hr/>
</body>

</html>
